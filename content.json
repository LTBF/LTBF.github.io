[{"title":"SSH连接虚拟机Ubuntu","date":"2020-08-14T16:00:00.000Z","path":"2020/08/15/SSH连接虚拟机Ubuntu/","text":"1. 查看虚拟机ip地址在Ubuntu下输入命令查看ip地址： 1ifconfig 2. 测试ip地址是否可达Windows下打开cmd，输入： 1ping [ip地址] 3. 安装ssh首先测试Ubuntu是否安装ssh: 1ssh localhost 若连接失败，则需要安装ssh服务： 1sudo apt-get install openssh-server 安装完成后，确认ssh服务处于启动状态： 1sudo service ssh status 出现Active: active (running)，代表正在正在运行。 4. 使用XShell或git连接Ubuntu","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]},{"title":"2021美团正式批笔试8.15","date":"2020-08-14T16:00:00.000Z","path":"2020/08/15/2021美团正式批笔试8.15/","text":"1. 特殊的逆序对如果一个数的四倍是它的逆序数，那么这两个数就构成了一个逆序数对。给一个正整数n，求不大于n的正整数构成的逆序数对。 提示： 11234的逆序数是4321，1100的逆序数是11 输入： 1输入正整数n 输出： 12第一行输出共有多少对逆序数从第二行开始每行输出一对逆序数，按第一个数从小到达开始输出，没有就不输出 示例： 12345输入：10000输出：12178 8712 *没有考虑到4i可能已经超出了n，最终代码只通过了55%：** 1234567891011121314151617181920212223242526272829303132333435363738import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); for(int i = 1; i &lt;= n; i++)&#123; int t = i * 4; if(t &lt;= n &amp;&amp; judge(i))&#123; // 丢掉了重要条件 list.add(new int[]&#123;i, t&#125;); &#125; &#125; System.out.println(list.size()); for(int[] arr : list)&#123; System.out.println(arr[0] + &quot; &quot; + arr[1]); &#125; &#125; private static boolean judge(int a) &#123; String str1 = String.valueOf(a); int b = Integer.valueOf(new StringBuilder(str1).reverse().toString()); return a*4 == b; &#125;&#125; 2. 统计旅行次数每次旅行会从一个城市出发，经过若干城市后回到出发的城市。现给出若干次旅行所有的城市之间的通行信息，请你找出总共旅行了多少次。其中不会包括无效的旅行信息。 输入： 12第一行输入n，代表通行信息条数此后每行输入出发城市，到达城市 输出： 1一共旅行了多少次 示例： 12345678910输入：6beijing chongqingchongqing hangzhouhangzhou beijingbeijing xianxian beijing输出：2 看评论才知道，要考虑A-A这种情况（但自己的代码没问题啊），代码只通过了91%： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.*;&#x2F;** * @author shkstart * @create 2020-08-15 16:36 *&#x2F;public class Two &#123; public static void main(String[] args) &#123; Scanner scan &#x3D; new Scanner(System.in); int n &#x3D; Integer.valueOf(scan.nextLine()); Map&lt;String, List&lt;String&gt;&gt; map &#x3D; new HashMap&lt;&gt;(); for(int i &#x3D; 0; i &lt; n; i++)&#123; String[] strs &#x3D; scan.nextLine().split(&quot; &quot;); List&lt;String&gt; list &#x3D; map.getOrDefault(strs[0], new ArrayList&lt;&gt;()); list.add(strs[1]); map.put(strs[0], list); &#125; int ct &#x3D; 0; for(String key : map.keySet())&#123; List&lt;String&gt; list &#x3D; map.get(key); while(list.size() &gt; 0)&#123; if(dfs(key, key, map))&#123; ct++; &#125; &#125; &#125; System.out.println(ct); &#125; private static boolean dfs(String start, String key, Map&lt;String, List&lt;String&gt;&gt; map) &#123; List&lt;String&gt; list &#x3D; map.get(key); int i &#x3D; 0; boolean res &#x3D; false; for(i &#x3D; 0; i &lt; list.size(); i++)&#123; String next &#x3D; list.get(i); if(next.equals(start))&#123; res &#x3D; true; &#125; else&#123; res &#x3D; dfs(start, next, map); &#125; if(res)&#123; break; &#125; &#125; if(res)&#123; list.remove(i); &#125; return res; &#125;&#125; 补充： 真无语，难道真的是自己审题有问题吗，看到有人居然一遍遍历就过了，把题想难了： 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int count; cin&gt;&gt;count; vector&lt;pair&lt;string,string&gt;&gt;res; string str1,str2; for(int i &#x3D; 0;i &lt; count;i++)&#123; cin&gt;&gt;str1&gt;&gt;str2; res.push_back(&#123;str1,str2&#125;); &#125; int len &#x3D; 1; count &#x3D; res.size(); for(int i &#x3D; 0;i &lt; count - 1;i++)&#123; if(res[i].second !&#x3D; res[i + 1].first)len++; &#125; cout&lt;&lt;len&lt;&lt;endl; return 0;&#125; 3. 小区人员划分有n个人编号1-n，给出关系&lt;a, b&gt;代表a和b同属一个小区。请你根据给出的关系，对人员进行划分。 输入： 12第一行输入n，m分别代表人员数，和关系数第二行开始每行输入关系a b , 共输入m行 输出： 123第一行输出n个人共有几个小区此后每行，输出每个小区的人员，编号递增小区顺序：编号最小的人员的编号越小，越优先输出 示例： 1 通过并查集思想，不难解决，此次笔试唯一AC的题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.*;&#x2F;** * @author shkstart * @create 2020-08-15 17:24 *&#x2F;public class Three &#123; public static void main(String[] args) &#123; Scanner scan &#x3D; new Scanner(System.in); int n &#x3D; scan.nextInt(), m &#x3D; scan.nextInt(); int[] mark &#x3D; new int[n+1]; Map&lt;Integer, List&lt;Integer&gt;&gt; map &#x3D; new HashMap&lt;&gt;(); for(int i &#x3D; 1; i &lt;&#x3D; n ;i++)&#123; mark[i] &#x3D; i; List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(); list.add(i); map.put(i, list); &#125; for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123; int a &#x3D; scan.nextInt(), b &#x3D; scan.nextInt(); int c_a &#x3D; mark[a], c_b &#x3D; mark[b]; if(c_a &#x3D;&#x3D; c_b)&#123; continue; &#125; List&lt;Integer&gt; listA&#x3D; map.get(c_a); List&lt;Integer&gt; listB &#x3D; map.get(c_b); for(int t : listB)&#123; mark[t] &#x3D; c_a; listA.add(t); &#125; map.remove(c_b); &#125; System.out.println(map.size()); Set&lt;Integer&gt; set &#x3D; new HashSet&lt;&gt;(); for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123; int c &#x3D; mark[i]; if(set.contains(c))&#123; continue; &#125; List&lt;Integer&gt; list &#x3D; map.get(c); Collections.sort(list); for(int num : list)&#123; System.out.print(num + &quot; &quot;); &#125; System.out.println(); set.add(c); &#125; &#125;&#125; 4. 运输的最高收益运输公司有n辆车，位于不同位置。现有两个地方都要用车，每辆车由于位置不同到两地的运输收益也不同。连个地方分别要a辆车，b辆车。请你计算出运输的最大收益。 输入： 123第一行：n, a, b第二行：a1 a2 ... an 每辆车到第一个地方的收益第二行：b1 b2 ... bn 每辆车到第二个地方的收益 输出： 1最大收益 示例： 123456输入：5 2 24 3 5 5 12 3 4 3 5输出：18 这道题应该是道动态规划的题，和背包也挺像的，暂时没思路： 1","tags":[{"name":"笔试","slug":"笔试","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"}]},{"title":"Hello World","date":"2020-08-14T10:47:07.063Z","path":"2020/08/14/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"背包问题解析","date":"2020-08-13T16:00:00.000Z","path":"2020/08/14/背包问题解析/","text":"1. 0-1背包背包的能容纳的最大重量为W，有N个物品，每个物品的重量为wi，价值为vi。求背包可容纳的物品的最大价值。 定义二维数组dp[N][W]，dp[i][j]表示前i个物品在重量不超过j的情况下能容纳物品的最大价值。设第i件物品的重量为wi, 价值为vi，根据第i件物品是否在背包中，可以有两种情况： 第i件物品不放在背包中，dp[i][j]（前i件物品放入容量为j的背包的最大价值） = dp[i-1][j]（前i-1件物品放入容量为j的背包的最大价值） 第i件物品放入背包中，dp[i][j]（前i件物品放入容量为j的背包的最大价值） = dp[i-1][j-wi] + vi（前i-1件物品放入容量为j-wi的背包的最大价值 + vi） dp[i][j]应该取两者的较大的，状态转移方程为：$$dp[i][j] = max{dp[i-1][j],\\quad dp[i-1][j-w_i],+,v_i}$$ 12345678910111213141516public int solve(int[] weights, int[] values, int W, int N)&#123; int[][] dp &#x3D; new int[N+1][W+1]; for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123; int w &#x3D; weights[i-1], v &#x3D; values[i-1]; for(int j &#x3D; 1; j &lt;&#x3D; W; j++)&#123; dp[i][j] &#x3D; dp[i-1][j]; if(j - w &gt;&#x3D; 0)&#123; dp[i][j] &#x3D; Math.max(dp[i][j], dp[i-1][j-w] + v); &#125; &#125; &#125; return dp[N][W];&#125; 空间优化 观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。此时，$$dp[j] = max{dp[j],,, dp[j-w_i],+,v_i}$$因为dp[j-wi]代表的是dp[i-1][j-wi]，为了避免覆盖掉dp[i-1][j-wi]，也就是说要先计算 dp[i][j] 再计算 dp[i][j-wi]，在程序实现时需要按倒序来循环求解。 1234567891011121314public int solve(int[] weights, int[] values, int W, int N)&#123; int[] dp &#x3D; new int[W+1]; for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123; int w &#x3D; weights[i-1], v &#x3D; values[i-1]; &#x2F;&#x2F; dp[j] 代表没有第i件物品容量为j的最大价值 for(int j &#x3D; W; j &gt;&#x3D; w; j--)&#123; dp[j] &#x3D; Math.max([j], dp[j-w] + v); &#125; &#125; return dp[N][W];&#125; 例题 416. 分割等和子集 我们可以先求出数组所有元素的和sum，问题可以转化为0-1背包问题：背包的容量为sum/2，原数组就是每件物品的重量，判断背包是否可以正好装满。 此问题没有涉及物品的价值：求的是是否能将背包装满，所以无需考虑物品的价值。 12345678910111213141516171819202122232425public boolean canPartition(int[] nums) &#123; int n &#x3D; nums.length; int sum &#x3D; 0; for(int m : nums)&#123; sum +&#x3D; m; &#125; if(sum % 2 &#x3D;&#x3D; 1)&#123; return false; &#125; int S &#x3D; sum &#x2F; 2; boolean[] dp &#x3D; new boolean[S+1]; dp[0] &#x3D; true; for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123; &#x2F;&#x2F; 每个物品只用一次 int weight &#x3D; nums[i-1]; for(int j &#x3D; S; j &gt;&#x3D; weight; j--)&#123; &#x2F;&#x2F; 从后往前，先计算dp[j]，再计算dp[j-1] dp[j] &#x3D; dp[j] || dp[j-weight]; &#x2F;&#x2F; ***** &#125; &#125; return dp[S];&#125; 494. 目标和 将数组按符号分为两个集和：带正号集和S1，带符号集和S2，可以得出：$$sum(S1) - sum(S2) = target\\sum(S1) + sum(S2) ,=, sum$$可以得出：$$2*sum(S1) = target + sum$$ 问题也可以转化为0-1背包问题：容量为(target+sum)/2，物品为数组，求有多少种方式可以将背包放满。 此问题求解的是背包放满有多少种方式，同样没有涉及到物品价值。 1234567891011121314151617181920212223public int findTargetSumWays(int[] nums, int S) &#123; int sum &#x3D; 0; for(int m : nums)&#123; sum +&#x3D; m; &#125; if((sum + S) % 2 &#x3D;&#x3D; 1 || sum &lt; S)&#123; &#x2F;&#x2F; 注意这里，否则会超出内存 return 0; &#125; int T &#x3D; (sum + S) &#x2F; 2; int[] dp &#x3D; new int [T + 1]; dp[0] &#x3D; 1; int n &#x3D; nums.length; for(int weight : nums)&#123; for(int j &#x3D; T; j &gt;&#x3D; weight; j--)&#123; dp[j] +&#x3D; dp[j-weight]; &#125; &#125; return dp[T];&#125; 这道题数组长度不会超过20，同样可以用DFS求解，时间复杂度O(2^n)。 474. 一和零 这道题如果仔细考虑一下，也是个0-1背包问题：背包的容量有两个限制m和n，物品就是字符串数组，每个物品的代价就是字符串中0和1的数量，求背包中最多能放如多少个物品。 12345678910111213141516171819202122232425public int findMaxForm(String[] strs, int m, int n) &#123; int[][] dp &#x3D; new int[m+1][n+1]; &#x2F;&#x2F; 背包有两个限制属性 for(String s : strs)&#123; &#x2F;&#x2F; 每个物品只能放一次 int zero &#x3D; 0, one &#x3D; 0; &#x2F;&#x2F; 物品的两个属性代价 for(char ch : s.toCharArray())&#123; if(ch &#x3D;&#x3D; &#39;0&#39;)&#123; zero++; &#125; else&#123; one++; &#125; &#125; for(int j &#x3D; m; j &gt;&#x3D; zero; j--)&#123; &#x2F;&#x2F; 0 for(int k &#x3D; n; k &gt;&#x3D; one; k--)&#123; &#x2F;&#x2F; 1 dp[j][k] &#x3D; Math.max(dp[j][k], dp[j-zero][k-one] + 1); &#125; &#125; &#125; return dp[m][n];&#125; 0-1背包的特点 N个物品，每个物品两个属性&lt;w, v&gt; 每个物品在背包中可以放0个或1个 求容量不超出下的最大价值 2. 完全背包背包的能容纳的最大重量为W，有N个物品，每个物品的重量为wi，价值为vi。求背包可容纳的物品的最大价值。完全背包问题中，每个物品放入的数量是不受限制的。 dp[i][j]表示前i个物品&lt;wi, vi&gt;放入容量为j背包时的最大代价，根据第i个物品放入到背包的状况，可以得到状态转移方程：$$dp[i][j] = max{dp[i-1][j],, dp[i-1][j-w_i] + v_i,, dp[i-1][j-2w_i]+2v_i,….}$$ 1234567891011121314151617181920212223242526272829303132public int solve(int[] weights, int[] values, int W, int N)&#123; int[][] dp &#x3D; new int[N+1][W+1]; for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123; &#x2F;&#x2F; 放入每个物品 int w &#x3D; weights[i-1], v &#x3D; values[i-1]; &#x2F;&#x2F; 物品的代价和价值 for(int j &#x3D; 1; j &lt;&#x3D; W; j++)&#123; &#x2F;&#x2F; dp[i][j] &#x3D; dp[i-1][j]; &#x2F;&#x2F; 不放入第i个物品 for(int k &#x3D; 1; k*w &lt;&#x3D; j; k++)&#123; &#x2F;&#x2F; 放入1个，2个.... dp[i][j] &#x3D; Math.max(dp[i][j], dp[i-1][j-k*w] + k*v); &#125; &#125; &#125; return dp[N][W];&#125;空间压缩后public int solve(int[] weights, int[] values, int W, int N)&#123; int[] dp &#x3D; new int[W+1]; for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123; &#x2F;&#x2F; 放入每个物品 int w &#x3D; weights[i-1], v &#x3D; values[i-1]; &#x2F;&#x2F; 物品的代价和价值 for(int j &#x3D; W; j &gt;&#x3D; 1; j--)&#123; &#x2F;&#x2F; for(int k &#x3D; 1; k*w &lt;&#x3D; j; k++)&#123; &#x2F;&#x2F; 放入1个，2个.... dp[j] &#x3D; Math.max(dp[j], dp[j-k*w] + k*v); &#125; &#125; &#125; return dp[W];&#125; 另一种比较简洁的思路： 1234567891011121314151617public int solve(int[] weights, int[] values, int W, int N)&#123; int[] dp &#x3D; new int[W+1]; Arrays.fill(dp, -1); dp[0] &#x3D; 0; for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123; &#x2F;&#x2F; 放入每个物品 int w &#x3D; weights[i-1], v &#x3D; values[i-1]; &#x2F;&#x2F; 物品的代价和价值 for(int j &#x3D; w; j &lt;&#x3D; W; j++)&#123; &#x2F;&#x2F; if(dp[j-w] !&#x3D; -1)&#123; dp[j] &#x3D; Math.max(dp[j], dp[j-w] + v); &#125; &#125; &#125; return dp[W];&#125; 322. 零钱兑换 此问题是个完全背包问题：物品是硬币，可以无限次放入，背包容量是amount，求能将背包装满的组合数。 123456789101112131415161718192021public int coinChange(int[] coins, int amount) &#123; int[] dp &#x3D; new int[amount+1]; Arrays.fill(dp, -1); dp[0] &#x3D; 0; for(int m : coins[i])&#123; for(int j &#x3D; m; j &lt;&#x3D; amount; j++)&#123; if(dp[j-m] !&#x3D; -1)&#123; if(dp[j] &#x3D;&#x3D; -1)&#123; dp[j] &#x3D; dp[j-m] + 1; &#125; else&#123; dp[j] &#x3D; Math.min(dp[j], dp[j-m]+1); &#125; &#125; &#125; &#125; return dp[amount]; &#125; 518. 零钱兑换 II 完全背包，求组合数。 1234567891011121314public int change(int amount, int[] coins) &#123; int[] dp &#x3D; new int[amount+1]; dp[0] &#x3D; 1; for(int coin : coins)&#123; for(int i &#x3D; coin; i &lt;&#x3D; amount; i++)&#123; dp[i] +&#x3D; dp[i-coin]; &#125; &#125; return dp[amount];&#125; 139. 单词拆分 这道题比较有意思，物品是单词字典，背包的容量是字符串长度，不过它的放入条件是字符串要相同。而且物品放入有先后顺序。带放入顺序的完全背包问题： 123456789101112131415161718&#x2F;&#x2F; 错误解法public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; int len &#x3D; s.length(); boolean[] dp &#x3D; new boolean[len + 1]; dp[0] &#x3D; true; for(String str : wordDict)&#123; for(int i &#x3D; str.length(); i &lt;&#x3D; len; i++)&#123; if(!dp[i] &amp;&amp; dp[i-str.length()] &amp;&amp; isSame(s, i-1, str))&#123; dp[i] &#x3D; true; &#125; &#125; &#125; return dp[len]; &#125; 12345678910111213141516171819202122232425262728293031&#x2F;&#x2F; 正确解法public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; int len &#x3D; s.length(); boolean[] dp &#x3D; new boolean[len + 1]; dp[0] &#x3D; true; for(int i &#x3D; 1; i &lt;&#x3D; len; i++)&#123; for(String str : wordDict)&#123; int l &#x3D; str.length(); if(!dp[i] &amp;&amp; i &gt;&#x3D; l &amp;&amp; isSame(s, i-1, str))&#123; dp[i] |&#x3D; dp[i-l]; &#125; &#125; &#125; return dp[len]; &#125; public boolean isSame(String str, int end, String s)&#123; int i &#x3D; end, j &#x3D; s.length()-1; while(i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0)&#123; if(str.charAt(i) !&#x3D; s.charAt(j))&#123; break; &#125; i--; j--; &#125; return j &#x3D;&#x3D; -1; &#125; 377. 组合总和 Ⅳ 求组合数，不同的序列被视为不同的组合，则需要考虑物品放入背包时的顺序： 1234567891011121314public int combinationSum4(int[] nums, int target) &#123; if (nums &#x3D;&#x3D; null || nums.length &#x3D;&#x3D; 0) &#123; return 0; &#125; int[] maximum &#x3D; new int[target + 1]; maximum[0] &#x3D; 1; Arrays.sort(nums); for (int i &#x3D; 1; i &lt;&#x3D; target; i++) &#123; for (int j &#x3D; 0; j &lt; nums.length &amp;&amp; nums[j] &lt;&#x3D; i; j++) &#123; maximum[i] +&#x3D; maximum[i - nums[j]]; &#125; &#125; return maximum[target];&#125; 无视组合数字的中的先后顺序的话： 123456789101112131415public int combinationSum4(int[] nums, int target) &#123; int[] dp &#x3D; new int[target+1]; dp[0] &#x3D; 1; for(int m : nums)&#123; for(int j &#x3D; m; j &lt;&#x3D; target; j++)&#123; dp[j] +&#x3D; dp[j-m]; &#125; &#125; return dp[target];&#125; 完全背包的特点 N个物品，每个物品两个属性&lt;w, v&gt; 每个物品在背包中可以放0个或无限多个 求容量不超出下的最大价值 3. 多重背包多重背包的特点 N个物品，每个物品两个属性&lt;w, v&gt; 每个物品都有一定的数量Ni，在背包中可以放入0-Ni 求容量不超出下的最大价值 4.多维费用背包474. 一和零 属于0-1背包中的多维费用背包，答案见0-1背包。 多维费用背包的特点 N个物品，每个物品有多个限制属性如容量、体积，以及价值 放入看具体要求 求重量和体积都不超出下的最大价值","tags":[{"name":"背包","slug":"背包","permalink":"http://yoursite.com/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"MySql数据库面试问题","date":"2020-08-13T13:22:53.000Z","path":"2020/08/13/MySQL数据库/","text":"1.说一说MySQL中的索引​ MySQL数据库的索引是用B+树实现的。在B+树中非叶节点只存储关键字和指针（可以存储更多的关键字，降低树高），叶子节点存储关键字和数据。相邻的叶子节点间有指针连接，范围查找更为快速。通过B+树索引进行查找的时间复杂度为树高，一般是2~4次。（数据结构） ​ MySQL数据库中的索引有两种：聚集索引、稀疏索引。其中聚集索引的叶子节点会存储实际表中真实的数据，一个表只能有一个聚集索引，而稀疏索引的叶子节点存储的是主键的值。也就是说，通过稀疏索引进行查找，首先会查询稀疏索引树，找到符合条件的聚集索引的关键字，然后用该关键字在聚集索引树中进行查找，找到最终的数据。 ​ MySQL数据库中InnoDB引擎主索引是聚集索引，叶子的value存储真实数据，辅助索引是稀疏索引，叶子节点value存储主键的值；而Myisam引擎主索引和辅助索引都是稀疏索引，两者没有任何区别（value都存储数据的地址）。 2.为什么MySQL索引使用B+树，不是B树​ B+树是B树的变种，B+树中非叶节点只用来保存索引（关键字和指针），不储存数据，所有的数据存储在叶子节点上；而B树中的非叶节点会保存数据，这样使得B+树的查询效率更加稳定，均是从根节点到叶子节点。 ​ B+树非叶节点不存储数据，所以可以存储更多的关键字，使得B+树查找的磁盘IO数更少。 ​ B+树相邻的叶子节点间有指针连接，范围查询更为有利。 3.为什么推荐采用自增主键​ InnoDB推荐使用自增列作为主键，这样可以提高存取速度。因为如果InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的。 4.MySQL常见的存储引擎有哪些​ MySQL中常见的存储引擎有InnoDB和MyISAM，主要区别是： MyISAM不支持事务；InnoDB是事务类型的存储引擎。 MyISAM只支持表级锁；InnoDB支持行级锁和表级锁，默认为行级锁。 MyISAM引擎不支持外键；InnoDB支持外键。 MyISAM支持全文索引（FULLTEXT）；InnoDB不支持。 MyISAM索引都是是稀疏索引，叶子节点存储真实数据的指针，数据和索引分离；InnoDB采用聚集索引，真实数据在聚集的叶子节点上，辅助索引是稀疏索引，叶子节点存储主键值。 5.MySQL中where、group by、having关键字 where子句用来筛选from子句中指定的操作所产生的的行 group by 子句用来分组where子句的输出 having子句用来从分组的结果中筛选组 where和having的区别：where 是group by之前进行筛选，筛选的是行，having是group by 之后进行统计的筛选，筛选的是组。 执行顺序：执行where子句查找符合条件的数据 &gt; 使用group by 子句对数据进行分组 &gt;对group by 子句形成的组运行聚集函数计算每一组的值&gt;最后用having 子句去掉不符合条件的组 6.索引的最左前缀原则​ 在联合索引的情况下，不需要索引的全部定义，只要满足最左前缀，就可以利用索引来加快查询速度。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。最左前缀原则的利用也可以显著提高查询效率，是常见的MySQL性能优化手段。 ​ 如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下： 123select * from user where name&#x3D;xx and city&#x3D;xx ; ／／可以命中索引select * from user where name&#x3D;xx ; &#x2F;&#x2F; 可以命中索引select * from user where city&#x3D;xx ; &#x2F;&#x2F; 无法命中索引 这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 `city= xx and name ＝xx`，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。 7.那些列上适合建立索引，对性能有何开销​ 主键、外键必须有索引。 ​ 经常需要作为（where）条件查询的列上适合创建索引，并且该列上也必须有一定的区分度。创建索引需要维护，在插入数据的时候会重新维护各个索引树（数据页的分裂与合并），对性能造成影响。 8.“行级锁什么时候会锁住整个表？“​ InnoDB行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。 9.MySQL中建表的约束 主键约束：唯一性，非空性 唯一约束：唯一性，可以空，但只能有一个 检查约束：对该列数据的范围、格式的限制 默认约束：该数据的默认值 外键约束：需要建立两表间的关系并引用主表的列 10.SQL语句的优化有哪些？ 为经常使用的字段（排序、搜索）建立索引 字段的种类尽可能用int 或者tinyint类型。另外字段尽可能用NOT NULL。 select * 尽量少用，你想要什么字段 就select 什么字段出来 不要老是用* 号！同理，只要一行数据时尽量使用 LIMIT 1 11.order by是怎么工作的？​ ORDER BY 语句用于对结果集进行排序。以下面的语句进行分析： 1select city,name,age from t where city=&#x27;杭州&#x27; order by name limit 1000 ; city字段建立了索引，过程如下： 初始化 sort_buffer, 确认放入 name, city, age 这三个字段。 从索引 city 找到第一个满足 city=’杭州’条件的主键 id。 回表取到 name, city, age 三个字段值，存入 sort_buffer 中。 从索引 city 取下一个主键 id 记录。 重复 3-4 步骤，直到 city 不满足条件。 对 sort_buffer 中的数据按照字段 name 做快速排序。 排序结果取前 1000 行返回给客户端。","tags":[]},{"title":"Redis基础","date":"2020-08-13T13:22:53.000Z","path":"2020/08/13/Redis基础/","text":"1.Redis有那些数据结构​ 字符串、字典Hash、列表List、集和Set、有序集和SortedSet。 ​ ….加分项 ​ BitMap、Geo、HyperLogLog、 应用场景补充 ​ 字符串：常规的key-value缓存应用。常用计数器：微博数，粉丝数 ​ hash: 存储部分变更数据，如用户信息等。 ​ list: 可以构建消息队列 ​ set: 交集、并集、差集，去重，找共同的爱好…… ​ sortedset: 通过score对元素进行优先排序，带权重的消息队列 2.大量key同一时间过期​ 如果大量的key在同一时间过期，那么到过期的时间点Redis会发生卡顿现象，严重的话会造成缓存雪崩，解决方法是在设置失效时间时加上一个随机值。 3.Redis分布式锁​ 分布式锁是为了解决多进程之间的同步，redis可以实现分布式锁。可以用setnx原子操作来获得锁（），抢到之后用expire给锁添加过期时间。 12setnx k vexpire k timeout 追问：如果setnx获取锁成功，但线程执行expire之前崩溃，会如何，怎样解决？ ​ 此时，这个锁将一直被持有，无法释放。可以用同时具有setnx和expire的原子指令***解决： 1set k v nx[key必须不存在] [ex t 秒级]&#x2F;[px t 毫秒级] 4.如何在Redis中查询大量的具有固定前缀的key​ 可以利用keys指令查询，但该指令会一次性查找全部符合条件的key，会造成卡顿（Redis是单线程的）： 1keys [pattern] ​ 因为keys指令需要全部遍历，数据量很大的话，需要一定的执行时间。由于Redis是单线程，所以其他服务会暂停，直到keys指令结束。为避免此情况发生，可以使用scan指令，scan指令可以无阻塞的取出指定模式的key列表（每次执行会找到若干个符合条件的key），但会出现重复，所以客户端需要去重： 1scan cursor[0代表从头开始] [MATCH pattern] [COUNT num] ​ 由于scan不是一次性遍历（增量式迭代），所以在全部扫描完成时可能有些key会发生变化。 5.Redis异步队列​ Redis可以实现异步队列，一般用List实现，rpush生产消息，lpop消费消息。当lpop没有消息可消费时，需要sleep一会儿重试。 ​ 除了sleep还可以使用blpop指令，在没有消息时，他会阻塞住直到消息到来。 一次生产，多次消费如何实现？ ​ 可以使用pub/sub主题订阅模式，可以实现1：N的消息队列 pub/sub有何问题 ​ 在消费者下线情况下，生产的消息会丢失，可以使用RabbitMQ。 如何实现延时队列 ​ 可以使用有序集和sortedset，将时间作为score，消息内容作为key，调用zadd来生产消息，消费者通过zrangebyscore指令获取N秒前的消息. 6.Redis持久化​ Redis持久化有两种方式：RDB镜像全量持久化、AOF增量持久化。 RDB: ​ Redis每隔一段时间可以将所有数据备份到磁盘，Redis会fork一个子线程进行RDB操作，子线程创建后，父子线程共享数据段，父线程将继续提供服务，写脏的页面数据会和子线程分开（cow, copy on write)。cow数据未发生变化时，父子线程共享数据，一旦发生变化，子线程才会分配空间存储数据。 ​ 自动触发：配置文件中，可以配置经过多少次save就触发； ​ 手动触发：通过bgsave命令，会fork一个子进程。 AOF： ​ 将Redis执行的指令记录到磁盘，sync属性可以支持每条指令都写到磁盘，但代价较高。可以设置每秒sync，这样最多会丢失1s的数据。 ​ AOF日志会随着时间不断变大，可以通过AOF重写解决。首先读取数据库中所有键值的状态，使用一条命令替代前面多条操作语句。使用bgrewriteaof命令进行重写，重写时会fork一个子进程进行重写，主进程将重写期间的命令放到重写缓冲区中，待重写完成将其添加到AOF文件中。 ​ RDB无法实时持久化，AOF文件较大（AOF重写解决）。 7.Pipline是什么​ 普通的请求中，每次请求都对应一次IO操作等待（往返时延），而Pipline会将所有请求转化为一次IO操作（一次往返）。使用前提是指令之间没有因果相关性。 8.Redis的同步机制​ Redis同步机制有两种：主从同步 主从同步： 从服务器向主服务器发送sync命令 主服务器收到sync命令，开始执行bgsave命令生成RDB文件，并用缓存开始记录此后执行的所有写命令 主服务器bgsave完成之后，向从服务器发送RDB文件，继续在缓存中记录写命令 从服务器收到RDB文件，丢弃所有旧数据，载入RDB 主服务器向从服务器发送缓存中的命令 从服务器载入RDB后开始接收命令请求，执行来自主服务器中的缓存命令 通过以上操作，全量同步完成，以后主服务器向从服务器发送所有的写操作进行增量同步。 9.Redis集群​ Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master,继续提供服务。 ​ Redis Cluster着眼于扩展性，在单个Redis内存不足时，使用Cluster进行分片存储。 10.Redis为什么快 数据放在内存中，而且其存储数据类似HashMap，所以速度很快 单线程，没有线程上下文切换开销 多路IO复用，可以一个线程监听多路IO 研究表明，redis的瓶颈在网络时延 11.Redis与memcached区别 memcached只支持字符串，redis支持更丰富的数据类型 redis支持数据持久化 redis支持数据备份，即master-slave 12.redis数据过期回收 定期回收 没过一段时间去抽查一部分数据是否过期，过期就删除。 惰性删除 使用key时，先判断是否过期，过期则删除。","tags":[]},{"title":"数据库基础概念","date":"2020-08-13T13:22:53.000Z","path":"2020/08/13/数据库基础概念/","text":"一、事务事务指的是满足ACID的一组操作，它可以通过Commit提交一个事务，也可以使用Rollback进行回滚。 原子性（Atomicity） 事务被视为不可分割的最小单元，事务的所有操作要么全部完成后提交，要么全部失败回滚。 回滚可以通过回滚日志（Undo log）实现，里面记录着事务所执行的所有修改操作，回滚时反向执行即可。 一致性（Consistency） 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果是相同的。 隔离性（Isolation） 一个事务所作的更改在提交前对其他事务是不可见的。 持久性（Durability） 一旦事务提交，其所作的更改就会永远保持到数据库中。即使数据库发生崩溃，事务的执行的结果也不能丢失。 系统发生崩溃时，可以通过重做日志（Redo Log）进行修复，从而实现持久性。与回滚日志不同记录的数据的逻辑修改不同，重做日志记录的是数据页的物理更改。 事务的ACID特性概念简单，但不好理解，主要是这几个特性不是一种平级关系： 一致性是基本保证的，只有满足一致性，事务的执行结果才是正确的 在无并发情形下，事务串行执行，隔离性一定满足。此时只要满足原子性就能满足一致性 在并发情形下，多个事务并发执行，事务不仅要满足原子性，还要满足隔离性，才能满足一致性 事务满足持久性，是为了应对系统崩溃情况 二、并发一致性问题并发条件下，事务的隔离性很难保证，因为会出现很多并发一致性问题。 丢失修改 T1，T2两个事务都对一个数据进行修改，T1先修改，T2后修改，此时T2的修改会覆盖T1的修改。 读脏数据 T1修改一个数据，T2随后读取了该数据。如果T1撤销了这次修改（发生了回滚），那么T2读到的数据是脏数据。 不可重复读 T2读取了一个数据，随后T1修改了该数据。如果T2再次读该数据，此时读取的数据与第一次不一致。 幻读 T1读取了某个范围内的数据，随后T2在这个范围内插入了一条数据。T1再次查询这个范围内的数据的话，此时读取的结果与第一次不同。 三、数据库中的锁机制 锁的粒度 MySQL中提供了两种锁的粒度：行级锁和表级锁。 降低锁的粒度，可以减少锁的竞争，提升系统的并发程度。 但是加锁需要消耗资源，锁的各种实现都会增加系统负担。锁粒度越小，系统开销越大。 因此需要平衡锁开销和并发度。 锁的类型 独占锁（Exclusive），简写为 X 锁，又称写锁。 共享锁（Shared），简写为 S 锁，又称读锁。 有以下两个规定： ​ 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 ​ 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。 补充（不太懂） 使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。 意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定： ​ 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁； ​ 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。 通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。 封锁协议 一级封锁协议：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。 可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。 二级封锁协议：在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。 可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。 三级封锁协议：在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。 可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。 两端锁协议：加锁和解锁分为两个阶段进行。 可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。 事务遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件。 四、事务的隔离级别 读未提交（READ UNCOMMITTED） 一个事务可以读取到另一个事务没有提交的数据。无法避免任何一种情况。 读提交（READ COMMITTED） 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。可以解决脏读。 可重复读（REPEATABLE READ） 保证在同一个事务中多次读取同一数据的结果是一样的。可以解决不可重复读。 序列化（SERIALIZABLE） 强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。 该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。 五、多版本并发控制六、关系数据库设计理论数据库三大范式： 属性不可分：每一列属性都是不可再分的属性值，确保每一列的原子性，两列属性相近或一样，尽量合并属性一样的列，确保不产生冗余数据。 每一行的数据只能与其中一列相关，一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。 数据不能存在传递关系，每个属性都与主键有直接关系而不是间接关系。 七、常见问题 数据库索引用过哪些，什么情况失效？ 主键索引（聚簇索引）、普通索引、唯一索引、全文索引 where 语句中使用or，但是没有把or中的所有字段都加上索引，索引失效。 where 语句使用&lt;&gt;和!= like查询以“%…”开头 如果mysql估计全表扫描更快的话 LIMIT M, N LIMIT 给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目（初始记录行的偏移量是 0而不是 1)。 LIMIT M 等价于LIMIT 0, M drop和delete的区别 delete 删除的是 数据，drop语句删除表结构及所有数据，并将表所占用的空间全部释放 delete会触发触发器，drop不会触发触发器； 数据库事务的应用场景 在执行一系列数据库操作时，要保证这些操作必须完全正确执行，否则就不执行，在这种情况下，适合使用事务，例如将一些数据插入到两个相关联的表中，而且不能只有一张表插入成功，这种情况下，使用事务，无论是否插入成功，都不会对数据库造成不好的影响。 数据库索引的创建原则 表的主键、外键必须有索引; 经常查询的数据列最好建立索引 对于需要在指定范围内的快速或频繁查询的数据列; 经常用在WHERE子句中的数据列。 经常出现在关键字order by、group by、distinct后面的字段，建立索引。如果建立的是复合索引，索引的字段顺序要和这些关键字后面的字段顺序一致，否则索引不会被使用。","tags":[]},{"title":"Redis缓存雪崩、穿透、击穿","date":"2020-08-13T13:22:53.000Z","path":"2020/08/13/Redis缓存雪崩、穿透、击穿/","text":"1.缓存雪崩了解吗​ Redis中数据同一时刻大面积失效，那一瞬间Redis和没有一样，此时如果存在大量请求，会直接打到MySql数据库上，MySql数据库会瘫痪，无法提供服务，整个系统就崩掉了。 如何应对呢？ ​ 处理缓存雪崩很简单，在批量往Redis存数据的时候，把每个key的失效时间加个随机值就好了，保证数据在同一时刻不会大面积失效，数据库负担过重。 1setRedis（Key，value，time + Math.random() * 10000）; ​ 如果Redis时集群部署，可以将热点数据均匀分散到各个Redis库中，避免全部失效。 ​ 也可以设置热点数据永不过期，更新时覆盖即可。 2.缓存穿透、击穿​ 缓存穿透是指缓存和数据库中都没有的数据，而用户在不断的发送请求。此时的用户很有可能是攻击者，会导致数据库压力过大。（先查缓存，没有就去数据库查） 如何解决呢？ 增加校验，拦截不合理的请求。 从缓存和数据库都取不到的数据，可以在缓存中添加key对应valu为null的一条数据，有效时间可以设置短点 ​ 缓存击穿和缓存雪崩类似，但有点不同。缓存击穿指的是有一个key非常热点，在不停的扛着大并发，在该key失效的一瞬间，会有大量请求击穿缓存打到数据库，导致数据库负担过重。 如何解决呢？ 设置热点数据永不过期 加上互斥锁","tags":[]},{"title":"Java内存模型","date":"2020-08-13T13:17:53.000Z","path":"2020/08/13/Java内存模型/","text":"一、JMM中的主内存和工作内存​ Java内存模型（即Java Memory Model，简称JMM）本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括字段、静态字段、和构成数组对象元素）的访问方式。 ​ 所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在告诉缓存或者寄存器中，保存了该线程使用的变量从主内存副本拷贝。 ​ 线程只能直接操作工作内存中的变量，不同线程之间的变量传递需要通过主内存来完成。 JMM中的主内存： 存储Java实例对象 包括成员变量、类信息、常量、静态变量 属于数据共享的区域，多线程并发操作会引发线程安全问题 JMM中的工作内存： 存储当前方法的所有本地变量信息，本地变量对其他线程不可见 字节码行号指示器、Native方法等 属于线程私有区域，不存在线程安全问题 JMM和Java内存区域划分是不同的概念层次 JMM描述的是一组规则，围绕原子性、有序性、可见性展开 相似点：存在共享区域和私有区域 主内存与工作内存的数据存储类型以及操作方式归纳 方法里的基本数据类型本地变量将直接存储在工作内存的栈帧结构中 引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中 成员变量、static变量、类信息存储在主内存中 主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新到主内存 二、内存模型的三大特性 原子性 Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。 可见性 可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。 ​ 主要有三种实现可见性的方式： volatile synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。 final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。 对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。 有序性 有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。 也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。 三、happen-before原则-","tags":[]},{"title":"Java并发基础","date":"2020-08-13T10:17:53.000Z","path":"2020/08/13/Java并发基础/","text":"一、关于并发的相关概念1. 多线程、并发、并行、 并发：多个线程在同一时间段内同时执行。 并行：多个线程在同一时刻同时时执行。 ​ 通常一个处理器（或一个核）同一时刻只能处理一个线程，而线程在某些时候可能不需要cpu，在此时可以让cpu去执行其他地任务。为了充分地利用计算机资源，可以创建多个线程，在线程不需要cpu时，转而去执行其他的线程。 ​ 然而多线程会带来额外的开销：上下文切换、线程调度 2. 什么是上下文切换​ 当cpu从一个线程切换为另一个线程时，在切换前需要保存上一个线程的状态，切换后需要恢复下一个线程的状态。所以任务（线程）从保存到加载的过程就是一次上下文切换。 如何减少上下文切换 无锁并发编程：多线程竞争锁，会引起上下文切换（挂起） CAS算法：避免加锁 使用最少线程： 协程：单线程实现多任务的调度 3. 死锁产生死锁的条件 资源互斥：一个资源最多只能由一个线程获得 请求保持：线程在请求其他资源时，不放弃已获得资源 不可剥夺：一个线程获得的资源无法被其他线程剥夺 环路等待： 资源的请求构成了请求环路 如何避免死锁 避免一个线程同时获取多个锁 使用定时锁 3. 多线程一定快吗​ 在一些情形下，多线程并不一定比单线程快： 任务量比较小，单线程在很短的时间内就能完成 资源限制，如网速、硬盘读写速度、数据库连接池 二、Java并发机制的底层原理1. volatile​ 被volatile声明的变量，在修改时会发生两件事： 当前处理器缓存行的数据写回到系统内存 将其他CPU里缓存了该内存地址的数据置为无效 2. Synchronized​ Java中所有的对象都可以作为锁(通过对象头标记)，具体表现如下： Synchronized作用于普通方法：锁是当前对象 Synchronized作用于静态方法：锁是当前类的Class对象 Synchronized作用于方法快：锁是括号中的对象 Java引入了偏向锁和轻量级锁，来减少获得锁和释放锁带来的性能损耗。锁一共有四章状态：无锁、偏向锁、轻量级锁、重量级锁。这几个状态，会随着竞争情况逐渐升级，锁可以升级但不能降级。 偏向锁 ​ 很多情况下，一个锁是总是由一个线程多次获得。获得偏向锁的线程再次获得该锁，可以直接获得，无需加锁和解锁。 轻量级锁 ​ 在获得锁时，自旋一定时间多次获得。 ​ 竞争的线程不会被阻塞，适用于同步块可以在很快。 重量级锁 3. 原子操作​ Java实现原子操作可以通过锁和循环CAS的方式实现。 CAS带来的问题 ABA问题 循环带来额外开销： 只能保证一个变量的原子性：","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"},{"name":"volatile","slug":"volatile","permalink":"http://yoursite.com/tags/volatile/"},{"name":"synchronized","slug":"synchronized","permalink":"http://yoursite.com/tags/synchronized/"}]},{"title":"java02","date":"2020-08-12T13:12:47.000Z","path":"2020/08/12/java中的Object类/","text":"Java是纯面向对象的语言，换言之，在Java中一切都是对象。而Object类是Java中所有类的基类，也就是说所有类都直接或间接继承自Object。 ​ 在继承体系中，父类是基础，子类是对父类的扩充和丰富，所以理解Object类对理解其他类至关重要。理解Object类，关键在于其实现的方法。 1.getClass()1public final native Class&lt;?&gt; getClass(); ​ 返回对象的Class对象，可以看出是个native方法。 2.hashCode()1public native int hashCode(); ​ 返回对象的hashcode值，也是个native方法， 3.equals()123public boolean equals(Object obj) &#123; return (this &#x3D;&#x3D; obj);&#125; ​ 判断对象是否相同，注意这里判断的是引用。 4.clone()1protected native Object clone() throws CloneNotSupportedException; ​ 返回该对象的克隆。 5.toString()123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; ​ 返回对象的字符串表示。 6.wait()1234567891011121314151617181920public final native void wait(long timeout) throws InterruptedException;public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException(&quot;timeout value is negative&quot;); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( &quot;nanosecond timeout value out of range&quot;); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout);&#125;public final void wait() throws InterruptedException &#123; wait(0);&#125; ​ 与synchronized配合使用，释放锁使线程等待。 7.notify() notifyAll()12public final native void notify();public final native void notifyAll(); ​ 唤醒等待的线程。 8.finalize()1protected void finalize() throws Throwable &#123; &#125; ​ 当对象没有有效引用时被垃圾回收器调用，但不保证一定会被调用。 对象回收过程中的finalize()： 通过可达性分析找到可以回收的对象 将对象加入到一个较低优先级的线程（垃圾回收器线程），线程会依次调用对象的finalize()方法 该线程执行了对象的finalize方法，若对象在该方法中实现了自救，对象不在回收 对象的finalize方法还未来得及执行（线程的优先级较低），对象被回收","tags":[]},{"title":"Java系列之注解","date":"2020-08-12T11:52:58.000Z","path":"2020/08/12/Java注解/","text":"一、什么是注解​ Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。注解是ava5开始引入的新特征。 二、常见的Java注解 Override ​ java.lang.Override 是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重写了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java 编译器将以一个编译错误来警示。 Deprecated ​ Deprecated 也是一种标记类型注解。当一个类型或者类型成员使用@Deprecated 修饰的话，编译器将不鼓励使用这个被标注的程序元素。所以使用这种修饰具有一定的“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为@Deprecated，但编译器仍然要报警。 SuppressWarnings ​ SuppressWarning 不是一个标记类型注解。它有一个类型为String[] 的成员，这个成员的值为被禁止的警告名。 三、注解的语法 注解定义 注解通过@Interface关键字进行定义: 12public @interface TestAnnocation &#123;&#125; 注解使用 注解可以应用到类、方法、成员变量上： 123@TestAnnocationpublic class Test &#123;&#125; 四、元注解​ 元注解是作用于注解的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。元注解有：@Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。 @Retention 定义该注解的生命周期 ● RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。● RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式● RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。 @Documented是个标记性注解，表示是否将注解信息添加在java 文档中 @Target表示该注解用于什么地方，默认值为任何元素 ● ElementType.CONSTRUCTOR: 用于描述构造器● ElementType.FIELD: 成员变量、对象、属性（包括enum实例）● ElementType.LOCAL_VARIABLE: 用于描述局部变量● ElementType.METHOD: 用于描述方法● ElementType.PACKAGE: 用于描述包● ElementType.PARAMETER: 用于描述参数● ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明 @Inherited是个标记性注解，定义该注解和子类的关系 @Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类。 @Repeatable 五、注解的属性​ 注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。 1234567@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface TestAnnocation &#123; int id(); String msg();&#125; ​ 在使用的时候，我们应该给它们进行赋值。赋值的方式是在注解的括号内以 value=”” 形式，多个属性之前用 ，隔开。 123@TestAnnocation(id = 1, msg = &quot;hello&quot;)public class Test &#123;&#125; ​ 使用default关键字可以为属性指定默认值。 1234567@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface TestAnnocation &#123; int id() default 1; String msg() default &quot;hello&quot;;&#125; 六、自定义注解自定义注解类编写的一些规则: Annotation 型定义为@interface, 所有的Annotation 会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口. 参数成员只能用public 或默认(default) 这两个访问权修饰 参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组. 要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法 注解也可以没有定义成员,，不过这样注解就没啥用了 PS:自定义注解需要使用到元注解 七、注解原理​ 注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。","tags":[]}]