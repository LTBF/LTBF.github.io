[{"title":"LeetCode刷题笔记","date":"2020-10-09T16:00:00.000Z","path":"2020/10/10/LeetCode刷题笔记/","text":"LeetCode刷题笔记，记录一些非常值得记录的算法题….. 寻找输入流的中位数 LeetCode 295. Find Median from Data Stream剑指Offer 使用两个堆：一个大顶堆，一个小顶堆。其中，大顶堆用于存放输入流中较小的一半数，小顶堆存放输入流中较大的一半数。约定，大顶堆中的数最多比小顶堆中的数多一个。那么，输入流中的中位数要么是大顶堆的头部元素（输入流中数字个数为奇），要么是两个堆顶元素和的平均值（输入流中数字个数为偶）。 12345678910111213141516171819202122232425262728293031323334353637class MedianFinder &#123; private PriorityQueue&lt;Integer&gt; prioritySmall; private PriorityQueue&lt;Integer&gt; priorityBig; /** initialize your data structure here. */ public MedianFinder() &#123; prioritySmall = new PriorityQueue&lt;&gt;((a, b) -&gt; &#123;return b - a;&#125;); priorityBig = new PriorityQueue&lt;&gt;((a, b) -&gt; &#123;return a - b;&#125;); &#125; public void addNum(int num) &#123; if(prioritySmall.isEmpty() || prioritySmall.peek() &gt;= num)&#123; prioritySmall.offer(num); &#125; else&#123; priorityBig.offer(num); &#125; if(prioritySmall.size() &gt; priorityBig.size() + 1)&#123; priorityBig.offer(prioritySmall.poll()); &#125; if(priorityBig.size() &gt; prioritySmall.size())&#123; prioritySmall.offer(priorityBig.poll()); &#125; &#125; public double findMedian() &#123; if(prioritySmall.size() &gt; priorityBig.size())&#123; return prioritySmall.peek(); &#125; return (prioritySmall.peek() + priorityBig.peek()) / 2.0; &#125;&#125; 乱序整数数组中缺失的第一个正整数 LeetCode 41. First Missing Positive 将数组中的正整数放到数组中的指定位置上：m放到数组中的第m个位置。之后，遍历数组，找出不符合该规律的位置。需要注意一点，由于数组中的数字可能存在重复，在swap时应该避免相同元素进行交换。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int firstMissingPositive(int[] nums) &#123; if(nums == null)&#123; return -1; &#125; int n = nums.length; int index = 0; while(index &lt; n)&#123; if(nums[index] &gt; 0 &amp;&amp; nums[index] != index+1)&#123; if(nums[index] &lt;= n &amp;&amp; nums[nums[index]-1] != nums[index])&#123; // 里面存在重复数字，需要过滤 swap(nums, index, nums[index]-1); continue; &#125; &#125; index++; &#125; int res = 1; for(int m : nums)&#123; if(res != m)&#123; return res; &#125; res++; &#125; return res; &#125; public void swap(int[] nums, int i, int j)&#123; int t = nums[i]; nums[i] = nums[j]; nums[j] = t; &#125;&#125; 统计数组中每个元素后面比自己小的元素数 LeetCode 315. Count of Smaller Numbers After Self 普通方法的时间复杂度一般是O(n^2)，使用二叉查找树，可以将时间复杂度降低到O(nlogn)。 该二叉查找树的每个节点除了value值之外，还需要维护一个变量ct，代表该节点的左子树的节点个数。这样，如果按数组逆序来构建这棵二查找树： 插入时如果元素比该节点的value大，则说明该节点的左子树上的节点以及该节点都比插入元素小，元素插入右子树 如果比该节点的value小的话，元素要插入该节点的左子树，该节点的ct需要加1 插入元素与节点value相等时，可以将其插入到右子树 这样，一个元素后面有多少个比其小的元素，就是在插入该元素过程中所有小于该元素的的节点ct域的和。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123; public List&lt;Integer&gt; countSmaller(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return new ArrayList&lt;&gt;(); &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int i = nums.length - 1; TreeNode root = new TreeNode(nums[i]); list.add(0); for(i = i - 1; i &gt;= 0; i--)&#123; int m = insert(root, nums[i]); list.add(m); &#125; Collections.reverse(list); return list; &#125; public int insert(TreeNode root, int num)&#123; if(num &lt; root.val)&#123; // 更新ct root.ct++; if(root.left == null)&#123; root.left = new TreeNode(num); return 0; &#125; else&#123; return insert(root.left, num); &#125; &#125; else&#123; int res = root.ct; if(num &gt; root.val)&#123; res++; &#125; if(root.right == null)&#123; root.right = new TreeNode(num); return res; &#125; else&#123; return res + insert(root.right, num); &#125; &#125; &#125;&#125;class TreeNode&#123; int val; int ct; TreeNode left, right; TreeNode(int val)&#123; this.val = val; &#125;&#125; 分式的小数形式表示 LeetCode 166. Fraction to Recurring Decimal 这道题的难点在于如何找出小数部分的循环，思路是用一个Map记录和判断，具体看代码实现。这道题还需注意一下几点： 分式的分子分母可能为正也可能为负 将负数转为正数时，当心越界（非常容易出现） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public String fractionToDecimal(long numerator, long denominator) &#123; // 考虑数字正负的情况 boolean flag = (numerator &lt; 0 &amp;&amp; denominator &gt; 0) || (numerator &gt; 0 &amp;&amp; denominator &lt; 0); // 修改为long， 避免越界 numerator = Math.abs(numerator); denominator = Math.abs(denominator); // Map记录循环 Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); // 结果的整数部分和小数部分 String posStr = &quot;&quot;, negStr = &quot;&quot;; posStr = String.valueOf(numerator / denominator); numerator = (numerator % denominator) * 10; for(int i = 0; i &lt; 100000; i++)&#123; if(numerator == 0)&#123; break; &#125; if(map.containsKey(numerator))&#123; int startIndex = map.get(numerator); negStr = negStr.substring(0, startIndex) + &quot;(&quot; + negStr.substring(startIndex, i) + &quot;)&quot;; break; &#125; map.put(numerator, i); negStr += String.valueOf(numerator / denominator); numerator = (numerator % denominator) * 10; &#125; // 结果添加负号 if(flag)&#123; posStr = &quot;-&quot; + posStr; &#125; if(negStr.equals(&quot;&quot;))&#123; return posStr; &#125; return posStr + &quot;.&quot; + negStr; &#125;&#125; 去掉最小子数组，使剩余数组之和能整除P Leetcode 1590. Make Sum Divisible by Pdate: 2020.09.22算法指数：☆☆☆☆是否做出：是 思路类似求数组中和为target的最小子数组，只不过在这道题中求的是和%sum= m的最小子数组，其中sum是整个数组的和，m是sum%p。 123456789101112131415161718192021222324252627class Solution &#123; public int minSubarray(int[] nums, int p) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int target = 0; for(int m : nums)&#123; target += m; target %= p; // 遍历中取余，可以避免越界 &#125; if(target == 0)&#123; // 数组天然整除p，无需减少任何元素 return 0; &#125; int res = nums.length, cur = 0; // 初始化 map.put(0, -1); // important，子数组从第一个元素开始的时候 for(int i = 0; i &lt; nums.length; i++)&#123; cur += nums[i]; cur = cur % p; int need = (cur - target + p) % p; res = Math.min(res, i - map.getOrDefault(need, -nums.length)); map.put(cur, i); &#125; return res == nums.length ? -1 : res; &#125;&#125; 判断数组中长度为3的递增子序列 Leetcode 334. Increasing Triplet Subsequence date: 2020.10.12 算法指数：☆☆☆ 是否做出：否 此类问题一般可以通过用简单方法解决。长度为2的递增此序列—&gt;长度为3/的递增子序列 12345678910111213141516171819202122class Solution &#123; public boolean increasingTriplet(int[] nums) &#123; int a = Integer.MAX_VALUE; int b = Integer.MAX_VALUE; for(int m : nums)&#123; if(m &lt;= a)&#123; a = m; &#125; else if(m &lt;= b)&#123; b = m; &#125; else&#123; return true; &#125; &#125; return false; &#125;&#125; 获取随机值Set LeetCode380. Insert Delete GetRandom O(1) date: 2020.10.17 算法指数：☆☆☆ 是否做出：是 通过数组+Map实现随机访问。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class RandomizedSet &#123; private Map&lt;Integer, Integer&gt; map; private int[] array; private int nextInsert; /** Initialize your data structure here. */ public RandomizedSet() &#123; map = new HashMap&lt;&gt;(); array = new int[100005]; nextInsert = 0; &#125; /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ public boolean insert(int val) &#123; if(map.containsKey(val))&#123; return false; &#125; array[nextInsert] = val; map.put(val, nextInsert++); return true; &#125; /** Removes a value from the set. Returns true if the set contained the specified element. */ public boolean remove(int val) &#123; if(map.containsKey(val))&#123; int index = map.get(val); swap(array, index, --nextInsert); map.put(array[index], index); // 更新索引 map.remove(val); return true; &#125; return false; &#125; /** Get a random element from the set. */ public int getRandom() &#123; int index = ((int)(Math.random() * 10000000)) % nextInsert; return array[index]; &#125; public void swap(int[] array, int i, int j)&#123; int m = array[i]; array[i] = array[j]; array[j] = m; &#125;&#125; 最大的数字 LeetCode 179. Largest Number date: 2020.10.17 算法指数：☆☆☆☆ 是否做出：是 这道题的关键在于字符串比较部分：34和3哪个应该放前面、30和3哪个应该放前面。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; public String largestNumber(int[] nums) &#123; if(nums == null || nums.length == 0)&#123; return &quot;&quot;; &#125; String[] strs = new String[nums.length]; for(int i = 0; i &lt; nums.length; i++)&#123; strs[i] = String.valueOf(nums[i]); &#125; Arrays.sort(strs, (s1, s2) -&gt; &#123; return compareString(s1, s2); &#125;); String res = &quot;&quot;; for(String s : strs)&#123; res += s; &#125; // 过滤0前缀 int startIndex; for(startIndex = 0; startIndex &lt; res.length()-1; startIndex++)&#123; if(res.charAt(startIndex) != &#x27;0&#x27;)&#123; break; &#125; &#125; return res.substring(startIndex); &#125; public int compareString(String s1, String s2)&#123; int i = 0; for(; i &lt; s1.length() &amp;&amp; i &lt; s2.length(); i++)&#123; if(s1.charAt(i) &gt; s2.charAt(i))&#123; return -1; &#125; if(s1.charAt(i) &lt; s2.charAt(i))&#123; return 1; &#125; &#125; if(i &lt; s1.length())&#123; return compareString(s1.substring(i), s2); &#125; if(i &lt; s2.length())&#123; return compareString(s1, s2.substring(i)); &#125; return 0; &#125;&#125; 直方图中的最大面积 LeetCode 84. Largest Rectangle in Histogram date: 2020.10.17 算法指数：☆☆☆☆☆ 是否做出：否 单调递增栈可以实现记录当前bar在最大区间[i, j]中是最低的。用图来说明递增栈是如何解决这个问题的： 首先，高度为2的bar&lt;0, 2&gt;进栈(0代表该bar从位置0到当前位置是最低的，2代表该bar的高度): 然后，高度为1的bar想要进栈，但是小于栈顶高度为2的bar，所以栈中的元素要出栈。&lt;0, 2&gt;出栈，该bar最低的最大区间为[0, 0]，area = 2*1。此时栈为空，高度为1的bar继续进栈，此时注意进栈的是&lt;0, 1&gt;，因为前面出栈的bar的高度都比1高。高度为5，6的bar&lt;2, 5&gt;,&lt;3, 6&gt;依次进栈， 现在该高度为2的bar进栈了，重复前面的操作。首先&lt;3, 6&gt;出栈，该bar对应的区间为[3, 3]，area = 1 * 6;然后&lt;2, 5&gt;出栈，对应的区间为[2, 3]，area = 2 * 5。然后&lt;2, 2&gt;进栈，&lt;5, 3&gt;进栈。 最终依次出栈：&lt;5, 3&gt;对应区间为[5, 5],area = 1 * 3; &lt;2, 2&gt;对应区间为[2, 5]，area = 4 * 2; &lt;0, 1&gt;对应区间为[0, 5],area = 6 * 1。 123456789101112131415161718192021222324252627282930313233class Solution &#123; // 单调递增栈 public int largestRectangleArea(int[] heights) &#123; if(heights == null || heights.length == 0)&#123; return 0; &#125; int maxArea = 0; Stack&lt;int[]&gt; stack = new Stack&lt;&gt;(); for(int i = 0; i &lt; heights.length; i++)&#123; int start = i; while(!stack.isEmpty() &amp;&amp; stack.peek()[1] &gt; heights[i])&#123; int[] arr = stack.pop(); int height = arr[1]; int width = i - arr[0]; start = arr[0]; maxArea = Math.max(maxArea, height * width); &#125; stack.push(new int[]&#123;start, heights[i]&#125;); &#125; while(!stack.isEmpty())&#123; int[] arr = stack.pop(); int height = arr[1]; int width = heights.length - arr[0]; maxArea = Math.max(maxArea, height * width); &#125; return maxArea; &#125;&#125; 快速幂 LeetCode 50. Pow(x, n) date: 2020.10.19 算法指数：☆☆☆☆ 是否做出：否 利用二分思想，xn = xn/2 * xn/2 * xn%2==1 ? 1 : 0 1234567891011121314151617181920212223242526272829class Solution &#123; // 快速幂 public double myPow(double x, long n) &#123; boolean isNegative = n &lt; 0; n = Math.abs(n); // 注意int负数越界 double res = calculate(x, n); return isNegative ? 1/res : res; &#125; public double calculate(double x, long n)&#123; if(n == 0)&#123; return 1; &#125; if(n == 1)&#123; return x; &#125; double res = calculate(x, n/2); res *= res; res *= n % 2 == 1 ? x : 1; return res; &#125;&#125; 另一种方法：​ 211 = 28 * 22 * 21 = 2(1000) * 2(10) *2(1) 12345678910111213141516171819202122232425262728class Solution &#123; public double myPow(double x, long n) &#123; if(n == 0)&#123; return 1; &#125; boolean flag = n &lt; 0 ? true : false; n = Math.abs(n); double res = 1; double base = x; while(n != 0)&#123; if((n&amp;1) == 1)&#123; res = res * base; &#125; base = base * base; n = n&gt;&gt;1; &#125; if(flag)&#123; return 1/res; &#125; return res; &#125;&#125;","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://yoursite.com/tags/Leetcode/"}]},{"title":"BIO、NIO以及Netty","date":"2020-10-01T16:00:00.000Z","path":"2020/10/02/BIO、NIO以及Netty/","text":"什么是BIOBIO(Blocked Input Output)是一种同步阻塞IO。早期Java网络通信通过Socket(套接字)进行通信，这是一种阻塞式的通信。通过BIO实现网络通信，需要一对套接字： 运行于服务端的ServerSocket 运行于客户端的Socket Socket通信方式如下图所示： Java使用Socket进行网络通信过程：服务端：1.创建ServerSocket对象，绑定地址(ip)和端口(port):serverSocket.bind(new InetSocketAddress(host,port))2.通过accept方法监听客户端请求：accept方法调用后会阻塞住，直到客户端请求出现3.连接建立，通过输入输出流进行通信：read方法调用会阻塞，直到数据可以读取4.连接关闭，资源释放 客户端：1.创建Socket对象，设置连接服务器的地址(ip)及端口(port):socket.connect(new InetSocketAddress(host,port))2.连接建立，通过输入输出流进行通信：read方法调用会阻塞，直到数据可以读取3.连接关闭，释放资源 Socket网络通信实例：123456789101112131415161718192021222324252627282930313233public class Server &#123; public static void main(String[] args) &#123; try&#123; ServerSocket serverSocket = new ServerSocket(8888); while(true)&#123; Socket socket = serverSocket.accept(); // 阻塞，直到获取一个连接 // 读取数据 InputStream inputStream = socket.getInputStream(); DataInputStream dataInputStream = new DataInputStream(inputStream); String str = dataInputStream.readUTF(); System.out.println(&quot;server receive from client:&quot; + str); // 发送数据 OutputStream outputStream = socket.getOutputStream(); DataOutputStream dataOutputStream = new DataOutputStream(outputStream); dataOutputStream.writeUTF(&quot;hello client, I am Server!&quot;); // 关闭连接 socket.close(); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930public class Client &#123; public static void main(String[] args) &#123; Socket socket; try&#123; socket = new Socket(&quot;127.0.0.1&quot;, 8888); // 发送数据 OutputStream outputStream = socket.getOutputStream(); DataOutputStream dataOutputStream = new DataOutputStream(outputStream); dataOutputStream.writeUTF(&quot;hello server, I am client!&quot;); // 读取数据 InputStream inputStream = socket.getInputStream(); DataInputStream dataInputStream = new DataInputStream(inputStream); String str = dataInputStream.readUTF(); System.out.println(&quot;client receive from server:&quot; + str); // 关闭连接 socket.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125;&#125; Server端控制台会输出： 1server receive from client:hello server, I am client! Client端控制台会输出： 1client receive from server:hello client, I am Server! 为什么不推荐使用BIO资源耗费严重：一个线程只能处理一个客户端连接，如果要管理多个客户端的话，必须为每个客户端连接创建一个线程。 123456while(true)&#123; Socket socket = serverSocket.accept(); new Thread(() - &gt; &#123; // socket连接处理 &#125;).start();&#125; 线程池可以一定程度上缓解此问题，但无法根本改变： 123456while(true)&#123; Socket socket = serverSocket.accept(); threadPool.execute(() -&gt; &#123; // socket连接处理 &#125;);&#125; 无论如何优化，它底层还是同步阻塞的IO，无法从根本上解决问题。 同步和异步（消息通信机制） 同步：发出一个调用时，在没有得到结果之前，该调用就不返回 异步：调用在发出之后，这个调用就直接返回了，所以没有返回结果 阻塞和非阻塞（等待调用结果时的状态） 阻塞：调用结果返回之前，线程一直挂起 非阻塞：调用没有返回结果之前，线程不会阻塞 再看NIONIO(Non-blocking IO)是一种同步非阻塞IO，在java1.4时引入，对应java.nio包。NIO提供了与传统BIO中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同套接字通道的实现，两种通道都支持阻塞和非阻塞两种模式： 阻塞模式：基本不会使用。与传统网络编程一样，简单但性能和可靠性不好。 非阻塞模式：对高负荷、高并发应用非常好，但是编程麻烦。这也是Netty出现的重要原因。 NIO核心组件解读NIO包含一下几个核心组件： Channel Buffer Selector Selector Key 它们之间的关系如下： 1.NIO通过Channel(通道)和Buffer(缓存区)来传输数据，数据总是从缓冲区写入通道，或从通道读取到缓冲区。在NIO中，所以数据都是通过Buffer处理的，Channel对应于JDK底层的Socket。2.NIO通过Selector(选择器)来监视多个通道对象，如数据到达、连接打开等，单线程可以监视多个通道3.将Channel注册到Selector时，会返回一个Selector Key，可以根据它获取那些IO事件已经就绪，也可以通过它获取对应的Channel进行操作。Selector是NIO实现的关键，它使用了事件通知相关的API来选择已经就绪的通道。简单来说，流程如下： 将Channel注册到Selector中 调用Selector的select方法，这个方法会阻塞，直到有就绪的Channel出现 注册到Selector的就绪态Channel会被轮询出来：新的连接、读就绪、写就绪 通过Selector Key获取就绪Channel的集和，进行后续的IO操作 使用NIO进行通信123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class NIOServer &#123; public static void main(String[] args) throws IOException &#123; // 服务端通信通道 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 开启非阻塞 serverSocketChannel.configureBlocking(false); // 设置端口号 serverSocketChannel.socket().bind(new InetSocketAddress(8888)); // 选择器 Selector selector = Selector.open(); // 服务端注册选择器, 监听&quot;连接&quot; serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); while(true)&#123; // 轮询，选择就绪通道，并返回数量(阻塞) int select = selector.select(); // 获取当前选择器中所有注册的key(已就绪的监听事件) Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator(); // 迭代 while(iterator.hasNext())&#123; SelectionKey key = iterator.next(); if(key.isAcceptable()) &#123; // 新的请求连接 createChannel(key); &#125; else if(key.isReadable())&#123; // 通道可以好读 doRead(key); &#125; else if(key.isWritable())&#123; // 通道可以写 doWrite(key); &#125; // 移除 iterator.remove(); &#125; &#125; &#125; private static void doWrite(SelectionKey key) throws IOException &#123; // 获取通道 SocketChannel socketChannel = (SocketChannel)key.channel(); // 写数据 ByteBuffer byteBuffer = ByteBuffer.wrap(&quot;send to Client&quot;.getBytes()); socketChannel.write(byteBuffer); // 通道监听读 key.interestOps(SelectionKey.OP_READ); &#125; private static void doRead(SelectionKey key) throws IOException &#123; // 获取通道 SocketChannel socketChannel = (SocketChannel)key.channel(); // 读取数据 ByteBuffer byteBuffer = ByteBuffer.allocate(1024); try&#123; // 当远程SocketChannel断开连接时，Server端会触发一个read事件，此处会发生异常 int read = socketChannel.read(byteBuffer); byteBuffer.flip(); System.out.println(&quot;Server receive:&quot; + new String(byteBuffer.array(), 0, read)); // 通道监听写 key.interestOps(SelectionKey.OP_WRITE); &#125; catch (IOException e)&#123; key.cancel(); &#125; &#125; // 新连接的建立 private static void createChannel(SelectionKey key) throws IOException &#123; // 获取key的监听通道 ServerSocketChannel serverSocketChannel = (ServerSocketChannel)key.channel(); // 接收请求 SocketChannel socketChannel = serverSocketChannel.accept(); System.out.println(&quot;Accept connection from &quot; + socketChannel); // 设置通道非阻塞 socketChannel.configureBlocking(false); // 发送欢迎词 ByteBuffer byteBuffer = ByteBuffer.wrap((&quot;Welcome:&quot; + socketChannel.getRemoteAddress() + &quot; assigned to&quot; + Thread.currentThread().getName()).getBytes()); socketChannel.write(byteBuffer); //*** // 注册连接到selector, 绑定监听读数据 socketChannel.register(key.selector(),SelectionKey.OP_READ ); &#125;&#125; 1234567891011121314151617181920public class NIOClient &#123; public static void main(String[] args) throws IOException &#123; SocketChannel socketChannel &#x3D; SocketChannel.open(new InetSocketAddress(8888)); socketChannel.configureBlocking(false); ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024); byteBuffer.put(&quot;Hello I am Client&quot;.getBytes()); byteBuffer.flip(); socketChannel.write(byteBuffer); byteBuffer.clear(); socketChannel.read(byteBuffer); byteBuffer.flip(); System.out.println(new String(byteBuffer.array())); &#125;&#125; NIO为什么更好 使用比较少的线程就可以管理多个客户端连接，提高了并发量且减少了资源消耗 没有IO操作的时候，线程可以去执行其他任务，非阻塞。 使用NIO编写代码太难了NIO非常难用，而且存在许多bug，开发和维护的成本比较大。一般情况下会使用Netty这个成熟的框架。 重要角色Netty还在学习中…..","tags":[]},{"title":"Linux常见命令","date":"2020-09-28T16:00:00.000Z","path":"2020/09/29/Linux常见命令/","text":"1. 进程线程1234top ---实时显示系统中各个进程的资源占用状况ps ---查看当前进程top -H -p pid ---查看进程下的线程ps -T -p pid ---同上 2. 磁盘和内存12df ---查看磁盘状态free ---查看内存状态 3. 网络12netstat ---显示各种网络相关信息ifconfig ---查看网卡信息 4. 文件/目录12345678910111213mkdir ---创建目录touch ---创建文件mv ---移动文件&#x2F;目录rm ---删除文件&#x2F;目录cp ---复制文件&#x2F;目录chmod ---修改文件&#x2F;目录的权限more ---按页显示内容cat ---按行显示内容tac ---按行倒叙显示内容less ---与more类似，可以向前翻页tail ---只看结尾几行head ---只看开始几行scp 5. 压缩和解压1tar ---压缩和解压 6. 其他12345678910lscdpwdgrep ---文本搜索sedawkchgrpwc ---统计字节数(-c)、行数(-l)、字数(-w)historyifconfig","tags":[]},{"title":"Spring循环依赖","date":"2020-09-23T16:00:00.000Z","path":"2020/09/24/Spring循环依赖/","text":"1. Spring中bean的生命周期 构造器创建bean对象 依赖注入 init方法初始化bean对象 使用 销毁 2. Spring循环依赖是怎么回事循环依赖发生在单例对象A的创建过程中（第一步和第二步）需要其他的单例对象B，而这个单例对象B恰好也需要A。循环依赖主要分两种：构造器循环依赖和属性循环依赖。 3. 如和解决循环依赖Spring通过三级缓存可以解决属性循环依赖，三级缓存主要如下： 12345678/** Cache of singleton objects: bean name --&gt; bean instance */private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(256);/** Cache of singleton factories: bean name --&gt; ObjectFactory */private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(16);/** Cache of early singleton objects: bean name --&gt; bean instance */private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16); singletonObjects: 第一级缓存，存放完整可用的单例对象 earlySingletonObjects: 第二级缓存，存放提前曝光的单例对象 singletonFactories: 第三级缓存，存放单例对象的工厂 那么三级缓存如何解决属性循环依赖的呢？看一下单例bean的创建过程： 1234567891011121314151617181920212223protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; // 从一级缓存中获取单例对象 Object singletonObject = this.singletonObjects.get(beanName); // 一级缓存获取失败，且该对象正在创建过程中 if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; synchronized (this.singletonObjects) &#123; // 二级缓存中获取单例对象 singletonObject = this.earlySingletonObjects.get(beanName); // 二级缓存获取失败，且允许从三级缓存中获取对象 if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; // 三级缓存获取单例对象的工厂 ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); // 获取成功，获取对象，将对象从三级缓存放到二级缓存 if (singletonFactory != null) &#123; singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; return (singletonObject != NULL_OBJECT ? singletonObject : null);&#125; 为什么三级缓存可以解决循环依赖呢？这是因为在bean生命周期的第一步结束后，会将该对象放入三级缓存。这也是无法解决构造器循环依赖的原因。 12345678910protected void addSingletonFactory(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123; Assert.notNull(singletonFactory, &quot;Singleton factory must not be null&quot;); synchronized (this.singletonObjects) &#123; if (!this.singletonObjects.containsKey(beanName)) &#123; this.singletonFactories.put(beanName, singletonFactory); this.earlySingletonObjects.remove(beanName); this.registeredSingletons.add(beanName); &#125; &#125;&#125; https://blog.csdn.net/u010853261/article/details/77940767","tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring和SpringBoot的区别","date":"2020-09-23T16:00:00.000Z","path":"2020/09/24/Spring和SpringBoot的区别/","text":"1. 什么是SpringSpring框架为开发Java应用程序提供了全面的基础架构支持。它包含一些很好的功能，如依赖注入和开箱即用的模块，如：Spring JDBC 、Spring MVC 、Spring Security、 Spring AOP 、Spring ORM 、Spring Test. 这些模块缩短应用程序的开发时间，提高了应用开发的效率例如，在Java Web开发的早期阶段，我们需要编写大量的代码来将记录插入到数据库中。但是通过使用Spring JDBC模块的JDBCTemplate，我们可以将操作简化为几行代码。 2.什么是Spring BootSpring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。 Spring Boot中的一些特征： 创建独立的Spring应用。 嵌入式Tomcat、Jetty、 Undertow容器（无需部署war文件）。 提供的starters 简化构建配置 尽可能自动配置spring应用。 提供生产指标,例如指标、健壮检查和外部化配置 完全没有代码生成和XML配置要求 https://www.jianshu.com/p/ffe5ebe17c3a","tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"旋转有序数组上二分查找","date":"2020-09-14T16:00:00.000Z","path":"2020/09/15/旋转有序数组上二分查找/","text":"在旋转排序数组上应用二分查找，若数组中的元素都不相同，则可以按下图分析： 若a[mid] &gt; a[high], 则代表mid位于旋转数组的左半段； 若a[mid] &lt; a[low],则代表mid位于旋转数组的右半段 否则，代表区间[low, high]是个递增数组，不存在旋转 若数组中可能存在重复元素，则需要按下图分析： 若a[mid] &lt; a[low], 则代表处于状态① 若a[mid] &gt; a[high], 则代表处于状态② 若a[mid] = a[low] = a[high],则代表处于状态③或④ 否则，代表区间[low, high]不存在反转 1. 寻找旋转排序数组中的最小值123456789101112131415161718public int findMin(int[] nums) &#123; int low &#x3D; 0, high &#x3D; nums.length-1; while(low &lt; high)&#123; int mid &#x3D; low + (high - low) &#x2F; 2; if(nums[mid] &gt; nums[high])&#123; low &#x3D; mid+1; &#125; else if(nums[mid] &lt; nums[low])&#123; high &#x3D; mid; &#125; else&#123; high &#x3D; mid; &#125; &#125; return nums[low];&#125; 2. 寻找旋转排序数组中的最小值II123456789101112131415161718192021222324public int findMin(int[] nums) &#123; int low &#x3D; 0, high &#x3D; nums.length-1; while(low &lt; high)&#123; int mid &#x3D; low + (high - low) &#x2F; 2; if(nums[mid] &lt; nums[low])&#123; high &#x3D; mid; &#125; else if(nums[mid] &gt; nums[high])&#123; low &#x3D; mid + 1; &#125; else if(nums[mid] &#x3D;&#x3D; nums[low] &amp;&amp; nums[mid] &#x3D;&#x3D; nums[high])&#123; high--; &#125; else&#123; high &#x3D; mid; &#125; &#125; return nums[low];&#125; 3. 搜索旋转排序数组1234567891011121314151617181920212223242526272829303132333435363738public int search(int[] nums, int target) &#123; int low &#x3D; 0, high &#x3D; nums.length-1; while(low &lt;&#x3D; high)&#123; int mid &#x3D; low + (high - low) &#x2F; 2; if(nums[mid] &#x3D;&#x3D; target)&#123; return mid; &#125; if(nums[mid] &gt; nums[high])&#123; if(target &gt;&#x3D; nums[low] &amp;&amp; target &lt; nums[mid])&#123; high &#x3D; mid - 1; &#125; else&#123; low &#x3D; mid + 1; &#125; &#125; else if(nums[mid] &lt; nums[low])&#123; if(target &gt; nums[mid] &amp;&amp; target &lt;&#x3D; nums[high])&#123; low &#x3D; mid + 1; &#125; else &#123; high &#x3D; mid - 1; &#125; &#125; else &#123; if(target &gt; nums[mid])&#123; low &#x3D; mid + 1; &#125; else&#123; high &#x3D; mid - 1; &#125; &#125; &#125; return -1;&#125; 4. 搜索旋转排序数组II12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean search(int[] nums, int target) &#123; int low &#x3D; 0, high &#x3D; nums.length-1; while(low &lt;&#x3D; high)&#123; int mid &#x3D; low + (high - low) &#x2F; 2; if(nums[mid] &#x3D;&#x3D; target)&#123; return true; &#125; if(nums[mid] &gt; nums[high])&#123; if(target &gt;&#x3D; nums[low] &amp;&amp; target &lt; nums[mid])&#123; high &#x3D; mid - 1; &#125; else&#123; low &#x3D; mid + 1; &#125; &#125; else if(nums[mid] &lt; nums[low])&#123; if(target &gt; nums[mid] &amp;&amp; target &lt;&#x3D; nums[high])&#123; low &#x3D; mid + 1; &#125; else&#123; high &#x3D; mid - 1; &#125; &#125; else if(nums[mid] &#x3D;&#x3D; nums[low] &amp;&amp; nums[mid] &#x3D;&#x3D; nums[high])&#123; low++; high--; &#125; else&#123; if(target &gt; nums[mid])&#123; low &#x3D; mid + 1; &#125; else&#123; high &#x3D; mid - 1; &#125; &#125; &#125; return false;&#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"}]},{"title":"MVCC多版本并发控制","date":"2020-09-14T16:00:00.000Z","path":"2020/09/15/MVCC多版本并发控制/","text":"1. 什么是MVCCmvcc中文名位多版本并发控制，是数据库引擎处理读写冲突的一种手段，目的在于提高并发场景下数据库的吞吐量。 通过mvcc机制，在多个事务并发执行时，select可以无需加锁，而是通过mvcc机制读取指定版本的历史记录，可以保证读取的值符合事务所处的隔离级别。从而解决并发场景下的读写冲突。 在mysql数据库中，mvcc可以在读已提交和可重复读两种隔离级别下使用。 2. 为什么需要MVCC事务并发会导致一系列问题：丢失更新、脏读、不可重复读、幻读。数据库可以通过隔离级别来应对，实现隔离级别有两种方式： 加读写锁 mvcc【针对于select,更新还得加写锁】 但本质上，隔离级别是一种在并发性能和并发产生的副作用间的妥协。 3. mvcc的实现原理InnoDB引擎是通过每个表的两个隐藏字段实现的： DATA_TRX_ID：记录更新这条记录的事务ID DATA_ROLL_PTR：指向改行上一次的数据，在undo日志中以链表形式组织 此外InnoDB还有一个隐藏字段： DB_ROW_ID：如果表没有主键，此列会出现作为隐藏主键。 MVCC的判断流程如下： ReadView:是当前活动事务ID的列表[minid, maxid] 如果被访问数据的DATA_TRX_ID小于minid，说明该版本的数据在ReadView生成前，已经提交，可以直接返回 如果访问数据的DATA_TRX_ID大于maxid, 说明该版本的数据在ReadView生成后才生成，需要根据undo寻找上一个版本，继续判断 如果访问数据的DATA_TRX_ID在minid和maxid之间， 若DATA_TRX_ID在ReadView中，说明创建ReadView时，该版本所属事务尚未提交，需要寻找上一个版本 若DATA_TRX_ID不在ReadView中，说明创建ReadView时，该版本所属事务已经提交，可以直接返回 RC和RR两个隔离级别下一个很大的不同是：ReadView生成时间点不同，RC下每次select都会生成一个ReadView，事务执行期间会更新；而RR只在第一个select语句时生成一个ReadView，事务执行期间，不会更新。 参考：InnoDB MVCC 机制，看这篇就够了","tags":[{"name":"MySql","slug":"MySql","permalink":"http://yoursite.com/tags/MySql/"}]},{"title":"Java实现消费者-生产者模式","date":"2020-09-05T16:00:00.000Z","path":"2020/09/06/Java生产者-消费者/","text":"1. 生产者-消费者者模式生产者-消费者模式是并发场景下非常经典的设计模式。生产者用于生产物品，消费者消费生产者生产的物品。在Java中可以多种实现方式： synchronized锁 ReentrantLock锁 BlockingQueue阻塞队列 PipedInputStream/PipedOutputStream管道 Semaphore信号量 2. synchronized实现生产者-消费者1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class One &#123; private int productNum; private final int capacity = 10; private int ct; public synchronized void produce()&#123; while(productNum == capacity)&#123; notifyAll(); try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; productNum++; ct++; System.out.println(ct+&quot;生产一个商品：&quot; + productNum + &quot; &quot; + Thread.currentThread().getName() + &quot;获得锁&quot;); notifyAll(); &#125; public synchronized void consume()&#123; while(productNum == 0) &#123; notifyAll(); try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; productNum--; ct++; System.out.println(ct + &quot;消费一个商品：&quot; + productNum + &quot; &quot; + Thread.currentThread().getName() + &quot;获得锁&quot;); notifyAll(); &#125; public static void main(String[] args) &#123; One one = new One(); for(int i = 0; i &lt; 100; i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; one.produce(); &#125; &#125;, &quot;P&quot;+i).start(); &#125; for(int i = 0; i &lt; 100; i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; one.consume(); &#125; &#125;, &quot;C&quot;+i).start(); &#125; &#125;&#125; 实现的刚开始唤醒线程用的是notify方法，会出现线程一直阻塞无法推进的问题。原因是notify是随机唤醒一个阻塞的线程，如果在执行的某个时刻，productNum = 0而且生产线程全部是Runnable状态，此时会有一个消费线程处于Blocked状态。结果显然易见，会出现死循环，两个消费线程相互唤醒阻塞。 synchronized锁编写起来非常简单，但是消费线程和生产线程会处于一个等待队列，他们的等待条件相同，而ReentrantLock可以指定等待条件。 2. ReentrantLock实现生产者-消费者模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Two &#123; private final Lock lock = new ReentrantLock(); private int productNum = 0; private final int capacity = 10; private int ct; private final Condition notFull = lock.newCondition(); // 生产者生产 private final Condition notEmpty = lock.newCondition(); // 消费者消费 public void produce()&#123; try&#123; lock.lock(); while(productNum == capacity)&#123; notEmpty.signal(); // 唤醒一个消费线程 notFull.await(); // 挂起当前生产线程 &#125; productNum++; ct++; System.out.println(ct+&quot;生产一个商品：&quot; + productNum + &quot; &quot; + Thread.currentThread().getName() + &quot;获得锁&quot;); notEmpty.signal(); // 唤醒一个消费线程 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void consume()&#123; try&#123; lock.lock(); while(productNum == 0)&#123; notFull.signal(); // 唤醒一个生产线程 notEmpty.await(); // 挂起当前消费线程 &#125; productNum--; ct++; System.out.println(ct+&quot;消费一个商品：&quot; + productNum + &quot; &quot; + Thread.currentThread().getName() + &quot;获得锁&quot;); notFull.signal(); // 唤醒一个生产线程 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; Two two = new Two(); for(int i = 0; i &lt; 100; i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; two.produce(); &#125; &#125;, &quot;P&quot;+i).start(); &#125; for(int i = 0; i &lt; 100; i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; two.consume(); &#125; &#125;, &quot;C&quot;+i).start(); &#125; &#125;&#125; 3. BlockingQueue实现生产者-消费者模式1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Three &#123; private final BlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;&gt;(10); public void produce()&#123; try &#123; blockingQueue.put(1);; System.out.println(Thread.currentThread().getName() + &quot; 生产一个物品:&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public void consume()&#123; try&#123; blockingQueue.take(); System.out.println(Thread.currentThread().getName() + &quot; 消费一个物品&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Three three = new Three(); for(int i = 0; i &lt; 100; i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; three.produce(); &#125; &#125;, &quot;P&quot;+i).start(); &#125; for(int i = 0; i &lt; 100; i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; three.consume(); &#125; &#125;, &quot;C&quot;+i).start(); &#125; &#125;&#125; 阻塞队列：当队列为满时，阻塞当前生产者线程，唤醒消费者线程；当队列为空的时候，阻塞当前消费者线程，唤醒生产者线程。 4.管道输入输出流PipedInputStream和PipedOutputStream实现生产者-消费者模式使用方法：先创建一个管道输入流和管道输出流，然后将输入流和输出流进行连接，用生产者线程往管道输出流中写入数据，消费者在管道输入流中读取数据，这样就可以实现了不同线程间的相互通讯，但是这种方式在生产者和生产者、消费者和消费者之间不能保证同步，也就是说在一个生产者和一个消费者的情况下是可以生产者和消费者之间交替运行的，多个生成者和多个消费者者之间则不行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Four &#123; private final PipedInputStream input = new PipedInputStream(); private final PipedOutputStream output = new PipedOutputStream(); public Four()&#123; try &#123; input.connect(output); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public void produce()&#123; try &#123; int t = (int)(Math.random() * 255); output.write(t); output.flush(); System.out.println(&quot;生产一个商品&quot; + t); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public void consume()&#123; try &#123; int t = input.read(); System.out.println(&quot;消费一个商品&quot; + t); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Four four = new Four(); new Thread(new Runnable() &#123; @Override public void run() &#123; for(int i = 0; i &lt; 100; i++)&#123; four.produce(); &#125; &#125; &#125;).start(); new Thread(new Runnable() &#123; @Override public void run() &#123; for(int i = 0; i &lt; 100; i++)&#123; four.consume(); &#125; &#125; &#125;).start(); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; four.input.close(); four.output.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5. Semaphore实现生产者-消费者模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Five &#123; private int productNum = 0; private final Semaphore notFull = new Semaphore(10); private final Semaphore notEmpty = new Semaphore(10); private final Semaphore mutex = new Semaphore(1); public void produce()&#123; try &#123; notFull.acquire(); mutex.acquire(); productNum++; System.out.println(&quot;生产一个商品&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; mutex.release(); notEmpty.release(); &#125; &#125; public void consume()&#123; try&#123; notEmpty.acquire(); mutex.acquire(); productNum--; System.out.println(&quot;消费一个商品&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; mutex.release(); notFull.release(); &#125; &#125; public static void main(String[] args) &#123; Five five = new Five(); for(int i = 0; i &lt; 100; i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; five.produce(); &#125; &#125;, &quot;P&quot;+i).start(); &#125; for(int i = 0; i &lt; 100; i++)&#123; new Thread(new Runnable() &#123; @Override public void run() &#123; five.consume(); &#125; &#125;, &quot;C&quot;+i).start(); &#125; &#125;&#125;","tags":[]},{"title":"百度后台开发笔试","date":"2020-09-02T16:00:00.000Z","path":"2020/09/03/百度后台开发笔试/","text":"1.一个长为n的正整数数组，里面的每个元素不是0就是5。从数组中选出若干数字组成一个数字，要求能整除90。求满足条件的最大的数字，不存在就输出-1。12345输入：125 5 5 5 5 5 0 0 5 5 5 5输出：55555555500 数字能整除90—&gt;能整除10，结果还能整除9 一个数字能整除9—&gt;每位之和能整除90 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class One &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); int fiveNum = 0; int zeroNum = 0; for(int i = 0; i &lt; n; i++)&#123; if(scan.nextInt() == 5)&#123; fiveNum++; &#125; else&#123; zeroNum++; &#125; &#125; // 一个0都不存在时 if(zeroNum == 0)&#123; System.out.println(-1); return; &#125; // 5可以最多出现几次 while(fiveNum &gt; 0)&#123; if((fiveNum * 5) % 9 == 0)&#123; break; &#125; fiveNum--; &#125; // 5一次都没有 if(fiveNum == 0)&#123; System.out.println(&quot;0&quot;); return; &#125; // 可以有fiveNum个5，zeroNum个0，毫无疑问5在前0在后 String s = new String(&quot;&quot;); while(fiveNum &gt; 0)&#123; s += &quot;5&quot;; fiveNum--; &#125; while(zeroNum &gt; 0)&#123; s += &quot;0&quot;; zeroNum--; &#125; System.out.println(s); &#125;&#125; 2.有n头奶牛，每头奶牛进行m项测评，所有测评都通过的是优质奶牛。注意区间的重合问题。但是不知道什么原因一直超时 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Two &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int T = scan.nextInt(); while(T-- &gt; 0)&#123; int n = scan.nextInt(), m = scan.nextInt(); // 奶牛数，资质数 int[] ct = new int[n+1]; boolean[] visited = new boolean[n+1]; for(int i = 1; i &lt;= m; i++)&#123; // 每种资质下有k个区间满足 Arrays.fill(visited, false); int k = scan.nextInt(); // 区间数 while(k-- &gt; 0)&#123; int l = scan.nextInt(), r = scan.nextInt(); // 区间开始结束 while(l &lt;= r)&#123; if(visited[l])&#123; // 去重 continue; &#125; ct[l]++; visited[l] = true; l++; &#125; &#125; &#125; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int i = 1; i &lt;= n; i++)&#123; if(ct[i] == m)&#123; list.add(i+&quot;&quot;); &#125; &#125; Collections.sort(list); System.out.println(list.size()); for(String s : list)&#123; System.out.print(s + &quot; &quot;); &#125; &#125; &#125;&#125; 3.有n阶台阶，每次可以跨1-m步，要求每次跨的步数与前两次都不同。求登顶的次数还有一种解法dp[i][j][k]表示到达k前两步分别为j,k的方案数，用动态规划解决。 123456789101112131415161718192021222324252627282930313233343536373839404142public class Three &#123; public static void main(String[] args) &#123; Scanner scan &#x3D; new Scanner(System.in); int n &#x3D; scan.nextInt(), m &#x3D; scan.nextInt(); Map&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;(); int ct &#x3D; backtracking(0, -1, -1, n, m, map); System.out.println(ct); &#125; private static int backtracking(int lastLast, int last, int cur, int n, int m, Map&lt;String, Integer&gt; map) &#123; if(cur &#x3D;&#x3D; n)&#123; return 1; &#125; if(cur &gt; n)&#123; return 0; &#125; String str &#x3D; lastLast + &quot;-&quot; + last + &quot;_&quot; + cur; if(map.containsKey(str))&#123; return map.get(str); &#125; int ct &#x3D; 0; for(int i &#x3D; 1; i &lt;&#x3D; m; i++)&#123; ct +&#x3D; backtracking(last, i, cur+i, n, m, map); &#125; ct %&#x3D;1000000007; map.put(str, ct); return ct; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"百度","slug":"百度","permalink":"http://yoursite.com/tags/%E7%99%BE%E5%BA%A6/"}]},{"title":"Redis系列之缓存不一致","date":"2020-08-29T16:00:00.000Z","path":"2020/08/30/Redis系列之缓存不一致/","text":"缓存不一致指的是缓存中的数据与数据库中的数据发生了不一致的情况。一般常用的缓存方案有两种： 方案一： 读的时候，先读缓存，缓存没有的话，读数据库，取出数据后放入缓存，同时返回响应。 更新的时候，先删除缓存，再更新数据库 方案二： 读的时候，先读缓存，缓存没有的话，读数据库，取出数据后放入缓存，同时返回响应。 更新的时候，先更新数据库，再删除缓存 两种方案数据库缓存不一致发生的场景： 方案一：T1删除缓存-&gt;T2读缓存(没有)，读数据库，并放入缓存-&gt;T1更新数据库 方案二：T1读缓存(没有)，读数据库-&gt;T2更新数据库，删除缓存-&gt;T1放入缓存 解决方案： 一般来说，我们对缓存的一致性要求并没有很高，只要求最终一致性，在较短的时间内不一致都是能忍受的。不论是前面哪一种方案，就算发生了，再来一次更新请求只要不发生同样的情况，缓存都会被再次刷成一致的。所以解决方案从简易到复杂就有缓存过期时间兜底，保证“更新数据库、删除缓存”和“读数据库并设置缓存”的之间串行化。 缓存过期时间兜底 就算更新操作非常少，没有更新操作，也有一个缓存过期时间，在缓存过期之后再次刷新缓存。 读若未命中，将读并放入缓存操作放入该线程的队列；更新操作也放入该线程的队列 更新操作执行后，向MQ发消息置缓存失效。","tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"美团8.29后端笔试","date":"2020-08-29T16:00:00.000Z","path":"2020/08/30/美团8.29后端笔试/","text":"1. 小团的神秘暗号一字符串为其加上一个头部和尾部进行加密。头部至少包含一个“MT”的子序列，且以T结尾。尾部至少包含一个“MT”的子序列，且以M开始。求得取出头部、尾部后的最大字符串。 12345输入：10MMATSATMMT输出：SATM 送分题，找出最靠前的头部和最靠后的尾部，剩下的就是最长的字符串。 1234567891011121314151617181920212223242526272829303132public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = Integer.valueOf(scan.nextLine()); String str = scan.nextLine(); int start = 0, end = n-1; boolean flag1 = false, flag2 = false; for(int i = 0; i &lt; n; i++)&#123; if(str.charAt(i) == &#x27;M&#x27;)&#123; flag1 = true; &#125; if(str.charAt(i) == &#x27;T&#x27; &amp;&amp; flag1)&#123; start = i+1; break; &#125; &#125; for(int i = n-1; i &gt;= 0; i--)&#123; if(str.charAt(i) == &#x27;T&#x27;)&#123; flag2 = true; &#125; if(str.charAt(i) == &#x27;M&#x27; &amp;&amp; flag2)&#123; end = i-1; break; &#125; &#125; System.out.println(str.substring(start, end+1));&#125; 2. 小团的选调计划有n个人编号1-n，有n个任务，编号1-n。每个人可以填写选择任务的志愿，编号小的优先被满足。求出每个人最终分配的任务。 123456789输入：51 5 3 4 22 3 5 4 15 4 1 2 31 2 5 4 31 4 5 2 3输出：1 2 5 4 3 送分题，记录任务的领取状况，按人员编号从小到大，依次按其志愿领取任务未领取的任务。‘ 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; Scanner scan &#x3D; new Scanner(System.in); int n &#x3D; scan.nextInt(); int[][] nums &#x3D; new int[n][n]; for(int i &#x3D; 0; i &lt; n; i++)&#123; for(int j &#x3D; 0; j &lt; n; j++)&#123; nums[i][j] &#x3D; scan.nextInt(); &#125; &#125; boolean[] selected &#x3D; new boolean[n+1]; int[] res &#x3D; new int[n]; for(int i &#x3D; 0; i &lt; n; i++)&#123; for(int j &#x3D; 0; j &lt; n; j++)&#123; if(!selected[nums[i][j]])&#123; selected[nums[i][j]] &#x3D; true; res[i] &#x3D; nums[i][j]; break; &#125; &#125; &#125; for(int m : res)&#123; System.out.print(m+&quot; &quot;); &#125;&#125; 3. 小团无路可逃有一颗树，小团位于y位置，小美位于x位置。小美要追打小团，每次小美和小团可以向相邻位置转移（小团可以不动）。问最多多久小美可以追上小团。 12345678输入：5 1 22 13 14 25 3输出：2 求出小美距所有节点的最短距离[dx1, dx2, …]，小团距所欲节点的最短距离[dy1, dy2, …]。则问题的结果是满足dxi &gt; dyi的最大dxi。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public static void main(String[] args) &#123; Scanner scan &#x3D; new Scanner(System.in); int n &#x3D; scan.nextInt(), x &#x3D; scan.nextInt(), y &#x3D; scan.nextInt(); List&lt;Integer&gt;[] lists &#x3D; new List[n+1]; for(int i &#x3D; 0; i &lt; n-1; i++)&#123; int u &#x3D; scan.nextInt(), v &#x3D; scan.nextInt(); lists[u] &#x3D; lists[u] &#x3D;&#x3D; null ? new ArrayList&lt;&gt;() : lists[u]; lists[v] &#x3D; lists[v] &#x3D;&#x3D; null ? new ArrayList&lt;&gt;() : lists[v]; lists[u].add(v); lists[v].add(u); &#125; int[] dist1 &#x3D; getDistance(x, n, lists); int[] dist2 &#x3D; getDistance(y, n, lists); int res &#x3D; 0; for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123; if(dist1[i] &gt; dist2[i])&#123; res &#x3D; Math.max(res, dist1[i]); &#125; &#125; System.out.println(res);&#125;&#x2F;&#x2F; 迪杰斯特拉算法求单源最短路径(还可以通过BFS算法求)private static int[] getDistance(int start, int n, List&lt;Integer&gt;[] lists) &#123; int[] dist &#x3D; new int[n+1]; &#x2F;&#x2F; 节点编号1-n boolean[] flag &#x3D; new boolean[n+1]; Arrays.fill(dist, -1); &#x2F;&#x2F; -1 代表不可达 if(lists[start] &#x3D;&#x3D; null)&#123; return dist; &#125; for(int next : lists[start])&#123; dist[next] &#x3D; 1; &#125; flag[start] &#x3D; true; for(int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123; &#x2F;&#x2F; 找出下一个最近距离节点 int min &#x3D; 0; &#x2F;&#x2F; 初始 for(int j &#x3D; 1; j &lt;&#x3D; n; j++)&#123; if(!flag[j] &amp;&amp; dist[j] !&#x3D; -1)&#123; &#x2F;&#x2F; 节点j尚未求出最短距离，且节点j目前可达 min &#x3D; min &#x3D;&#x3D; 0 ? j : dist[min] &gt; dist[j] ? j : min; &#125; &#125; flag[min] &#x3D; true; &#x2F;&#x2F; min节点加入最终集和 for(int next : lists[min])&#123; &#x2F;&#x2F; 通过min,更新未求出最短距离的节点 if(!flag[next])&#123; if(dist[next] &#x3D;&#x3D; -1)&#123; dist[next] &#x3D; dist[min] + 1; &#125; else&#123; dist[next] &#x3D; Math.min(dist[next], dist[min] + 1); &#125; &#125; &#125; &#125; return dist;&#125; 3. 小团的默契游戏一个长为n的整数数组，最大值不超过m。给一个组合(l, r)，使得按序取数组中满足a[i]&lt;l或a[i]&gt;r组成的数组是单调不下降的。其中1&lt;=l&lt;=r&lt;=m。 12345输入：5 54 1 4 1 2输出：10 最简单的方式是通过三层循环解决该问题，但仔细分析可以发现一下规律： 若(l, r)满足，则(l, r+1)肯定满足 若(l, r)满足，则(l+1, )满足的话，只能是\\&gt;=r 通过这两点可以进行充分的剪枝。 123456789101112131415161718192021222324252627282930313233343536public static void main(String[] args) &#123; Scanner scan &#x3D; new Scanner(System.in); int m &#x3D; scan.nextInt(), n &#x3D; scan.nextInt(); int[] nums &#x3D; new int[n]; for(int i &#x3D; 0; i &lt; n; i++)&#123; nums[i] &#x3D; scan.nextInt(); &#125; int ct &#x3D; 0; int l, r, i; int star &#x3D; 1; &#x2F;&#x2F; 虽然n的数量级时10^5, 但加入了两处剪枝后，可以大幅降低时间复杂度 for(l &#x3D; 1; l &lt;&#x3D; m; l++)&#123; for(r &#x3D; star; r &lt;&#x3D; m; r++)&#123; &#x2F;&#x2F; l时的r必然是l-1时r的子集---第二处剪枝 int pre &#x3D; 0; for(i &#x3D; 0; i &lt; n; i++)&#123; if(nums[i] &lt; l || nums[i] &gt; r)&#123; if(nums[i] &lt; pre)&#123; break; &#125; pre &#x3D; nums[i]; &#125; &#125; if(i &#x3D;&#x3D; n)&#123; &#x2F;&#x2F; 子序列是非降序排列---第一处剪枝-1 break; &#125; &#125; if(r &lt;&#x3D; m)&#123; &#x2F;&#x2F; [r, m]必然满足---第一处剪枝-2 ct +&#x3D; m - r + 1; &#125; star &#x3D; r; &#125; System.out.println(ct);&#125;","tags":[{"name":"笔试","slug":"笔试","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"},{"name":"美团","slug":"美团","permalink":"http://yoursite.com/tags/%E7%BE%8E%E5%9B%A2/"}]},{"title":"字节跳动2021后端笔试第二场08.16","date":"2020-08-15T16:00:00.000Z","path":"2020/08/16/字节跳动2021后端笔试第二场08.16/","text":"1. 统计二叉树中的叶子节点数给出二叉树中的前序和中序遍历，求出二叉树中有多少个叶子节点。 123456输入：3 // 节点数2 1 3 // 前序序列3 1 2 // 中序序列输出：1 // 叶子节点数 答题过程中采用的方法是重建+遍历统计，最终只过了90%，说是数组越界，但buildTree经过在Leetcode和牛客网都测试了一遍，都能通过，想不明白。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 二叉树节点class TreeNode&#123; int val; TreeNode left, right;&#125;public class One &#123; private static int ct = 0; private static TreeNode buildTree(int[] preOrder, int prest, int preed, int[] inOrder, int inst, int ined) &#123; if(prest &gt; preed)&#123; // 没有子树 return null; &#125; TreeNode root = new TreeNode(); root.val = preOrder[prest]; int mid; for(mid = inst; mid &lt;= ined &amp;&amp; root.val != inOrder[mid]; mid++); int len = mid - inst; root.left = buildTree(preOrder, prest+1, prest+len, inOrder, inst, mid-1); root.right = buildTree(preOrder, prest+len+1, preed, inOrder, mid+1,ined); return root; &#125; private static void traceAll(TreeNode root) &#123; if(root == null)&#123; return; &#125; traceAll(root.left); traceAll(root.right); if(root.left == null &amp;&amp; root.right == null)&#123; ct++; &#125; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); // 二叉树的节点数 int[] preOrder = new int[n]; // 前序序列 int[] inOrder = new int[n]; // 中序序列 for(int i = 0; i &lt; n; i++)&#123; preOrder[i] = scan.nextInt(); &#125; for(int i = 0; i &lt; n; i++)&#123; inOrder[i] = scan.nextInt(); &#125; TreeNode root = buildTree(preOrder, 0, n-1, inOrder, 0, n-1); ct = 0; traceAll(root); System.out.println(ct); &#125;&#125; 其实，统计叶子节点数，在buildTree的时候就可以统计，可以节省一次遍历： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class One &#123; private static int ct = 0; private static TreeNode buildTree(int[] preOrder, int prest, int preed, int[] inOrder, int inst, int ined) &#123; if(prest &gt; preed)&#123; // 没有子树 return null; &#125; if(prest == preed &amp;&amp; inst == ined)&#123; // 叶子节点 ct++; &#125; TreeNode root = new TreeNode(); root.val = preOrder[prest]; int mid; for(mid = inst; mid &lt;= ined &amp;&amp; root.val != inOrder[mid]; mid++); int len = mid - inst; root.left = buildTree(preOrder, prest+1, prest+len, inOrder, inst, mid-1); root.right = buildTree(preOrder, prest+len+1, preed, inOrder, mid+1,ined); return root; &#125; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); // 二叉树的节点数 int[] preOrder = new int[n]; // 前序序列 int[] inOrder = new int[n]; // 中序序列 for(int i = 0; i &lt; n; i++)&#123; preOrder[i] = scan.nextInt(); &#125; for(int i = 0; i &lt; n; i++)&#123; inOrder[i] = scan.nextInt(); &#125; ct = 0; TreeNode root = buildTree(preOrder, 0, n-1, inOrder, 0, n-1); System.out.println(ct); &#125;&#125; 2. 有效字符一个由0-9，A-F组成的字符串，里面不能出现0010，问至少删除多少个字符，能满足要求。 1234567输入：2 &#x2F;&#x2F; 测试用例数01000010ABCDEF输出：01 没想到什么很好的解决方法，最后骗分的代码竟然AC了，纯属瞎猫碰上死耗子： 1234567891011121314151617181920212223public class Two &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int t = Integer.valueOf(scan.nextLine()); while(t-- &gt; 0)&#123; String s = scan.nextLine(); int len = s.length(); int ct = 0; for(int i = 0; i &lt; len - 3; i++)&#123; if(s.charAt(i) == &#x27;0&#x27; &amp;&amp; s.charAt(i+1) == &#x27;0&#x27; &amp;&amp; s.charAt(i+2) == &#x27;1&#x27; &amp;&amp; s.charAt(i+3) == &#x27;0&#x27;)&#123; ct++; i += 2; &#125; &#125; System.out.println(ct); &#125; &#125;&#125; 看到讨论区里的解释是只要找有几个“0010”即可，仔细想想确实是，比如00100010至少删去两个字符，0010010至少删去两个字符，001010至少删去一个字符： 123456789101112131415161718192021public class Two &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int t = Integer.valueOf(scan.nextLine()); while(t-- &gt; 0)&#123; String s = scan.nextLine(); int len = s.length(); int ct = 0; for(int i = 0; i &lt; len - 3; i++)&#123; if(s.charAt(i) == &#x27;0&#x27; &amp;&amp; s.charAt(i+1) == &#x27;0&#x27; &amp;&amp; s.charAt(i+2) == &#x27;1&#x27; &amp;&amp; s.charAt(i+3) == &#x27;0&#x27;)&#123; ct++; &#125; &#125; System.out.println(ct); &#125; &#125;&#125; 这类题目应该通过例子，找出规律。 3. 插入广告给n段视频，每段视频长度为L_i。现在需要向视频中插入广告，为了用户体验，插入的间隔越大越好。插入间隔可以为0，现有m段广告，问最大的插入间隔是多少。如果无法插入，则*** 12345输入：n mL_1 L_2 ... L_n输入：最大间隔 是在想不出怎么会有无法插入的情况，大不了间隔为0，一直放广告，随便一段视频都能插入完啊。还有中间广播提示广告可以无限插入，这道题根本get不到点，直接放弃了。 评论区讨论是用二分法解决的，突然恍然大悟：如果间隔为x，那么视频i最多能插入L_i / x段视频。这点笔试中想到了，但是没有联系到二分法，所以感觉没有思路。这道题nlogn是可以通过的，广告的最小间隔是0，最大间隔是max{L_i}。那么这道题就可以转化为二分法求最大的大于指定数。 12345678910111213141516171819202122232425262728293031323334353637383940public class Three &#123; public static void main(String[] args) &#123; Scanner scan &#x3D; new Scanner(System.in); int n &#x3D; scan.nextInt(), m &#x3D; scan.nextInt(); int[] lens &#x3D; new int[n]; int left &#x3D; 0, right &#x3D; 0; for(int i &#x3D; 0; i &lt; n; i++)&#123; lens[i] &#x3D; scan.nextInt(); right &#x3D; Math.max(right, lens[i]); &#125; while(left &lt; right)&#123; int mid &#x3D; left + (right - left + 1) &#x2F; 2; int ct &#x3D; count(lens, mid); if(ct &lt; m)&#123; right &#x3D; mid - 1; &#125; else&#123; left &#x3D; mid; &#125; &#125; System.out.println(left); &#125; private static int count(int[] lens, int mid) &#123; int ct &#x3D; 0; for(int m : lens)&#123; ct +&#x3D; m &#x2F; mid + 1; &#125; return ct; &#125;&#125; 这道题目，可能需要使用long类型，不过解决问题的思路有了，才是最关键的。 4. 最大的sum % m长度为n的整数数组，从数组中选取0-n个数，选取的数的和记为sum，求最大的sum%m。 122 &lt;&#x3D; m &lt;&#x3D; 1e9+7n &lt;&#x3D; 35 这道题看起来是0-1背包，但m的数量级太大，直接劝退。后来考虑递归遍历所有情况，时间复杂度2^n，也会超时，最终通过40%。看评论区，暴力dfs居然过了60%，为什么我的只过了40%，难道是因为用的是java吗。 看评论区，通过将数组分为两组，思路以后再写。","tags":[{"name":"笔试","slug":"笔试","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"},{"name":"字节","slug":"字节","permalink":"http://yoursite.com/tags/%E5%AD%97%E8%8A%82/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"SSH连接虚拟机Ubuntu","date":"2020-08-14T16:00:00.000Z","path":"2020/08/15/SSH连接虚拟机Ubuntu/","text":"1. 查看虚拟机ip地址在Ubuntu下输入命令查看ip地址： 1ifconfig 2. 测试ip地址是否可达Windows下打开cmd，输入： 1ping [ip地址] 3. 安装ssh首先测试Ubuntu是否安装ssh: 1ssh localhost 若连接失败，则需要安装ssh服务： 1sudo apt-get install openssh-server 安装完成后，确认ssh服务处于启动状态： 1sudo service ssh status 出现Active: active (running)，代表正在正在运行。 4. 使用XShell或git连接Ubuntu","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://yoursite.com/tags/Ubuntu/"}]},{"title":"2021美团正式批笔试8.15","date":"2020-08-14T16:00:00.000Z","path":"2020/08/15/2021美团正式批笔试8.15/","text":"1. 特殊的逆序对如果一个数的四倍是它的逆序数，那么这两个数就构成了一个逆序数对。给一个正整数n，求不大于n的正整数构成的逆序数对。 提示： 11234的逆序数是4321，1100的逆序数是11 输入： 1输入正整数n 输出： 12第一行输出共有多少对逆序数从第二行开始每行输出一对逆序数，按第一个数从小到达开始输出，没有就不输出 示例： 12345输入：10000输出：12178 8712 *没有考虑到4i可能已经超出了n，最终代码只通过了55%：** 1234567891011121314151617181920212223242526272829303132333435363738import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); int n = scan.nextInt(); List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); for(int i = 1; i &lt;= n; i++)&#123; int t = i * 4; if(t &lt;= n &amp;&amp; judge(i))&#123; // 丢掉了重要条件 list.add(new int[]&#123;i, t&#125;); &#125; &#125; System.out.println(list.size()); for(int[] arr : list)&#123; System.out.println(arr[0] + &quot; &quot; + arr[1]); &#125; &#125; private static boolean judge(int a) &#123; String str1 = String.valueOf(a); int b = Integer.valueOf(new StringBuilder(str1).reverse().toString()); return a*4 == b; &#125;&#125; 2. 统计旅行次数每次旅行会从一个城市出发，经过若干城市后回到出发的城市。现给出若干次旅行所有的城市之间的通行信息，请你找出总共旅行了多少次。其中不会包括无效的旅行信息。 输入： 12第一行输入n，代表通行信息条数此后每行输入出发城市，到达城市 输出： 1一共旅行了多少次 示例： 12345678910输入：6beijing chongqingchongqing hangzhouhangzhou beijingbeijing xianxian beijing输出：2 看评论才知道，要考虑A-A这种情况（但自己的代码没问题啊），代码只通过了91%： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.*;&#x2F;** * @author shkstart * @create 2020-08-15 16:36 *&#x2F;public class Two &#123; public static void main(String[] args) &#123; Scanner scan &#x3D; new Scanner(System.in); int n &#x3D; Integer.valueOf(scan.nextLine()); Map&lt;String, List&lt;String&gt;&gt; map &#x3D; new HashMap&lt;&gt;(); for(int i &#x3D; 0; i &lt; n; i++)&#123; String[] strs &#x3D; scan.nextLine().split(&quot; &quot;); List&lt;String&gt; list &#x3D; map.getOrDefault(strs[0], new ArrayList&lt;&gt;()); list.add(strs[1]); map.put(strs[0], list); &#125; int ct &#x3D; 0; for(String key : map.keySet())&#123; List&lt;String&gt; list &#x3D; map.get(key); while(list.size() &gt; 0)&#123; if(dfs(key, key, map))&#123; ct++; &#125; &#125; &#125; System.out.println(ct); &#125; private static boolean dfs(String start, String key, Map&lt;String, List&lt;String&gt;&gt; map) &#123; List&lt;String&gt; list &#x3D; map.get(key); int i &#x3D; 0; boolean res &#x3D; false; for(i &#x3D; 0; i &lt; list.size(); i++)&#123; String next &#x3D; list.get(i); if(next.equals(start))&#123; res &#x3D; true; &#125; else&#123; res &#x3D; dfs(start, next, map); &#125; if(res)&#123; break; &#125; &#125; if(res)&#123; list.remove(i); &#125; return res; &#125;&#125; 补充： 真无语，难道真的是自己审题有问题吗，看到有人居然一遍遍历就过了，把题想难了： 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int count; cin&gt;&gt;count; vector&lt;pair&lt;string,string&gt;&gt;res; string str1,str2; for(int i &#x3D; 0;i &lt; count;i++)&#123; cin&gt;&gt;str1&gt;&gt;str2; res.push_back(&#123;str1,str2&#125;); &#125; int len &#x3D; 1; count &#x3D; res.size(); for(int i &#x3D; 0;i &lt; count - 1;i++)&#123; if(res[i].second !&#x3D; res[i + 1].first)len++; &#125; cout&lt;&lt;len&lt;&lt;endl; return 0;&#125; 3. 小区人员划分有n个人编号1-n，给出关系&lt;a, b&gt;代表a和b同属一个小区。请你根据给出的关系，对人员进行划分。 输入： 12第一行输入n，m分别代表人员数，和关系数第二行开始每行输入关系a b , 共输入m行 输出： 123第一行输出n个人共有几个小区此后每行，输出每个小区的人员，编号递增小区顺序：编号最小的人员的编号越小，越优先输出 示例： 1 通过并查集思想，不难解决，此次笔试唯一AC的题： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.*;&#x2F;** * @author shkstart * @create 2020-08-15 17:24 *&#x2F;public class Three &#123; public static void main(String[] args) &#123; Scanner scan &#x3D; new Scanner(System.in); int n &#x3D; scan.nextInt(), m &#x3D; scan.nextInt(); int[] mark &#x3D; new int[n+1]; Map&lt;Integer, List&lt;Integer&gt;&gt; map &#x3D; new HashMap&lt;&gt;(); for(int i &#x3D; 1; i &lt;&#x3D; n ;i++)&#123; mark[i] &#x3D; i; List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;(); list.add(i); map.put(i, list); &#125; for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123; int a &#x3D; scan.nextInt(), b &#x3D; scan.nextInt(); int c_a &#x3D; mark[a], c_b &#x3D; mark[b]; if(c_a &#x3D;&#x3D; c_b)&#123; continue; &#125; List&lt;Integer&gt; listA&#x3D; map.get(c_a); List&lt;Integer&gt; listB &#x3D; map.get(c_b); for(int t : listB)&#123; mark[t] &#x3D; c_a; listA.add(t); &#125; map.remove(c_b); &#125; System.out.println(map.size()); Set&lt;Integer&gt; set &#x3D; new HashSet&lt;&gt;(); for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123; int c &#x3D; mark[i]; if(set.contains(c))&#123; continue; &#125; List&lt;Integer&gt; list &#x3D; map.get(c); Collections.sort(list); for(int num : list)&#123; System.out.print(num + &quot; &quot;); &#125; System.out.println(); set.add(c); &#125; &#125;&#125; 4. 运输的最高收益运输公司有n辆车，位于不同位置。现有两个地方都要用车，每辆车由于位置不同到两地的运输收益也不同。连个地方分别要a辆车，b辆车。请你计算出运输的最大收益。 输入： 123第一行：n, a, b第二行：a1 a2 ... an 每辆车到第一个地方的收益第二行：b1 b2 ... bn 每辆车到第二个地方的收益 输出： 1最大收益 示例： 123456输入：5 2 24 3 5 5 12 3 4 3 5输出：18 这道题应该是道动态规划的题，和背包也挺像的，暂时没思路： 1","tags":[{"name":"笔试","slug":"笔试","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"}]},{"title":"背包问题解析","date":"2020-08-13T16:00:00.000Z","path":"2020/08/14/背包问题解析/","text":"1. 0-1背包背包的能容纳的最大重量为W，有N个物品，每个物品的重量为wi，价值为vi。求背包可容纳的物品的最大价值。 定义二维数组dp[N][W]，dp[i][j]表示前i个物品在重量不超过j的情况下能容纳物品的最大价值。设第i件物品的重量为wi, 价值为vi，根据第i件物品是否在背包中，可以有两种情况： 第i件物品不放在背包中，dp[i][j]（前i件物品放入容量为j的背包的最大价值） = dp[i-1][j]（前i-1件物品放入容量为j的背包的最大价值） 第i件物品放入背包中，dp[i][j]（前i件物品放入容量为j的背包的最大价值） = dp[i-1][j-wi] + vi（前i-1件物品放入容量为j-wi的背包的最大价值 + vi） dp[i][j]应该取两者的较大的，状态转移方程为：$$dp[i][j] = max{dp[i-1][j],\\quad dp[i-1][j-w_i],+,v_i}$$ 12345678910111213141516public int solve(int[] weights, int[] values, int W, int N)&#123; int[][] dp &#x3D; new int[N+1][W+1]; for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123; int w &#x3D; weights[i-1], v &#x3D; values[i-1]; for(int j &#x3D; 1; j &lt;&#x3D; W; j++)&#123; dp[i][j] &#x3D; dp[i-1][j]; if(j - w &gt;&#x3D; 0)&#123; dp[i][j] &#x3D; Math.max(dp[i][j], dp[i-1][j-w] + v); &#125; &#125; &#125; return dp[N][W];&#125; 空间优化 观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。此时，$$dp[j] = max{dp[j],,, dp[j-w_i],+,v_i}$$因为dp[j-wi]代表的是dp[i-1][j-wi]，为了避免覆盖掉dp[i-1][j-wi]，也就是说要先计算 dp[i][j] 再计算 dp[i][j-wi]，在程序实现时需要按倒序来循环求解。 1234567891011121314public int solve(int[] weights, int[] values, int W, int N)&#123; int[] dp &#x3D; new int[W+1]; for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123; int w &#x3D; weights[i-1], v &#x3D; values[i-1]; &#x2F;&#x2F; dp[j] 代表没有第i件物品容量为j的最大价值 for(int j &#x3D; W; j &gt;&#x3D; w; j--)&#123; dp[j] &#x3D; Math.max([j], dp[j-w] + v); &#125; &#125; return dp[N][W];&#125; 例题 416. 分割等和子集 我们可以先求出数组所有元素的和sum，问题可以转化为0-1背包问题：背包的容量为sum/2，原数组就是每件物品的重量，判断背包是否可以正好装满。 此问题没有涉及物品的价值：求的是是否能将背包装满，所以无需考虑物品的价值。 12345678910111213141516171819202122232425public boolean canPartition(int[] nums) &#123; int n &#x3D; nums.length; int sum &#x3D; 0; for(int m : nums)&#123; sum +&#x3D; m; &#125; if(sum % 2 &#x3D;&#x3D; 1)&#123; return false; &#125; int S &#x3D; sum &#x2F; 2; boolean[] dp &#x3D; new boolean[S+1]; dp[0] &#x3D; true; for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123; &#x2F;&#x2F; 每个物品只用一次 int weight &#x3D; nums[i-1]; for(int j &#x3D; S; j &gt;&#x3D; weight; j--)&#123; &#x2F;&#x2F; 从后往前，先计算dp[j]，再计算dp[j-1] dp[j] &#x3D; dp[j] || dp[j-weight]; &#x2F;&#x2F; ***** &#125; &#125; return dp[S];&#125; 494. 目标和 将数组按符号分为两个集和：带正号集和S1，带符号集和S2，可以得出：$$sum(S1) - sum(S2) = target\\sum(S1) + sum(S2) ,=, sum$$可以得出：$$2*sum(S1) = target + sum$$ 问题也可以转化为0-1背包问题：容量为(target+sum)/2，物品为数组，求有多少种方式可以将背包放满。 此问题求解的是背包放满有多少种方式，同样没有涉及到物品价值。 1234567891011121314151617181920212223public int findTargetSumWays(int[] nums, int S) &#123; int sum &#x3D; 0; for(int m : nums)&#123; sum +&#x3D; m; &#125; if((sum + S) % 2 &#x3D;&#x3D; 1 || sum &lt; S)&#123; &#x2F;&#x2F; 注意这里，否则会超出内存 return 0; &#125; int T &#x3D; (sum + S) &#x2F; 2; int[] dp &#x3D; new int [T + 1]; dp[0] &#x3D; 1; int n &#x3D; nums.length; for(int weight : nums)&#123; for(int j &#x3D; T; j &gt;&#x3D; weight; j--)&#123; dp[j] +&#x3D; dp[j-weight]; &#125; &#125; return dp[T];&#125; 这道题数组长度不会超过20，同样可以用DFS求解，时间复杂度O(2^n)。 474. 一和零 这道题如果仔细考虑一下，也是个0-1背包问题：背包的容量有两个限制m和n，物品就是字符串数组，每个物品的代价就是字符串中0和1的数量，求背包中最多能放如多少个物品。 12345678910111213141516171819202122232425public int findMaxForm(String[] strs, int m, int n) &#123; int[][] dp &#x3D; new int[m+1][n+1]; &#x2F;&#x2F; 背包有两个限制属性 for(String s : strs)&#123; &#x2F;&#x2F; 每个物品只能放一次 int zero &#x3D; 0, one &#x3D; 0; &#x2F;&#x2F; 物品的两个属性代价 for(char ch : s.toCharArray())&#123; if(ch &#x3D;&#x3D; &#39;0&#39;)&#123; zero++; &#125; else&#123; one++; &#125; &#125; for(int j &#x3D; m; j &gt;&#x3D; zero; j--)&#123; &#x2F;&#x2F; 0 for(int k &#x3D; n; k &gt;&#x3D; one; k--)&#123; &#x2F;&#x2F; 1 dp[j][k] &#x3D; Math.max(dp[j][k], dp[j-zero][k-one] + 1); &#125; &#125; &#125; return dp[m][n];&#125; 0-1背包的特点 N个物品，每个物品两个属性&lt;w, v&gt; 每个物品在背包中可以放0个或1个 求容量不超出下的最大价值 2. 完全背包背包的能容纳的最大重量为W，有N个物品，每个物品的重量为wi，价值为vi。求背包可容纳的物品的最大价值。完全背包问题中，每个物品放入的数量是不受限制的。 dp[i][j]表示前i个物品&lt;wi, vi&gt;放入容量为j背包时的最大代价，根据第i个物品放入到背包的状况，可以得到状态转移方程：$$dp[i][j] = max{dp[i-1][j],, dp[i-1][j-w_i] + v_i,, dp[i-1][j-2w_i]+2v_i,….}$$ 1234567891011121314151617181920212223242526272829303132public int solve(int[] weights, int[] values, int W, int N)&#123; int[][] dp &#x3D; new int[N+1][W+1]; for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123; &#x2F;&#x2F; 放入每个物品 int w &#x3D; weights[i-1], v &#x3D; values[i-1]; &#x2F;&#x2F; 物品的代价和价值 for(int j &#x3D; 1; j &lt;&#x3D; W; j++)&#123; &#x2F;&#x2F; dp[i][j] &#x3D; dp[i-1][j]; &#x2F;&#x2F; 不放入第i个物品 for(int k &#x3D; 1; k*w &lt;&#x3D; j; k++)&#123; &#x2F;&#x2F; 放入1个，2个.... dp[i][j] &#x3D; Math.max(dp[i][j], dp[i-1][j-k*w] + k*v); &#125; &#125; &#125; return dp[N][W];&#125;空间压缩后public int solve(int[] weights, int[] values, int W, int N)&#123; int[] dp &#x3D; new int[W+1]; for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123; &#x2F;&#x2F; 放入每个物品 int w &#x3D; weights[i-1], v &#x3D; values[i-1]; &#x2F;&#x2F; 物品的代价和价值 for(int j &#x3D; W; j &gt;&#x3D; 1; j--)&#123; &#x2F;&#x2F; for(int k &#x3D; 1; k*w &lt;&#x3D; j; k++)&#123; &#x2F;&#x2F; 放入1个，2个.... dp[j] &#x3D; Math.max(dp[j], dp[j-k*w] + k*v); &#125; &#125; &#125; return dp[W];&#125; 另一种比较简洁的思路： 1234567891011121314151617public int solve(int[] weights, int[] values, int W, int N)&#123; int[] dp &#x3D; new int[W+1]; Arrays.fill(dp, -1); dp[0] &#x3D; 0; for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123; &#x2F;&#x2F; 放入每个物品 int w &#x3D; weights[i-1], v &#x3D; values[i-1]; &#x2F;&#x2F; 物品的代价和价值 for(int j &#x3D; w; j &lt;&#x3D; W; j++)&#123; &#x2F;&#x2F; if(dp[j-w] !&#x3D; -1)&#123; dp[j] &#x3D; Math.max(dp[j], dp[j-w] + v); &#125; &#125; &#125; return dp[W];&#125; 322. 零钱兑换 此问题是个完全背包问题：物品是硬币，可以无限次放入，背包容量是amount，求能将背包装满的组合数。 123456789101112131415161718192021public int coinChange(int[] coins, int amount) &#123; int[] dp &#x3D; new int[amount+1]; Arrays.fill(dp, -1); dp[0] &#x3D; 0; for(int m : coins[i])&#123; for(int j &#x3D; m; j &lt;&#x3D; amount; j++)&#123; if(dp[j-m] !&#x3D; -1)&#123; if(dp[j] &#x3D;&#x3D; -1)&#123; dp[j] &#x3D; dp[j-m] + 1; &#125; else&#123; dp[j] &#x3D; Math.min(dp[j], dp[j-m]+1); &#125; &#125; &#125; &#125; return dp[amount]; &#125; 518. 零钱兑换 II 完全背包，求组合数。 1234567891011121314public int change(int amount, int[] coins) &#123; int[] dp &#x3D; new int[amount+1]; dp[0] &#x3D; 1; for(int coin : coins)&#123; for(int i &#x3D; coin; i &lt;&#x3D; amount; i++)&#123; dp[i] +&#x3D; dp[i-coin]; &#125; &#125; return dp[amount];&#125; 139. 单词拆分 这道题比较有意思，物品是单词字典，背包的容量是字符串长度，不过它的放入条件是字符串要相同。而且物品放入有先后顺序。带放入顺序的完全背包问题： 123456789101112131415161718&#x2F;&#x2F; 错误解法public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; int len &#x3D; s.length(); boolean[] dp &#x3D; new boolean[len + 1]; dp[0] &#x3D; true; for(String str : wordDict)&#123; for(int i &#x3D; str.length(); i &lt;&#x3D; len; i++)&#123; if(!dp[i] &amp;&amp; dp[i-str.length()] &amp;&amp; isSame(s, i-1, str))&#123; dp[i] &#x3D; true; &#125; &#125; &#125; return dp[len]; &#125; 12345678910111213141516171819202122232425262728293031&#x2F;&#x2F; 正确解法public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; int len &#x3D; s.length(); boolean[] dp &#x3D; new boolean[len + 1]; dp[0] &#x3D; true; for(int i &#x3D; 1; i &lt;&#x3D; len; i++)&#123; for(String str : wordDict)&#123; int l &#x3D; str.length(); if(!dp[i] &amp;&amp; i &gt;&#x3D; l &amp;&amp; isSame(s, i-1, str))&#123; dp[i] |&#x3D; dp[i-l]; &#125; &#125; &#125; return dp[len]; &#125; public boolean isSame(String str, int end, String s)&#123; int i &#x3D; end, j &#x3D; s.length()-1; while(i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0)&#123; if(str.charAt(i) !&#x3D; s.charAt(j))&#123; break; &#125; i--; j--; &#125; return j &#x3D;&#x3D; -1; &#125; 377. 组合总和 Ⅳ 求组合数，不同的序列被视为不同的组合，则需要考虑物品放入背包时的顺序： 1234567891011121314public int combinationSum4(int[] nums, int target) &#123; if (nums &#x3D;&#x3D; null || nums.length &#x3D;&#x3D; 0) &#123; return 0; &#125; int[] maximum &#x3D; new int[target + 1]; maximum[0] &#x3D; 1; Arrays.sort(nums); for (int i &#x3D; 1; i &lt;&#x3D; target; i++) &#123; for (int j &#x3D; 0; j &lt; nums.length &amp;&amp; nums[j] &lt;&#x3D; i; j++) &#123; maximum[i] +&#x3D; maximum[i - nums[j]]; &#125; &#125; return maximum[target];&#125; 无视组合数字的中的先后顺序的话： 123456789101112131415public int combinationSum4(int[] nums, int target) &#123; int[] dp &#x3D; new int[target+1]; dp[0] &#x3D; 1; for(int m : nums)&#123; for(int j &#x3D; m; j &lt;&#x3D; target; j++)&#123; dp[j] +&#x3D; dp[j-m]; &#125; &#125; return dp[target];&#125; 完全背包的特点 N个物品，每个物品两个属性&lt;w, v&gt; 每个物品在背包中可以放0个或无限多个 求容量不超出下的最大价值 3. 多重背包多重背包的特点 N个物品，每个物品两个属性&lt;w, v&gt; 每个物品都有一定的数量Ni，在背包中可以放入0-Ni 求容量不超出下的最大价值 4.多维费用背包474. 一和零 属于0-1背包中的多维费用背包，答案见0-1背包。 多维费用背包的特点 N个物品，每个物品有多个限制属性如容量、体积，以及价值 放入看具体要求 求重量和体积都不超出下的最大价值","tags":[{"name":"背包","slug":"背包","permalink":"http://yoursite.com/tags/%E8%83%8C%E5%8C%85/"}]},{"title":"Redis缓存雪崩、穿透、击穿","date":"2020-08-13T13:22:53.000Z","path":"2020/08/13/Redis缓存雪崩、穿透、击穿/","text":"1.缓存雪崩了解吗​ Redis中数据同一时刻大面积失效，那一瞬间Redis和没有一样，此时如果存在大量请求，会直接打到MySql数据库上，MySql数据库会瘫痪，无法提供服务，整个系统就崩掉了。 如何应对呢？ ​ 处理缓存雪崩很简单，在批量往Redis存数据的时候，把每个key的失效时间加个随机值就好了，保证数据在同一时刻不会大面积失效，数据库负担过重。 1setRedis（Key，value，time + Math.random() * 10000）; ​ 如果Redis时集群部署，可以将热点数据均匀分散到各个Redis库中，避免全部失效。 ​ 也可以设置热点数据永不过期，更新时覆盖即可。 2.缓存穿透、击穿​ 缓存穿透是指缓存和数据库中都没有的数据，而用户在不断的发送请求。此时的用户很有可能是攻击者，会导致数据库压力过大。（先查缓存，没有就去数据库查） 如何解决呢？ 增加校验，拦截不合理的请求。 从缓存和数据库都取不到的数据，可以在缓存中添加key对应valu为null的一条数据，有效时间可以设置短点 ​ 缓存击穿和缓存雪崩类似，但有点不同。缓存击穿指的是有一个key非常热点，在不停的扛着大并发，在该key失效的一瞬间，会有大量请求击穿缓存打到数据库，导致数据库负担过重。 如何解决呢？ 设置热点数据永不过期 加上互斥锁","tags":[]},{"title":"数据库基础概念","date":"2020-08-13T13:22:53.000Z","path":"2020/08/13/数据库基础概念/","text":"一、事务事务指的是满足ACID的一组操作，它可以通过Commit提交一个事务，也可以使用Rollback进行回滚。 原子性（Atomicity） 事务被视为不可分割的最小单元，事务的所有操作要么全部完成后提交，要么全部失败回滚。 回滚可以通过回滚日志（Undo log）实现，里面记录着事务所执行的所有修改操作，回滚时反向执行即可。 一致性（Consistency） 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果是相同的。 隔离性（Isolation） 一个事务所作的更改在提交前对其他事务是不可见的。 持久性（Durability） 一旦事务提交，其所作的更改就会永远保持到数据库中。即使数据库发生崩溃，事务的执行的结果也不能丢失。 系统发生崩溃时，可以通过重做日志（Redo Log）进行修复，从而实现持久性。与回滚日志不同记录的数据的逻辑修改不同，重做日志记录的是数据页的物理更改。 事务的ACID特性概念简单，但不好理解，主要是这几个特性不是一种平级关系： 一致性是基本保证的，只有满足一致性，事务的执行结果才是正确的 在无并发情形下，事务串行执行，隔离性一定满足。此时只要满足原子性就能满足一致性 在并发情形下，多个事务并发执行，事务不仅要满足原子性，还要满足隔离性，才能满足一致性 事务满足持久性，是为了应对系统崩溃情况 二、并发一致性问题并发条件下，事务的隔离性很难保证，因为会出现很多并发一致性问题。 丢失修改 T1，T2两个事务都对一个数据进行修改，T1先修改，T2后修改，此时T2的修改会覆盖T1的修改。 读脏数据 T1修改一个数据，T2随后读取了该数据。如果T1撤销了这次修改（发生了回滚），那么T2读到的数据是脏数据。 不可重复读 T2读取了一个数据，随后T1修改了该数据。如果T2再次读该数据，此时读取的数据与第一次不一致。 幻读 T1读取了某个范围内的数据，随后T2在这个范围内插入了一条数据。T1再次查询这个范围内的数据的话，此时读取的结果与第一次不同。 三、数据库中的锁机制 锁的粒度 MySQL中提供了两种锁的粒度：行级锁和表级锁。 降低锁的粒度，可以减少锁的竞争，提升系统的并发程度。 但是加锁需要消耗资源，锁的各种实现都会增加系统负担。锁粒度越小，系统开销越大。 因此需要平衡锁开销和并发度。 锁的类型 独占锁（Exclusive），简写为 X 锁，又称写锁。 共享锁（Shared），简写为 S 锁，又称读锁。 有以下两个规定： ​ 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 ​ 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。 补充（不太懂） 使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。 在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。 意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定： ​ 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁； ​ 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。 通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。 封锁协议 一级封锁协议：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。 可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。 二级封锁协议：在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。 可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。 三级封锁协议：在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。 可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。 两端锁协议：加锁和解锁分为两个阶段进行。 可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。 事务遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件。 四、事务的隔离级别 读未提交（READ UNCOMMITTED） 一个事务可以读取到另一个事务没有提交的数据。无法避免任何一种情况。 读提交（READ COMMITTED） 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。可以解决脏读。 可重复读（REPEATABLE READ） 保证在同一个事务中多次读取同一数据的结果是一样的。可以解决不可重复读。 序列化（SERIALIZABLE） 强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。 该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。 五、多版本并发控制六、关系数据库设计理论数据库三大范式： 属性不可分：每一列属性都是不可再分的属性值，确保每一列的原子性，两列属性相近或一样，尽量合并属性一样的列，确保不产生冗余数据。 每一行的数据只能与其中一列相关，一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。 数据不能存在传递关系，每个属性都与主键有直接关系而不是间接关系。 七、常见问题 数据库索引用过哪些，什么情况失效？ 主键索引（聚簇索引）、普通索引、唯一索引、全文索引 where 语句中使用or，但是没有把or中的所有字段都加上索引，索引失效。 where 语句使用&lt;&gt;和!= like查询以“%…”开头 如果mysql估计全表扫描更快的话 LIMIT M, N LIMIT 给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目（初始记录行的偏移量是 0而不是 1)。 LIMIT M 等价于LIMIT 0, M drop和delete的区别 delete 删除的是 数据，drop语句删除表结构及所有数据，并将表所占用的空间全部释放 delete会触发触发器，drop不会触发触发器； 数据库事务的应用场景 在执行一系列数据库操作时，要保证这些操作必须完全正确执行，否则就不执行，在这种情况下，适合使用事务，例如将一些数据插入到两个相关联的表中，而且不能只有一张表插入成功，这种情况下，使用事务，无论是否插入成功，都不会对数据库造成不好的影响。 数据库索引的创建原则 表的主键、外键必须有索引; 经常查询的数据列最好建立索引 对于需要在指定范围内的快速或频繁查询的数据列; 经常用在WHERE子句中的数据列。 经常出现在关键字order by、group by、distinct后面的字段，建立索引。如果建立的是复合索引，索引的字段顺序要和这些关键字后面的字段顺序一致，否则索引不会被使用。","tags":[]},{"title":"Redis基础","date":"2020-08-13T13:22:53.000Z","path":"2020/08/13/Redis基础/","text":"1.Redis有那些数据结构​ 字符串、字典Hash、列表List、集和Set、有序集和SortedSet。 ​ ….加分项 ​ BitMap、Geo、HyperLogLog、 应用场景补充 ​ 字符串：常规的key-value缓存应用。常用计数器：微博数，粉丝数 ​ hash: 存储部分变更数据，如用户信息等。 ​ list: 可以构建消息队列 ​ set: 交集、并集、差集，去重，找共同的爱好…… ​ sortedset: 通过score对元素进行优先排序，带权重的消息队列 2.大量key同一时间过期​ 如果大量的key在同一时间过期，那么到过期的时间点Redis会发生卡顿现象，严重的话会造成缓存雪崩，解决方法是在设置失效时间时加上一个随机值。 3.Redis分布式锁​ 分布式锁是为了解决多进程之间的同步，redis可以实现分布式锁。可以用setnx原子操作来获得锁（），抢到之后用expire给锁添加过期时间。 12setnx k vexpire k timeout 追问：如果setnx获取锁成功，但线程执行expire之前崩溃，会如何，怎样解决？ ​ 此时，这个锁将一直被持有，无法释放。可以用同时具有setnx和expire的原子指令***解决： 1set k v nx[key必须不存在] [ex t 秒级]&#x2F;[px t 毫秒级] 4.如何在Redis中查询大量的具有固定前缀的key​ 可以利用keys指令查询，但该指令会一次性查找全部符合条件的key，会造成卡顿（Redis是单线程的）： 1keys [pattern] ​ 因为keys指令需要全部遍历，数据量很大的话，需要一定的执行时间。由于Redis是单线程，所以其他服务会暂停，直到keys指令结束。为避免此情况发生，可以使用scan指令，scan指令可以无阻塞的取出指定模式的key列表（每次执行会找到若干个符合条件的key），但会出现重复，所以客户端需要去重： 1scan cursor[0代表从头开始] [MATCH pattern] [COUNT num] ​ 由于scan不是一次性遍历（增量式迭代），所以在全部扫描完成时可能有些key会发生变化。 5.Redis异步队列​ Redis可以实现异步队列，一般用List实现，rpush生产消息，lpop消费消息。当lpop没有消息可消费时，需要sleep一会儿重试。 ​ 除了sleep还可以使用blpop指令，在没有消息时，他会阻塞住直到消息到来。 一次生产，多次消费如何实现？ ​ 可以使用pub/sub主题订阅模式，可以实现1：N的消息队列 pub/sub有何问题 ​ 在消费者下线情况下，生产的消息会丢失，可以使用RabbitMQ。 如何实现延时队列 ​ 可以使用有序集和sortedset，将时间作为score，消息内容作为key，调用zadd来生产消息，消费者通过zrangebyscore指令获取N秒前的消息. 6.Redis持久化​ Redis持久化有两种方式：RDB镜像全量持久化、AOF增量持久化。 RDB: ​ Redis每隔一段时间可以将所有数据备份到磁盘，Redis会fork一个子线程进行RDB操作，子线程创建后，父子线程共享数据段，父线程将继续提供服务，写脏的页面数据会和子线程分开（cow, copy on write)。cow数据未发生变化时，父子线程共享数据，一旦发生变化，子线程才会分配空间存储数据。 ​ 自动触发：配置文件中，可以配置经过多少次save就触发； ​ 手动触发：通过bgsave命令，会fork一个子进程。 AOF： ​ 将Redis执行的指令记录到磁盘，sync属性可以支持每条指令都写到磁盘，但代价较高。可以设置每秒sync，这样最多会丢失1s的数据。 ​ AOF日志会随着时间不断变大，可以通过AOF重写解决。首先读取数据库中所有键值的状态，使用一条命令替代前面多条操作语句。使用bgrewriteaof命令进行重写，重写时会fork一个子进程进行重写，主进程将重写期间的命令放到重写缓冲区中，待重写完成将其添加到AOF文件中。 ​ RDB无法实时持久化，AOF文件较大（AOF重写解决）。 7.Pipline是什么​ 普通的请求中，每次请求都对应一次IO操作等待（往返时延），而Pipline会将所有请求转化为一次IO操作（一次往返）。使用前提是指令之间没有因果相关性。 8.Redis的同步机制​ Redis同步机制有两种：主从同步 主从同步： 从服务器向主服务器发送sync命令 主服务器收到sync命令，开始执行bgsave命令生成RDB文件，并用缓存开始记录此后执行的所有写命令 主服务器bgsave完成之后，向从服务器发送RDB文件，继续在缓存中记录写命令 从服务器收到RDB文件，丢弃所有旧数据，载入RDB 主服务器向从服务器发送缓存中的命令 从服务器载入RDB后开始接收命令请求，执行来自主服务器中的缓存命令 通过以上操作，全量同步完成，以后主服务器向从服务器发送所有的写操作进行增量同步。 9.Redis集群​ Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master,继续提供服务。 ​ Redis Cluster着眼于扩展性，在单个Redis内存不足时，使用Cluster进行分片存储。 10.Redis为什么快 数据放在内存中，而且其存储数据类似HashMap，所以速度很快 单线程，没有线程上下文切换开销 多路IO复用，可以一个线程监听多路IO 研究表明，redis的瓶颈在网络时延 11.Redis与memcached区别 memcached只支持字符串，redis支持更丰富的数据类型 redis支持数据持久化 redis支持数据备份，即master-slave 12.redis数据过期回收 定期回收 没过一段时间去抽查一部分数据是否过期，过期就删除。 惰性删除 使用key时，先判断是否过期，过期则删除。","tags":[]},{"title":"MySql数据库面试问题","date":"2020-08-13T13:22:53.000Z","path":"2020/08/13/MySQL数据库/","text":"1.说一说MySQL中的索引​ MySQL数据库的索引是用B+树实现的。在B+树中非叶节点只存储关键字和指针（可以存储更多的关键字，降低树高），叶子节点存储关键字和数据。相邻的叶子节点间有指针连接，范围查找更为快速。通过B+树索引进行查找的时间复杂度为树高，一般是2~4次。（数据结构） ​ MySQL数据库中的索引有两种：聚集索引、稀疏索引。其中聚集索引的叶子节点会存储实际表中真实的数据，一个表只能有一个聚集索引，而稀疏索引的叶子节点存储的是主键的值。也就是说，通过稀疏索引进行查找，首先会查询稀疏索引树，找到符合条件的聚集索引的关键字，然后用该关键字在聚集索引树中进行查找，找到最终的数据。 ​ MySQL数据库中InnoDB引擎主索引是聚集索引，叶子的value存储真实数据，辅助索引是稀疏索引，叶子节点value存储主键的值；而Myisam引擎主索引和辅助索引都是稀疏索引，两者没有任何区别（value都存储数据的地址）。 2.为什么MySQL索引使用B+树，不是B树​ B+树是B树的变种，B+树中非叶节点只用来保存索引（关键字和指针），不储存数据，所有的数据存储在叶子节点上；而B树中的非叶节点会保存数据，这样使得B+树的查询效率更加稳定，均是从根节点到叶子节点。 ​ B+树非叶节点不存储数据，所以可以存储更多的关键字，使得B+树查找的磁盘IO数更少。 ​ B+树相邻的叶子节点间有指针连接，范围查询更为有利。 3.为什么推荐采用自增主键​ InnoDB推荐使用自增列作为主键，这样可以提高存取速度。因为如果InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的。 4.MySQL常见的存储引擎有哪些​ MySQL中常见的存储引擎有InnoDB和MyISAM，主要区别是： MyISAM不支持事务；InnoDB是事务类型的存储引擎。 MyISAM只支持表级锁；InnoDB支持行级锁和表级锁，默认为行级锁。 MyISAM引擎不支持外键；InnoDB支持外键。 MyISAM支持全文索引（FULLTEXT）；InnoDB不支持。 MyISAM索引都是是稀疏索引，叶子节点存储真实数据的指针，数据和索引分离；InnoDB采用聚集索引，真实数据在聚集的叶子节点上，辅助索引是稀疏索引，叶子节点存储主键值。 5.MySQL中where、group by、having关键字 where子句用来筛选from子句中指定的操作所产生的的行 group by 子句用来分组where子句的输出 having子句用来从分组的结果中筛选组 where和having的区别：where 是group by之前进行筛选，筛选的是行，having是group by 之后进行统计的筛选，筛选的是组。 执行顺序：执行where子句查找符合条件的数据 &gt; 使用group by 子句对数据进行分组 &gt;对group by 子句形成的组运行聚集函数计算每一组的值&gt;最后用having 子句去掉不符合条件的组 6.索引的最左前缀原则​ 在联合索引的情况下，不需要索引的全部定义，只要满足最左前缀，就可以利用索引来加快查询速度。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。最左前缀原则的利用也可以显著提高查询效率，是常见的MySQL性能优化手段。 ​ 如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下： 123select * from user where name&#x3D;xx and city&#x3D;xx ; ／／可以命中索引select * from user where name&#x3D;xx ; &#x2F;&#x2F; 可以命中索引select * from user where city&#x3D;xx ; &#x2F;&#x2F; 无法命中索引 这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 `city= xx and name ＝xx`，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。 7.那些列上适合建立索引，对性能有何开销​ 主键、外键必须有索引。 ​ 经常需要作为（where）条件查询的列上适合创建索引，并且该列上也必须有一定的区分度。创建索引需要维护，在插入数据的时候会重新维护各个索引树（数据页的分裂与合并），对性能造成影响。 8.“行级锁什么时候会锁住整个表？“​ InnoDB行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。 9.MySQL中建表的约束 主键约束：唯一性，非空性 唯一约束：唯一性，可以空，但只能有一个 检查约束：对该列数据的范围、格式的限制 默认约束：该数据的默认值 外键约束：需要建立两表间的关系并引用主表的列 10.SQL语句的优化有哪些？ 为经常使用的字段（排序、搜索）建立索引 字段的种类尽可能用int 或者tinyint类型。另外字段尽可能用NOT NULL。 select * 尽量少用，你想要什么字段 就select 什么字段出来 不要老是用* 号！同理，只要一行数据时尽量使用 LIMIT 1 11.order by是怎么工作的？​ ORDER BY 语句用于对结果集进行排序。以下面的语句进行分析： 1select city,name,age from t where city=&#x27;杭州&#x27; order by name limit 1000 ; city字段建立了索引，过程如下： 初始化 sort_buffer, 确认放入 name, city, age 这三个字段。 从索引 city 找到第一个满足 city=’杭州’条件的主键 id。 回表取到 name, city, age 三个字段值，存入 sort_buffer 中。 从索引 city 取下一个主键 id 记录。 重复 3-4 步骤，直到 city 不满足条件。 对 sort_buffer 中的数据按照字段 name 做快速排序。 排序结果取前 1000 行返回给客户端。","tags":[]},{"title":"Java内存模型","date":"2020-08-13T13:17:53.000Z","path":"2020/08/13/Java内存模型/","text":"一、JMM中的主内存和工作内存​ Java内存模型（即Java Memory Model，简称JMM）本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括字段、静态字段、和构成数组对象元素）的访问方式。 ​ 所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在告诉缓存或者寄存器中，保存了该线程使用的变量从主内存副本拷贝。 ​ 线程只能直接操作工作内存中的变量，不同线程之间的变量传递需要通过主内存来完成。 JMM中的主内存： 存储Java实例对象 包括成员变量、类信息、常量、静态变量 属于数据共享的区域，多线程并发操作会引发线程安全问题 JMM中的工作内存： 存储当前方法的所有本地变量信息，本地变量对其他线程不可见 字节码行号指示器、Native方法等 属于线程私有区域，不存在线程安全问题 JMM和Java内存区域划分是不同的概念层次 JMM描述的是一组规则，围绕原子性、有序性、可见性展开 相似点：存在共享区域和私有区域 主内存与工作内存的数据存储类型以及操作方式归纳 方法里的基本数据类型本地变量将直接存储在工作内存的栈帧结构中 引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中 成员变量、static变量、类信息存储在主内存中 主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新到主内存 二、内存模型的三大特性 原子性 Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。 可见性 可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。 ​ 主要有三种实现可见性的方式： volatile synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。 final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。 对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。 有序性 有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。 也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。 三、happen-before原则-","tags":[]},{"title":"Java并发基础","date":"2020-08-13T10:17:53.000Z","path":"2020/08/13/Java并发基础/","text":"一、关于并发的相关概念1. 多线程、并发、并行、 并发：多个线程在同一时间段内同时执行。 并行：多个线程在同一时刻同时时执行。 ​ 通常一个处理器（或一个核）同一时刻只能处理一个线程，而线程在某些时候可能不需要cpu，在此时可以让cpu去执行其他地任务。为了充分地利用计算机资源，可以创建多个线程，在线程不需要cpu时，转而去执行其他的线程。 ​ 然而多线程会带来额外的开销：上下文切换、线程调度 2. 什么是上下文切换​ 当cpu从一个线程切换为另一个线程时，在切换前需要保存上一个线程的状态，切换后需要恢复下一个线程的状态。所以任务（线程）从保存到加载的过程就是一次上下文切换。 如何减少上下文切换 无锁并发编程：多线程竞争锁，会引起上下文切换（挂起） CAS算法：避免加锁 使用最少线程： 协程：单线程实现多任务的调度 3. 死锁产生死锁的条件 资源互斥：一个资源最多只能由一个线程获得 请求保持：线程在请求其他资源时，不放弃已获得资源 不可剥夺：一个线程获得的资源无法被其他线程剥夺 环路等待： 资源的请求构成了请求环路 如何避免死锁 避免一个线程同时获取多个锁 使用定时锁 3. 多线程一定快吗​ 在一些情形下，多线程并不一定比单线程快： 任务量比较小，单线程在很短的时间内就能完成 资源限制，如网速、硬盘读写速度、数据库连接池 二、Java并发机制的底层原理1. volatile​ 被volatile声明的变量，在修改时会发生两件事： 当前处理器缓存行的数据写回到系统内存 将其他CPU里缓存了该内存地址的数据置为无效 2. Synchronized​ Java中所有的对象都可以作为锁(通过对象头标记)，具体表现如下： Synchronized作用于普通方法：锁是当前对象 Synchronized作用于静态方法：锁是当前类的Class对象 Synchronized作用于方法快：锁是括号中的对象 Java引入了偏向锁和轻量级锁，来减少获得锁和释放锁带来的性能损耗。锁一共有四章状态：无锁、偏向锁、轻量级锁、重量级锁。这几个状态，会随着竞争情况逐渐升级，锁可以升级但不能降级。 偏向锁 ​ 很多情况下，一个锁是总是由一个线程多次获得。获得偏向锁的线程再次获得该锁，可以直接获得，无需加锁和解锁。 轻量级锁 ​ 在获得锁时，自旋一定时间多次获得。 ​ 竞争的线程不会被阻塞，适用于同步块可以在很快。 重量级锁 3. 原子操作​ Java实现原子操作可以通过锁和循环CAS的方式实现。 CAS带来的问题 ABA问题 循环带来额外开销： 只能保证一个变量的原子性：","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"},{"name":"volatile","slug":"volatile","permalink":"http://yoursite.com/tags/volatile/"},{"name":"synchronized","slug":"synchronized","permalink":"http://yoursite.com/tags/synchronized/"}]},{"title":"java中的Object类","date":"2020-08-12T13:12:47.000Z","path":"2020/08/12/java中的Object类/","text":"Java是纯面向对象的语言，换言之，在Java中一切都是对象。而Object类是Java中所有类的基类，也就是说所有类都直接或间接继承自Object。 ​ 在继承体系中，父类是基础，子类是对父类的扩充和丰富，所以理解Object类对理解其他类至关重要。理解Object类，关键在于其实现的方法。 1.getClass()1public final native Class&lt;?&gt; getClass(); ​ 返回对象的Class对象，可以看出是个native方法。 2.hashCode()1public native int hashCode(); ​ 返回对象的hashcode值，也是个native方法， 3.equals()123public boolean equals(Object obj) &#123; return (this &#x3D;&#x3D; obj);&#125; ​ 判断对象是否相同，注意这里判断的是引用。 4.clone()1protected native Object clone() throws CloneNotSupportedException; ​ 返回该对象的克隆。 5.toString()123public String toString() &#123; return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());&#125; ​ 返回对象的字符串表示。 6.wait()1234567891011121314151617181920public final native void wait(long timeout) throws InterruptedException;public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException(&quot;timeout value is negative&quot;); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( &quot;nanosecond timeout value out of range&quot;); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout);&#125;public final void wait() throws InterruptedException &#123; wait(0);&#125; ​ 与synchronized配合使用，释放锁使线程等待。 7.notify() notifyAll()12public final native void notify();public final native void notifyAll(); ​ 唤醒等待的线程。 8.finalize()1protected void finalize() throws Throwable &#123; &#125; ​ 当对象没有有效引用时被垃圾回收器调用，但不保证一定会被调用。 对象回收过程中的finalize()： 通过可达性分析找到可以回收的对象 将对象加入到一个较低优先级的线程（垃圾回收器线程），线程会依次调用对象的finalize()方法 该线程执行了对象的finalize方法，若对象在该方法中实现了自救，对象不在回收 对象的finalize方法还未来得及执行（线程的优先级较低），对象被回收","tags":[]},{"title":"Java系列之注解","date":"2020-08-12T11:52:58.000Z","path":"2020/08/12/Java注解/","text":"一、什么是注解Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中。注解是ava5开始引入的新特征。 二、常见的Java注解 Overridejava.lang.Override 是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重写了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java 编译器将以一个编译错误来警示。 DeprecatedDeprecated 也是一种标记类型注解。当一个类型或者类型成员使用@Deprecated 修饰的话，编译器将不鼓励使用这个被标注的程序元素。所以使用这种修饰具有一定的“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为@Deprecated，但编译器仍然要报警。 SuppressWarningsSuppressWarning 不是一个标记类型注解。它有一个类型为String[] 的成员，这个成员的值为被禁止的警告名。 三、注解的语法 注解定义注解通过@Interface关键字进行定义:12public @interface TestAnnocation &#123;&#125; 注解使用注解可以应用到类、方法、成员变量上：123@TestAnnocationpublic class Test &#123;&#125; 四、元注解元注解是作用于注解的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。元注解有：@Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。 1.@Retention 定义该注解的生命周期 ● RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。 ● RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式 ● RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。 2.@Documented是个标记性注解，表示是否将注解信息添加在java 文档中 3.@Target表示该注解用于什么地方，默认值为任何元素 ● ElementType.CONSTRUCTOR: 用于描述构造器 ● ElementType.FIELD: 成员变量、对象、属性（包括enum实例） ● ElementType.LOCAL_VARIABLE: 用于描述局部变量 ● ElementType.METHOD: 用于描述方法 ● ElementType.PACKAGE: 用于描述包 ● ElementType.PARAMETER: 用于描述参数 ● ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明 4.@Inherited是个标记性注解，定义该注解和子类的关系@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类。 5.@Repeatable 五、注解的属性注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。 1234567@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface TestAnnocation &#123; int id(); String msg();&#125; 在使用的时候，我们应该给它们进行赋值。赋值的方式是在注解的括号内以 value=”” 形式，多个属性之前用 ，隔开。 123@TestAnnocation(id = 1, msg = &quot;hello&quot;)public class Test &#123;&#125; 使用default关键字可以为属性指定默认值。 1234567@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface TestAnnocation &#123; int id() default 1; String msg() default &quot;hello&quot;;&#125; 六、自定义注解自定义注解类编写的一些规则: Annotation 型定义为@interface, 所有的Annotation 会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口. 参数成员只能用public 或默认(default) 这两个访问权修饰 参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组. 要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法 注解也可以没有定义成员,，不过这样注解就没啥用了PS:自定义注解需要使用到元注解 七、注解原理注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。","tags":[]},{"title":"贝壳2021提前批笔试8.11","date":"2020-08-10T16:00:00.000Z","path":"2020/08/11/贝壳笔试8.11/","text":"1.回文字符串​ 给定一个字符串str，每次可以对其中的一个字符进行修改，统计将其变为回文字符串至少要修改几次。 ​ 非常简单，前后两指针进行比较，统计不同的字符数即可。 2.颜色填充题目：​ m*n的矩阵，对其中的每个格子进行填充，有以下规则： ​ 1.每个格子必须填充 ​ 2.相邻格子颜色不同 ​ 3.每种颜色的格子数相同 ​ 求，至少需要多少中颜色。 思路： 其实两种颜色就能实现填充m*n格子，且相邻格子的颜色不同 为了使所有颜色的格子数相同，我们要找m*n的最小因子 3.数组中最大子数组的最小长度给定一个数组nums, 找出其所有具有最大值的子数组的最短长度。其中，数组的值定义如下： 1数组[a1, a2, a3]的值 &#x3D; a1 | a2 | a3 数据范围： 12nums.length() &lt;&#x3D; 10^6数组内容全为正整数 分析： 根据数据范围，算法复杂度必须小于O(n^2) 数组的最大值，就是所有元素或的结果 需要map进行记录，前面的状态（记录最近的，让第j位变成1的位置i） 题型类似Leetcode325：这类题都是找最大、最小的子数组，只不过条件不同。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public int getMinLength(int[] nums)&#123; int n = nums.length; int max = 0; // 所有子数组中的最大值 for(int m : nums)&#123; max |= m; &#125; int res = n; // 原数组肯定具有最大值 Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); // 记录第j位最近出现的位置i for(int i = 0; i &lt; n; i++)&#123; int m = nums[i]; // 最大值为max，将其与m的每一位进行比较，若m对应该位的值不同(肯定为0)， // 就通过map找到最近的可以使该位为1的数的下标 // 则以m为结尾的具有最大值的最小数组为，找出的所有下标的最小值 int curLen = 1; // 以m为结尾数组初始长度 int j; for(j = 0; j &lt; 32; j++)&#123; // 遍历每一位 if(((max&gt;&gt;j)&amp;1) != ((m&gt;&gt;j)&amp;1))&#123; // 第j位不同 if(map.containsKey(j))&#123; // 前面具有可以使该位为1的数 curLen = Math.max(curLen, i - map.get(j) + 1); // 更新长度 &#125; else&#123; // 前面没有，跳出循环，以m为结尾无法组成最大值数组 break; &#125; &#125; &#125; if(j == 32)&#123; // 更新比较，符合条件子数组的长度 res = Math.min(res, curLen); &#125; // 记录最近每一位成为1的位置 for(j = 0; j &lt; 32; j++)&#123; if(((m&gt;&gt;j)&amp;1) != 0)&#123; map.put(j, i); &#125; &#125; &#125; return res;&#125; 非常可惜，当时没有做出来。 4.图的最大生成树n个城市，m条道路，每条道路具有一定的客流量。现在要去掉几条道路，使得城市之间是可达的，且剩余道路的总客流量最大。若无法可达，则输出-1，否则输出总客流量对10^9+7取余 1a b c d 代表城市a和b之间的客流量为：$$C_c^d$$ 1n&lt;&#x3D;10^3 分析： dfs方法，会遍历所有的边，指数级增长，肯定会超时 这道题本质是求图的最大生成树 图的相关算法需要总结，太陌生了 使用普利姆算法，贪心的求最大生成树，只能通过40%:","tags":[{"name":"笔试","slug":"笔试","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"贝壳","slug":"贝壳","permalink":"http://yoursite.com/tags/%E8%B4%9D%E5%A3%B3/"}]}]