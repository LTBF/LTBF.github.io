<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Like Wind</title>
  
  <subtitle>不积跬步，无以至千里；不积小流，无以成江海</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-20T10:34:50.426Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>NTJD</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java虚拟机整理</title>
    <link href="http://yoursite.com/2020/10/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM/"/>
    <id>http://yoursite.com/2020/10/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM/</id>
    <published>2020-10-19T16:00:00.000Z</published>
    <updated>2020-10-20T10:34:50.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、JVM内存区域划分"><a href="#一、JVM内存区域划分" class="headerlink" title="一、JVM内存区域划分"></a>一、JVM内存区域划分</h2><p>根据Java虚拟机规范，JVM内存结构如下：</p><img src="/2020/10/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM/JVM.jpg" height="300" width="520"><h3 id="1-方法区"><a href="#1-方法区" class="headerlink" title="1. 方法区"></a>1. 方法区</h3><p>属于内存共享区域，存储被虚拟机加载的类信息，常量，静态变量，即时编译后的代码等数据。</p><h3 id="2-堆"><a href="#2-堆" class="headerlink" title="2. 堆"></a>2. 堆</h3><p>这是JVM管理的内存最大的部分，线程共享，主要存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区（线程工作区）。会抛出OutOfMemoryError。</p><h3 id="3-虚拟机栈"><a href="#3-虚拟机栈" class="headerlink" title="3. 虚拟机栈"></a>3. 虚拟机栈</h3><p>线程私有，生命和线程一致。描述的Java方法执行的内存模型：每个方法调用时，都会创建一个栈帧，用于存储局部变量表，操作数栈、动态链接、方法出口等信息。每个方法从调用到结束，对应着一个栈帧的入栈和出栈。</p><h3 id="4-本地方法栈"><a href="#4-本地方法栈" class="headerlink" title="4. 本地方法栈"></a>4. 本地方法栈</h3><p>区别于Java虚拟机栈，Java虚拟机栈为虚拟机执行Java方法服务；本地方法栈则为虚拟机使用到的Native方法服务。</p><h3 id="5-程序计数器"><a href="#5-程序计数器" class="headerlink" title="5. 程序计数器"></a>5. 程序计数器</h3><p>线程私有，指向下一条需要执行的字节码指令。</p><h3 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h3><p>属于方法区的一部分，用于存放编译器生成的各种字面量和符号引用。intern()方法可以将常量放入池中。</p><h2 id="二、垃圾回收"><a href="#二、垃圾回收" class="headerlink" title="二、垃圾回收"></a>二、垃圾回收</h2><h3 id="1-如何判断对象是垃圾"><a href="#1-如何判断对象是垃圾" class="headerlink" title="1. 如何判断对象是垃圾"></a>1. 如何判断对象是垃圾</h3><p>在进行内存回收之前，首先的事情是要判断那些对象是可以回收的，那些是不可以回收的。</p><h4 id="1-引用计数算法"><a href="#1-引用计数算法" class="headerlink" title="(1) 引用计数算法"></a><strong>(1) 引用计数算法</strong></h4><p>​    <strong>方法</strong>：通过判断对象的引用数量来决定对象是否可回收。</p><p>​    <strong>具体实现</strong>：每一个对象都有一个引用计数器，被引用则+1，引用失效后-1。如果一个对象的引用为0，那么代表该对象可以被回收。</p><p>​    <strong>优点</strong>：执行效率高</p><p>​    <strong>缺点</strong>：无法解决循环引用的问题，导致内存泄漏</p><h4 id="2-可达性分析方法"><a href="#2-可达性分析方法" class="headerlink" title="(2) 可达性分析方法"></a><strong>(2) 可达性分析方法</strong></h4><p>​    <strong>方法</strong>：通过判断对象的引用链是否可达来决定对象是否可以被回收。</p><p>​    <strong>具体实现</strong>：通过一系列的GC Root对象作为起点，从这些节点出发所走过的路径称为引用链，如果一个对象没有在引用链中，说明该对象可以被回收。</p><h4 id="3-可以作为GC-Root的对象"><a href="#3-可以作为GC-Root的对象" class="headerlink" title="(3) 可以作为GC Root的对象"></a><strong>(3) 可以作为GC Root的对象</strong></h4><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的的对象</li><li>方法区中的常量引用对象</li><li>方法区静态属性引用对象</li><li>本地方法栈JNI（Native方法）中引用的对象</li></ul><h4 id="4-Java中的引用类型"><a href="#4-Java中的引用类型" class="headerlink" title="(4) Java中的引用类型"></a><strong>(4) Java中的引用类型</strong></h4><ul><li><strong>强引用</strong>：任何时候都不会被回收，最常见的引用</li><li>**软引用(Soft Reference)**：只有当内存不足时才被回收</li><li>**弱引用(Weak Reference)**：只要发生垃圾回收（无论内存是否足够），弱引用指向的对象就被回收</li><li><strong>虚引用</strong>：任何时候都可能被垃圾收集器回收 </li></ul><h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h3><h4 id="1-标记-清理算法"><a href="#1-标记-清理算法" class="headerlink" title="(1) 标记-清理算法"></a><strong>(1) 标记-清理算法</strong></h4><p>​        <strong>标记</strong>：通过可达性分析，对存活的对象进行标记</p><p>​        <strong>清理</strong>：对堆内存进行线性遍历，回收不可达对象的内存</p><p>​        <strong>问题</strong>：出现内存碎片，效率不高</p><h4 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="(2) 复制算法"></a>(2) 复制算法</h4><p>​        <strong>方法</strong>：将内存空间分为两块S1, S2，每次只使用其中的一块 S1，当S1内存不足时，就将该块空间中存货的对象复制到另一块S2。然后令S2作为当前的工作空间，S1进行全面清理。</p><p>​        <strong>问题</strong>：总有一半的空间闲置，空间利用率低下。</p><p>​        <strong>优点</strong>：不会产生空间碎片，直接复制，简单高效，适用于对象存活率低的场景（新生代）</p><p>​        <strong>改进</strong>：由于大多数对象都是朝生熄灭，没有必要按1：1划分空间，可以分为一块较大的Eden区和两个较小的Survivor ，每次使用Eden和其中的一块Survivor。回收时，将存活的对象复制到闲置的Survivor区，然后清理Eden和Survivor空间。</p><h4 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="(3) 标记-整理算法"></a>(3) 标记-整理算法</h4><p>​        <strong>标记</strong>：通过可达性分析，对存活的对象进行标记</p><p>​        <strong>整理</strong>：将所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p><p>​        <strong>优点</strong>：不会产生空间碎片，不用浪费空间，适用于对象存活率高的场景（老年代）</p><p>​        <strong>问题</strong>：效率比较低</p><h4 id="4-分代回收算法"><a href="#4-分代回收算法" class="headerlink" title="(4) 分代回收算法"></a>(4) 分代回收算法</h4><p>​        根据对象的生命周期不同划分区域，各区域采用不同的垃圾回收算法，以提高JVM回收效率。JDK8及其以后版本将堆内存分为新生代和老年代：</p><p>​        <strong>新生代</strong>：对象的生命周期短（1/3堆空间），大部分是朝生熄灭，采用复制算法回收。分为一块较大的Eden区和两个较小的Survivor区(一个from区，一个to区)（1：1：8），每次使用Eden和其中的一块Survivor（成为from区）。回收时，将存活的对象复制到闲置的Survivor区（即to区），然后清理Eden和Survivor空间（from区）。这里注意，对象总是首先在Eden区创建，如果Eden区不足，会在Survivor区创建。</p><p>​        <strong>老年带</strong>：对象的生命周期长（2/3堆空间），采用标记-清除算法或标记-整理算法回收。</p><p>​        <strong>对象如和晋升到老年代</strong>：经历一定Minor-GC次数依然存活的对象，Survivor区放不下的对象，新生成的较大对象。</p><h4 id="（5）Gc的分类"><a href="#（5）Gc的分类" class="headerlink" title="（5）Gc的分类"></a><strong>（5）Gc的分类</strong></h4><p>​        <strong>Minor-GC</strong>:只回收新生代</p><p>​        <strong>Full-GC</strong>:新生代和老年带都回收（整个堆空间）</p><h4 id="（6）触发Full-GC的条件"><a href="#（6）触发Full-GC的条件" class="headerlink" title="（6）触发Full-GC的条件"></a><strong>（6）触发Full-GC的条件</strong></h4><ul><li><p>老年代空间不足</p></li><li><p>永久代空间不足（JDK7之前，永久代在堆上，JDK8以后，使用元空间替代了永久代，放到了内存中，降低Full-GC的频率）</p></li><li><p>CMS GC时出现promotion failed, concurrent mode failure</p></li><li><p>Minor-GC晋升到老年代的平均大小大于老年代的剩余空间</p></li></ul><h4 id="（7）stop-the-world"><a href="#（7）stop-the-world" class="headerlink" title="（7）stop-the-world"></a><strong>（7）stop-the-world</strong></h4><p>​        JVM由于执行垃圾回收而终止了应用程序的运行，在所有垃圾回收算法中都会发生，多数GC算法通过减少stop-the-world发生的时间来提高程序性能。</p><h3 id="3-垃圾回收器"><a href="#3-垃圾回收器" class="headerlink" title="3.垃圾回收器"></a>3.垃圾回收器</h3><img src="/2020/10/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM/常见垃圾收集器.jpg" height="320" width="520"><h4 id="1-Serial收集器（-XX-UseSerialGC，复制算法）"><a href="#1-Serial收集器（-XX-UseSerialGC，复制算法）" class="headerlink" title="(1) Serial收集器（-XX:+UseSerialGC，复制算法）"></a><strong>(1) Serial收集器（-XX:+UseSerialGC，复制算法）</strong></h4><ul><li><p>单线程收集，进行垃圾收集时，需要暂停所有工作线程（stop-the-world)</p></li><li><p>简单高效，Client模式下默认的年轻代收集器。</p></li></ul><img src="/2020/10/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM/Serial收集器.jpg" height="160" width="520"><h4 id="2-ParNew收集器-XX-UseParNewGC，复制算法"><a href="#2-ParNew收集器-XX-UseParNewGC，复制算法" class="headerlink" title="(2) ParNew收集器(-XX:+UseParNewGC，复制算法)"></a><strong>(2) ParNew收集器(-XX:+UseParNewGC，复制算法)</strong></h4><ul><li><p>多线程进行垃圾回收，其余与Serial收集器一样。</p></li><li><p>单核效率不如Serial，在多核下执行才有优势</p></li></ul><img src="/2020/10/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM/ParNew收集器.jpg" height="160" width="520"><h4 id="3-Parallel-Scavenge收集器-XX-UseParallelGC，复制算法"><a href="#3-Parallel-Scavenge收集器-XX-UseParallelGC，复制算法" class="headerlink" title="(3) Parallel Scavenge收集器(-XX:+UseParallelGC，复制算法)"></a><strong>(3) Parallel Scavenge收集器(-XX:+UseParallelGC，复制算法)</strong></h4><ul><li><p>比起更关注用户线程的停顿时间，更关注系统的吞吐量</p></li><li><p>多核下才有优势，Server模式下的默认新生代垃圾收集器</p></li></ul><img src="/2020/10/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM/Parallel.jpg" height="160" width="520"><h4 id="4-Serial-Old收集器（-XX-UseSerialOldGC，标记-整理）"><a href="#4-Serial-Old收集器（-XX-UseSerialOldGC，标记-整理）" class="headerlink" title="(4) Serial Old收集器（-XX:+UseSerialOldGC，标记-整理）"></a><strong>(4) Serial Old收集器（-XX:+UseSerialOldGC，标记-整理）</strong></h4><ul><li><p>单线程收集，进行垃圾收集时，必须暂停其他工作线程。</p></li><li><p>简单高效，Client模式下默认的老年代收集器。</p></li><li><p>示意图见Serial老年代部分</p></li></ul><h4 id="5-Parallel-Old收集器-XX-UseParallelOldGC，标记-整理"><a href="#5-Parallel-Old收集器-XX-UseParallelOldGC，标记-整理" class="headerlink" title="(5)Parallel Old收集器(-XX:+UseParallelOldGC，标记-整理)"></a><strong>(5)Parallel Old收集器(-XX:+UseParallelOldGC，标记-整理)</strong></h4><ul><li><p>吞吐量优先收集器，多线程，</p></li><li><p>示意图见Parallel</p></li></ul><h4 id="6-CMS收集器-XX-UseConcMarkSweepGC，标记-清理-–重点"><a href="#6-CMS收集器-XX-UseConcMarkSweepGC，标记-清理-–重点" class="headerlink" title="(6) CMS收集器(-XX:+UseConcMarkSweepGC，标记-清理)–重点"></a><strong>(6) CMS收集器(-XX:+UseConcMarkSweepGC，标记-清理)–重点</strong></h4><ul><li><p>初始标记：标记GC Roots能直接关联到的对象，<strong>需要stop-the-world</strong></p></li><li><p>并发标记：并发地进行GC Roots Tracing，不会暂停应用程序</p></li><li><p>重新标记：修正并发标记中变动地部分，<strong>需要stop-the-world</strong></p></li><li><p>并发清理：清理垃圾对象，不会暂停</p></li></ul><img src="/2020/10/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM/CMS.jpg" height="160" width="520"><p><strong>(7) G1收集器(-XX:+UseG1GC，复制+标记-整理)–重点</strong></p><ul><li><p>优点：并行并发、分代收集、空间整合、可预测地停顿</p></li><li><p>将整个Java堆内存划分为多个大小相等地Region</p></li><li><p>年轻代和老年代不再物理隔离</p></li></ul><img src="/2020/10/20/Java%E8%99%9A%E6%8B%9F%E6%9C%BAJVM/G1收集器.jpg" height="160" width="520"><h2 id="三、JVM调优"><a href="#三、JVM调优" class="headerlink" title="三、JVM调优"></a>三、JVM调优</h2><p>常用调优参数：</p><ul><li>-XX:SurvivorRatio：Eden和Survivor的比值，默认8：1</li><li>-XX:NewRatio：老年代和新生代内存大小比值</li><li>-XX:MaxTenuingThresold：对象从新生代晋升到老年代经过的GC次数最大阈值</li></ul><h2 id="四、相关面试题"><a href="#四、相关面试题" class="headerlink" title="四、相关面试题"></a>四、相关面试题</h2><h3 id="1-Object的finalize-方法是否和C-中地析构函数相同"><a href="#1-Object的finalize-方法是否和C-中地析构函数相同" class="headerlink" title="1. Object的finalize()方法是否和C++中地析构函数相同"></a>1. Object的finalize()方法是否和C++中地析构函数相同</h3><p>不同，C++中的析构函数的调用是确定的，而finalize方法不一定会执行。</p><p>在java中，一个对象被回收要经历两次标记。如果对象通过GC Roots进行可达性分析后发现没有与引用链相连，就会被第一次标记，并且判断是否执行finalize方法，如果对象覆盖了finalize方法，且未被引用过，这个对象就会被放到F-Queue队列。虚拟机会有一个低优先级的线程区执行队列中对象的finalize方法。但是线程的优先级很低，并不保证finalize方法一定会执行。</p><p>finalize事实上是给与了对象一次最后重生的机会。</p><h3 id="2-java中的强引用、软引用、弱引用、虚引用"><a href="#2-java中的强引用、软引用、弱引用、虚引用" class="headerlink" title="2. java中的强引用、软引用、弱引用、虚引用"></a>2. java中的强引用、软引用、弱引用、虚引用</h3><ul><li><strong>强引用:</strong> 被强引用指向的对象，一直不会被回收</li><li><strong>软引用：</strong>被强引用指向的对象，当虚拟机内存不足时，才会被回收</li><li><strong>弱引用：</strong>被弱引用指向的对象，只要发生垃圾回收，就会被回收</li><li><strong>虚引用：</strong>和不存在一样，随时可能被回收</li></ul><h3 id="3-对象的创建过程"><a href="#3-对象的创建过程" class="headerlink" title="3. 对象的创建过程"></a>3. <strong>对象的创建过程</strong></h3><p>类加载阶段：</p><p>​    <strong>加载：</strong>加载class文件</p><p>​    <strong>验证：</strong>验证calss文件的正确性</p><p>​    <strong>准备：</strong>为类变量分配内存并设置类变量初始值</p><p>​    <strong>解析：</strong>将符号引用转为直接引用</p><p>​    <strong>初始化：</strong>执行类中定义的Java程序代码，静态代码块</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、JVM内存区域划分&quot;&gt;&lt;a href=&quot;#一、JVM内存区域划分&quot; class=&quot;headerlink&quot; title=&quot;一、JVM内存区域划分&quot;&gt;&lt;/a&gt;一、JVM内存区域划分&lt;/h2&gt;&lt;p&gt;根据Java虚拟机规范，JVM内存结构如下：&lt;/p&gt;
&lt;img sr</summary>
      
    
    
    
    <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
    <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode刷题笔记</title>
    <link href="http://yoursite.com/2020/10/10/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/10/10/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2020-10-09T16:00:00.000Z</published>
    <updated>2020-10-23T08:52:48.941Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode刷题笔记，记录一些非常值得记录的算法题…..    <a id="more"></a></p><h2 id="寻找输入流的中位数"><a href="#寻找输入流的中位数" class="headerlink" title="寻找输入流的中位数"></a>寻找输入流的中位数</h2><blockquote><p><a href="https://leetcode.com/problems/find-median-from-data-stream/">LeetCode 295. Find Median from Data Stream</a><br>剑指Offer</p></blockquote><p>使用两个堆：一个大顶堆，一个小顶堆。其中，大顶堆用于存放输入流中较小的一半数，小顶堆存放输入流中较大的一半数。约定，大顶堆中的数最多比小顶堆中的数多一个。那么，输入流中的中位数要么是大顶堆的头部元素（输入流中数字个数为奇），要么是两个堆顶元素和的平均值（输入流中数字个数为偶）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; prioritySmall;</span><br><span class="line">    <span class="keyword">private</span> PriorityQueue&lt;Integer&gt; priorityBig;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prioritySmall = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; &#123;<span class="keyword">return</span> b - a;&#125;);</span><br><span class="line">        priorityBig = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; &#123;<span class="keyword">return</span> a - b;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prioritySmall.isEmpty() || prioritySmall.peek() &gt;= num)&#123;</span><br><span class="line">            prioritySmall.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            priorityBig.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prioritySmall.size() &gt; priorityBig.size() + <span class="number">1</span>)&#123;</span><br><span class="line">            priorityBig.offer(prioritySmall.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(priorityBig.size() &gt; prioritySmall.size())&#123;</span><br><span class="line">            prioritySmall.offer(priorityBig.poll());</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(prioritySmall.size() &gt; priorityBig.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> prioritySmall.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (prioritySmall.peek() + priorityBig.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="乱序整数数组中缺失的第一个正整数"><a href="#乱序整数数组中缺失的第一个正整数" class="headerlink" title="乱序整数数组中缺失的第一个正整数"></a>乱序整数数组中缺失的第一个正整数</h2><blockquote><p><a href="https://leetcode.com/problems/first-missing-positive/">LeetCode 41. First Missing Positive</a></p></blockquote><p>将数组中的正整数放到数组中的指定位置上：m放到数组中的第m个位置。之后，遍历数组，找出不符合该规律的位置。需要注意一点，由于数组中的数字可能存在重复，在swap时应该避免相同元素进行交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(index &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] &gt; <span class="number">0</span> &amp;&amp; nums[index] != index+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[index] &lt;= n &amp;&amp; nums[nums[index]-<span class="number">1</span>] != nums[index])&#123;   <span class="comment">// 里面存在重复数字，需要过滤</span></span><br><span class="line">                    swap(nums, index, nums[index]-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res != m)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统计数组中每个元素后面比自己小的元素数"><a href="#统计数组中每个元素后面比自己小的元素数" class="headerlink" title="统计数组中每个元素后面比自己小的元素数"></a>统计数组中每个元素后面比自己小的元素数</h2><blockquote><p><a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/">LeetCode 315. Count of Smaller Numbers After Self</a></p></blockquote><p>普通方法的时间复杂度一般是O(n^2)，使用二叉查找树，可以将时间复杂度降低到O(nlogn)。</p><p>该二叉查找树的每个节点除了value值之外，还需要维护一个变量ct，代表该节点的左子树的节点个数。这样，如果按数组逆序来构建这棵二查找树：</p><ul><li>插入时如果元素比该节点的value大，则说明该节点的左子树上的节点以及该节点都比插入元素小，元素插入右子树</li><li>如果比该节点的value小的话，元素要插入该节点的左子树，该节点的ct需要加1</li><li>插入元素与节点value相等时，可以将其插入到右子树</li></ul><p>这样，一个元素后面有多少个比其小的元素，就是在插入该元素过程中所有小于该元素的的节点ct域的和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">countSmaller</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[i]);</span><br><span class="line">        list.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = i - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> m = insert(root, nums[i]);</span><br><span class="line">            list.add(m);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       Collections.reverse(list);</span><br><span class="line">        </span><br><span class="line">       <span class="keyword">return</span> list; </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(TreeNode root, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(num &lt; root.val)&#123;</span><br><span class="line">            <span class="comment">// 更新ct</span></span><br><span class="line">            root.ct++;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span>)&#123;</span><br><span class="line">                root.left = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> insert(root.left, num);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> res = root.ct;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; root.val)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span>(root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">                root.right = <span class="keyword">new</span> TreeNode(num);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> res + insert(root.right, num);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> ct;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">    </span><br><span class="line">    TreeNode(<span class="keyword">int</span> val)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分式的小数形式表示"><a href="#分式的小数形式表示" class="headerlink" title="分式的小数形式表示"></a>分式的小数形式表示</h2><blockquote><p><a href="https://leetcode.com/problems/fraction-to-recurring-decimal/">LeetCode 166. Fraction to Recurring Decimal</a></p></blockquote><p>这道题的难点在于如何找出小数部分的循环，思路是用一个Map记录和判断，具体看代码实现。这道题还需注意一下几点：</p><ul><li>分式的分子分母可能为正也可能为负</li><li>将负数转为正数时，当心越界（非常容易出现）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">fractionToDecimal</span><span class="params">(<span class="keyword">long</span> numerator, <span class="keyword">long</span> denominator)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 考虑数字正负的情况</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = (numerator &lt; <span class="number">0</span> &amp;&amp; denominator &gt; <span class="number">0</span>) || (numerator &gt; <span class="number">0</span> &amp;&amp; denominator &lt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 修改为long， 避免越界</span></span><br><span class="line">        numerator = Math.abs(numerator);</span><br><span class="line">        denominator = Math.abs(denominator);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Map记录循环</span></span><br><span class="line">        Map&lt;Long, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 结果的整数部分和小数部分</span></span><br><span class="line">        String posStr = <span class="string">&quot;&quot;</span>, negStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        posStr = String.valueOf(numerator / denominator);</span><br><span class="line">        numerator = (numerator % denominator) * <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(numerator == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(numerator))&#123;</span><br><span class="line">                <span class="keyword">int</span> startIndex = map.get(numerator);</span><br><span class="line">                negStr = negStr.substring(<span class="number">0</span>, startIndex) + <span class="string">&quot;(&quot;</span> + negStr.substring(startIndex, i) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(numerator, i);</span><br><span class="line">            negStr += String.valueOf(numerator / denominator);</span><br><span class="line">            numerator = (numerator % denominator) * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 结果添加负号</span></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            posStr = <span class="string">&quot;-&quot;</span> + posStr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(negStr.equals(<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> posStr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> posStr + <span class="string">&quot;.&quot;</span> + negStr;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="去掉最小子数组，使剩余数组之和能整除P"><a href="#去掉最小子数组，使剩余数组之和能整除P" class="headerlink" title="去掉最小子数组，使剩余数组之和能整除P"></a>去掉最小子数组，使剩余数组之和能整除P</h2><blockquote><p><a href="https://leetcode.com/problems/make-sum-divisible-by-p/">Leetcode 1590. Make Sum Divisible by P</a><br>date: 2020.09.22<br>算法指数：☆☆☆☆<br>是否做出：是</p></blockquote><p>思路类似求数组中和为target的最小子数组，只不过在这道题中求的是和%sum= m的最小子数组，其中sum是整个数组的和，m是sum%p。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSubarray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m : nums)&#123;</span><br><span class="line">            target += m;</span><br><span class="line">            target %= p;    <span class="comment">// 遍历中取余，可以避免越界</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;    <span class="comment">// 数组天然整除p，无需减少任何元素</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = nums.length, cur = <span class="number">0</span>;   <span class="comment">// 初始化</span></span><br><span class="line">        map.put(<span class="number">0</span>, -<span class="number">1</span>);   <span class="comment">// important，子数组从第一个元素开始的时候</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            cur += nums[i];</span><br><span class="line">            cur = cur % p;</span><br><span class="line">            <span class="keyword">int</span> need = (cur - target + p) % p;</span><br><span class="line">            res = Math.min(res, i - map.getOrDefault(need, -nums.length));</span><br><span class="line">            map.put(cur, i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res == nums.length ? -<span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断数组中长度为3的递增子序列"><a href="#判断数组中长度为3的递增子序列" class="headerlink" title="判断数组中长度为3的递增子序列"></a>判断数组中长度为3的递增子序列</h2><blockquote><p><a href="https://leetcode.com/problems/increasing-triplet-subsequence/">Leetcode 334. Increasing Triplet Subsequence</a></p><p>date: 2020.10.12</p><p>算法指数：☆☆☆</p><p>是否做出：否</p></blockquote><p>此类问题一般可以通过用简单方法解决。<br>长度为2的递增此序列—&gt;长度为3/的递增子序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> b = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m &lt;= a)&#123;</span><br><span class="line">                a = m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m &lt;= b)&#123;</span><br><span class="line">                b = m;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取随机值Set"><a href="#获取随机值Set" class="headerlink" title="获取随机值Set"></a>获取随机值Set</h2><blockquote><p><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/">LeetCode380. Insert Delete GetRandom O(1)</a></p><p>date: 2020.10.17</p><p>算法指数：☆☆☆</p><p>是否做出：是</p></blockquote><p>通过数组+Map实现随机访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nextInsert;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RandomizedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100005</span>];</span><br><span class="line">        nextInsert = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(val))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        array[nextInsert] = val;</span><br><span class="line">        map.put(val, nextInsert++);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(val))&#123;</span><br><span class="line">            <span class="keyword">int</span> index = map.get(val);</span><br><span class="line">            swap(array, index, --nextInsert);</span><br><span class="line">            map.put(array[index], index);    <span class="comment">// 更新索引</span></span><br><span class="line">            map.remove(val);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index = ((<span class="keyword">int</span>)(Math.random() * <span class="number">10000000</span>)) % nextInsert;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="最大的数字"><a href="#最大的数字" class="headerlink" title="最大的数字"></a>最大的数字</h2><blockquote><p><a href="https://leetcode.com/problems/largest-number/">LeetCode 179. Largest Number</a></p><p>date: 2020.10.17</p><p>算法指数：☆☆☆☆</p><p>是否做出：是</p></blockquote><p>这道题的关键在于字符串比较部分：34和3哪个应该放前面、30和3哪个应该放前面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(strs, (s1, s2) -&gt; &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> compareString(s1, s2);</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line">            </span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s : strs)&#123;</span><br><span class="line">            res += s;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 过滤0前缀</span></span><br><span class="line">        <span class="keyword">int</span> startIndex;</span><br><span class="line">        <span class="keyword">for</span>(startIndex = <span class="number">0</span>; startIndex &lt; res.length()-<span class="number">1</span>; startIndex++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.charAt(startIndex) != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> res.substring(startIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareString</span><span class="params">(String s1, String s2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; s1.length() &amp;&amp; i &lt; s2.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i) &gt; s2.charAt(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i) &lt; s2.charAt(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &lt; s1.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> compareString(s1.substring(i), s2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; s2.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> compareString(s1, s2.substring(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="直方图中的最大面积"><a href="#直方图中的最大面积" class="headerlink" title="直方图中的最大面积"></a>直方图中的最大面积</h2><blockquote><p><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">LeetCode 84. Largest Rectangle in Histogram</a></p><p>date: 2020.10.17</p><p>算法指数：☆☆☆☆☆</p><p>是否做出：否</p></blockquote><p>单调递增栈可以实现记录当前bar在最大区间[i, j]中是最低的。用图来说明递增栈是如何解决这个问题的：</p><p>首先，高度为2的bar&lt;0, 2&gt;进栈(<strong>0代表该bar从位置0到当前位置是最低的，2代表该bar的高度</strong>):</p><img src="/2020/10/10/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/LeetCode84-1.png" width="500" height="320"><p>然后，高度为1的bar想要进栈，但是小于栈顶高度为2的bar，所以栈中的元素要出栈。&lt;0, 2&gt;出栈，该bar最低的最大区间为[0, 0]，area = 2*1。此时栈为空，高度为1的bar继续进栈，此时注意进栈的是&lt;0, 1&gt;，因为前面出栈的bar的高度都比1高。高度为5，6的bar&lt;2, 5&gt;,&lt;3, 6&gt;依次进栈，</p><img src="/2020/10/10/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/LeetCode84-2.png" width="500" height="320"><p>现在该高度为2的bar进栈了，重复前面的操作。首先&lt;3, 6&gt;出栈，该bar对应的区间为[3, 3]，area = 1 * 6;然后&lt;2, 5&gt;出栈，对应的区间为[2, 3]，area = 2 * 5。然后&lt;2, 2&gt;进栈，&lt;5, 3&gt;进栈。</p><img src="/2020/10/10/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/LeetCode84-3.png" width="500" height="320"><p>最终依次出栈：&lt;5, 3&gt;对应区间为[5, 5],area = 1 * 3; &lt;2, 2&gt;对应区间为[2, 5]，area = 4 * 2; &lt;0, 1&gt;对应区间为[0, 5],area = 6 * 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 单调递增栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(heights == <span class="keyword">null</span> || heights.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;<span class="keyword">int</span>[]&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = i;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek()[<span class="number">1</span>] &gt; heights[i])&#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> height = arr[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> width = i - arr[<span class="number">0</span>];</span><br><span class="line">                start = arr[<span class="number">0</span>];</span><br><span class="line">                maxArea = Math.max(maxArea, height * width);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start, heights[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = stack.pop();</span><br><span class="line">            <span class="keyword">int</span> height = arr[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> width = heights.length - arr[<span class="number">0</span>];</span><br><span class="line">            maxArea = Math.max(maxArea, height * width);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><blockquote><p><a href="https://leetcode.com/problems/powx-n/">LeetCode 50. Pow(x, n)</a></p><p>date: 2020.10.19</p><p>算法指数：☆☆☆☆</p><p>是否做出：否</p></blockquote><p>利用二分思想，x<sup>n</sup> = x<sup>n/2</sup> *  x<sup>n/2</sup>  * x<sup>n%2==1 ? 1 : 0</sup></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快速幂</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> isNegative = n &lt; <span class="number">0</span>;</span><br><span class="line">        n = Math.abs(n);    <span class="comment">// 注意int负数越界</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> res = calculate(x, n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> isNegative ? <span class="number">1</span>/res : res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> res = calculate(x, n/<span class="number">2</span>);</span><br><span class="line">        res *= res;</span><br><span class="line">        res *= n % <span class="number">2</span> == <span class="number">1</span> ? x : <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="另一种方法："><a href="#另一种方法：" class="headerlink" title="另一种方法："></a>另一种方法：</h5><p>​                                                    2<sup>11</sup> = 2<sup>8</sup> * 2<sup>2</sup> * 2<sup>1</sup>  = 2<sup>(1000)</sup> *  2<sup>(10)</sup> *2<sup>(1)</sup>     </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = n &lt; <span class="number">0</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">        n = Math.abs(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">double</span> base = x;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n&amp;<span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                res = res * base;</span><br><span class="line">            &#125;</span><br><span class="line">            base = base * base;</span><br><span class="line">            n = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>/res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无序数组中最长的有序序列"><a href="#无序数组中最长的有序序列" class="headerlink" title="无序数组中最长的有序序列"></a>无序数组中最长的有序序列</h2><blockquote><p><a href="https://leetcode.com/problems/longest-consecutive-sequence/">LeetCode 128.Longest Consecutive Sequence</a></p><p>date: 2020.10.19</p><p>难度：hard</p><p>算法指数：☆☆☆☆</p><p>是否做出：否</p></blockquote><p>这道题目的是找最长的有序序列，那么就从所有有序序列的开始元素找起。将元素放到Set中可以快速找到每个有序序类的第一个元素。在找下一个元素时，要小心加1导致的位溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m : nums)&#123;</span><br><span class="line">            set.add(m);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(m-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> curCount = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> curNum = m;</span><br><span class="line">                <span class="keyword">while</span>(set.contains(curNum))&#123;</span><br><span class="line">                    curCount++;</span><br><span class="line">                    <span class="keyword">if</span>(curNum == Integer.MAX_VALUE)&#123;    <span class="comment">// 位溢出</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    curNum++;</span><br><span class="line">                &#125;</span><br><span class="line">                maxLen = Math.max(maxLen, curCount);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵中最长的增长路径"><a href="#矩阵中最长的增长路径" class="headerlink" title="矩阵中最长的增长路径"></a>矩阵中最长的增长路径</h2><blockquote><p><a href="https://leetcode.com/problems/longest-increasing-path-in-a-matrix/">LeetCode 329. Longest Increasing Path in a Matrix</a></p><p>date: 2020.10.23</p><p>难度：hard</p><p>算法指数：☆☆☆☆</p><p>是否做出：是</p></blockquote><p>暴力遍历方法可以轻易解决这个问题，但是会超时，在搜索过程中可以有两个优化的地方：</p><ul><li>使用Map记录已经搜索过的路径</li><li>从最小的数开始搜索</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    Map&lt;String, Integer&gt; map;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        m = matrix.length;</span><br><span class="line">        n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isSmallest(matrix, i, j))&#123;</span><br><span class="line">                    maxLen = Math.max(maxLen, dfs(matrix, i, j, visited));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; matrix[i-<span class="number">1</span>][j] &lt; matrix[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; m-<span class="number">1</span> &amp;&amp; matrix[i+<span class="number">1</span>][j] &lt; matrix[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; matrix[i][j-<span class="number">1</span>] &lt; matrix[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; n-<span class="number">1</span> &amp;&amp; matrix[i][j+<span class="number">1</span>] &lt; matrix[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">boolean</span>[][] visited)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// has result</span></span><br><span class="line">        String key = <span class="string">&quot;(&quot;</span> + x + <span class="string">&quot;,&quot;</span> + y + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : directions)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = x + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> j = y + dir[<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; !visited[i][j] &amp;&amp; matrix[i][j] &gt; matrix[x][y])&#123;</span><br><span class="line">                maxLen = Math.max(maxLen, dfs(matrix, i, j, visited));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        visited[x][y] = <span class="keyword">false</span>;</span><br><span class="line">        map.put(key, <span class="number">1</span>+maxLen);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + maxLen;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用数组代替Map，效率会有不错的提升，visited数组也可以不用使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span>[][] cache;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        m = matrix.length;</span><br><span class="line">        n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isSmallest(matrix, i, j))&#123;</span><br><span class="line">                    maxLen = Math.max(maxLen, dfs(matrix, i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; matrix[i-<span class="number">1</span>][j] &lt; matrix[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; m-<span class="number">1</span> &amp;&amp; matrix[i+<span class="number">1</span>][j] &lt; matrix[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; matrix[i][j-<span class="number">1</span>] &lt; matrix[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; n-<span class="number">1</span> &amp;&amp; matrix[i][j+<span class="number">1</span>] &lt; matrix[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// has result</span></span><br><span class="line">        <span class="keyword">if</span>(cache[x][y] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> cache[x][y];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : directions)&#123;</span><br><span class="line">            <span class="keyword">int</span> i = x + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> j = y + dir[<span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; m &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; n &amp;&amp; matrix[i][j] &gt; matrix[x][y])&#123;</span><br><span class="line">                maxLen = Math.max(maxLen, dfs(matrix, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cache[x][y] = maxLen + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + maxLen;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;LeetCode刷题笔记，记录一些非常值得记录的算法题…..&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Leetcode" scheme="http://yoursite.com/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>BIO、NIO以及Netty</title>
    <link href="http://yoursite.com/2020/10/02/BIO%E3%80%81NIO%E4%BB%A5%E5%8F%8ANetty/"/>
    <id>http://yoursite.com/2020/10/02/BIO%E3%80%81NIO%E4%BB%A5%E5%8F%8ANetty/</id>
    <published>2020-10-01T16:00:00.000Z</published>
    <updated>2020-10-19T04:51:25.881Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是BIO"><a href="#什么是BIO" class="headerlink" title="什么是BIO"></a>什么是BIO</h2><p>BIO(Blocked Input Output)是一种<strong>同步阻塞IO</strong>。早期Java网络通信通过Socket(套接字)进行通信，这是一种<strong>阻塞式</strong>的通信。<br>通过BIO实现网络通信，需要一对套接字：</p><ul><li>运行于服务端的ServerSocket</li><li>运行于客户端的Socket</li></ul><p>Socket通信方式如下图所示：</p><img src="/2020/10/02/BIO%E3%80%81NIO%E4%BB%A5%E5%8F%8ANetty/socket-network-communication-process.png" align="center" width="500" height="460"><h3 id="Java使用Socket进行网络通信过程："><a href="#Java使用Socket进行网络通信过程：" class="headerlink" title="Java使用Socket进行网络通信过程："></a>Java使用Socket进行网络通信过程：</h3><p>服务端：<br>1.创建ServerSocket对象，绑定地址(ip)和端口(port):<code>serverSocket.bind(new InetSocketAddress(host,port))</code><br>2.通过<code>accept</code>方法监听客户端请求：<code>accept</code>方法调用后会<strong>阻塞</strong>住，直到客户端请求出现<br>3.连接建立，通过输入输出流进行通信：<code>read</code>方法调用会<strong>阻塞</strong>，直到数据可以读取<br>4.连接关闭，资源释放</p><p>客户端：<br>1.创建<code>Socket</code>对象，设置连接服务器的地址(ip)及端口(port):<code>socket.connect(new InetSocketAddress(host,port))</code><br>2.连接建立，通过输入输出流进行通信：<code>read</code>方法调用会<strong>阻塞</strong>，直到数据可以读取<br>3.连接关闭，释放资源</p><h3 id="Socket网络通信实例："><a href="#Socket网络通信实例：" class="headerlink" title="Socket网络通信实例："></a>Socket网络通信实例：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                Socket socket = serverSocket.accept();    <span class="comment">// 阻塞，直到获取一个连接</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 读取数据</span></span><br><span class="line">                InputStream inputStream = socket.getInputStream();</span><br><span class="line">                DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(inputStream);</span><br><span class="line">                String str = dataInputStream.readUTF();</span><br><span class="line">                System.out.println(<span class="string">&quot;server receive from client:&quot;</span> + str);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 发送数据</span></span><br><span class="line">                OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">                DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(outputStream);</span><br><span class="line">                dataOutputStream.writeUTF(<span class="string">&quot;hello client, I am Server!&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 关闭连接</span></span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Socket socket;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送数据</span></span><br><span class="line">            OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">            DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(outputStream);</span><br><span class="line">            dataOutputStream.writeUTF(<span class="string">&quot;hello server, I am client!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取数据</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            DataInputStream dataInputStream = <span class="keyword">new</span> DataInputStream(inputStream);</span><br><span class="line">            String str = dataInputStream.readUTF();</span><br><span class="line">            System.out.println(<span class="string">&quot;client receive from server:&quot;</span> + str);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关闭连接</span></span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Server端控制台会输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server receive from client:hello server, I am client!</span><br></pre></td></tr></table></figure><p>Client端控制台会输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client receive from server:hello client, I am Server!</span><br></pre></td></tr></table></figure><h3 id="为什么不推荐使用BIO"><a href="#为什么不推荐使用BIO" class="headerlink" title="为什么不推荐使用BIO"></a>为什么不推荐使用BIO</h3><p><strong>资源耗费严重</strong>：一个线程只能处理一个客户端连接，如果要管理多个客户端的话，必须为每个客户端连接创建一个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    Socket socket = serverSocket.accept();</span><br><span class="line">    <span class="keyword">new</span> Thread(() - &gt; &#123;</span><br><span class="line">        <span class="comment">// socket连接处理</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池可以一定程度上缓解此问题，但无法根本改变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    Socket socket = serverSocket.accept();</span><br><span class="line">    threadPool.execute(() -&gt; &#123;</span><br><span class="line">        <span class="comment">// socket连接处理</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论如何优化，它底层还是<strong>同步阻塞</strong>的IO，无法从根本上解决问题。</p><blockquote><p><a href="https://www.zhihu.com/question/19732473">同步和异步（消息通信机制）</a></p><ul><li>同步：发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回</li><li>异步：调用在发出之后，这个调用就直接返回了，所以没有返回结果</li></ul></blockquote><blockquote><p><a href="https://www.zhihu.com/question/19732473">阻塞和非阻塞（等待调用结果时的状态）</a></p><ul><li>阻塞：调用结果返回之前，线程一直挂起</li><li>非阻塞：调用没有返回结果之前，线程不会阻塞</li></ul></blockquote><h2 id="再看NIO"><a href="#再看NIO" class="headerlink" title="再看NIO"></a>再看NIO</h2><p>NIO(Non-blocking IO)是一种<strong>同步非阻塞IO</strong>，在java1.4时引入，对应<code>java.nio</code>包。<br>NIO提供了与传统BIO中的<code>Socket</code>和<code>ServerSocket</code>相对应的<code>SocketChannel</code>和<code>ServerSocketChannel</code>两种不同套接字通道的实现，两种通道都支持阻塞和非阻塞两种模式：</p><ul><li><strong>阻塞模式：</strong>基本不会使用。与传统网络编程一样，简单但性能和可靠性不好。</li><li><strong>非阻塞模式：</strong>对高负荷、高并发应用非常好，但是编程麻烦。这也是Netty出现的重要原因。</li></ul><h3 id="NIO核心组件解读"><a href="#NIO核心组件解读" class="headerlink" title="NIO核心组件解读"></a>NIO核心组件解读</h3><p>NIO包含一下几个核心组件：</p><ul><li><strong>Channel</strong></li><li><strong>Buffer</strong></li><li><strong>Selector</strong></li><li><strong>Selector Key</strong></li></ul><p>它们之间的关系如下：</p><img src="/2020/10/02/BIO%E3%80%81NIO%E4%BB%A5%E5%8F%8ANetty/Java-NIO.png" width="500" height="300"><p>1.NIO通过Channel(通道)和Buffer(缓存区)来传输数据，数据总是从缓冲区写入通道，或从通道读取到缓冲区。在NIO中，所以数据都是通过Buffer处理的，Channel对应于JDK底层的Socket。<br>2.NIO通过Selector(选择器)来监视多个通道对象，如数据到达、连接打开等，单线程可以监视多个通道<br>3.将Channel注册到Selector时，会返回一个Selector Key，可以根据它获取那些IO事件已经就绪，也可以通过它获取对应的Channel进行操作。<br><strong>Selector是NIO实现的关键，它使用了事件通知相关的API来选择已经就绪的通道。</strong><br>简单来说，流程如下：</p><ul><li>将Channel注册到Selector中</li><li>调用Selector的<code>select</code>方法，这个方法会阻塞，直到有就绪的Channel出现</li><li>注册到Selector的就绪态Channel会被轮询出来：新的连接、读就绪、写就绪</li><li>通过Selector Key获取就绪Channel的集和，进行后续的IO操作</li></ul><h4 id="使用NIO进行通信"><a href="#使用NIO进行通信" class="headerlink" title="使用NIO进行通信"></a>使用NIO进行通信</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务端通信通道</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 开启非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 设置端口号</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择器</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 服务端注册选择器, 监听&quot;连接&quot;</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 轮询，选择就绪通道，并返回数量(阻塞)</span></span><br><span class="line">            <span class="keyword">int</span> select = selector.select();</span><br><span class="line">            <span class="comment">// 获取当前选择器中所有注册的key(已就绪的监听事件)</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="comment">// 迭代</span></span><br><span class="line">            <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable()) &#123;   <span class="comment">// 新的请求连接</span></span><br><span class="line">                    createChannel(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;  <span class="comment">// 通道可以好读</span></span><br><span class="line">                    doRead(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(key.isWritable())&#123;   <span class="comment">// 通道可以写</span></span><br><span class="line">                    doWrite(key);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 移除</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        SocketChannel socketChannel = (SocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写数据</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.wrap(<span class="string">&quot;send to Client&quot;</span>.getBytes());</span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通道监听读</span></span><br><span class="line">        key.interestOps(SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        SocketChannel socketChannel = (SocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 当远程SocketChannel断开连接时，Server端会触发一个read事件，此处会发生异常</span></span><br><span class="line">            <span class="keyword">int</span> read = socketChannel.read(byteBuffer);</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            System.out.println(<span class="string">&quot;Server receive:&quot;</span> + <span class="keyword">new</span> String(byteBuffer.array(), <span class="number">0</span>, read));</span><br><span class="line">            <span class="comment">// 通道监听写</span></span><br><span class="line">            key.interestOps(SelectionKey.OP_WRITE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            key.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新连接的建立</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createChannel</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取key的监听通道</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = (ServerSocketChannel)key.channel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接收请求</span></span><br><span class="line">        SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;Accept connection from &quot;</span> + socketChannel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置通道非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送欢迎词</span></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.wrap((<span class="string">&quot;Welcome:&quot;</span> + socketChannel.getRemoteAddress()</span><br><span class="line">                + <span class="string">&quot; assigned to&quot;</span> + Thread.currentThread().getName()).getBytes());</span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//***</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册连接到selector, 绑定监听读数据</span></span><br><span class="line">        socketChannel.register(key.selector(),SelectionKey.OP_READ );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class NIOClient &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        SocketChannel socketChannel &#x3D; SocketChannel.open(new InetSocketAddress(8888));</span><br><span class="line"></span><br><span class="line">        socketChannel.configureBlocking(false);</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024);</span><br><span class="line"></span><br><span class="line">        byteBuffer.put(&quot;Hello I am Client&quot;.getBytes());</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        socketChannel.write(byteBuffer);</span><br><span class="line"></span><br><span class="line">        byteBuffer.clear();</span><br><span class="line">        socketChannel.read(byteBuffer);</span><br><span class="line">        byteBuffer.flip();</span><br><span class="line">        System.out.println(new String(byteBuffer.array()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NIO为什么更好"><a href="#NIO为什么更好" class="headerlink" title="NIO为什么更好"></a>NIO为什么更好</h3><ul><li>使用比较少的线程就可以管理多个客户端连接，提高了并发量且减少了资源消耗</li><li>没有IO操作的时候，线程可以去执行其他任务，非阻塞。</li></ul><h3 id="使用NIO编写代码太难了"><a href="#使用NIO编写代码太难了" class="headerlink" title="使用NIO编写代码太难了"></a>使用NIO编写代码太难了</h3><p>NIO非常难用，而且存在许多bug，开发和维护的成本比较大。一般情况下会使用Netty这个成熟的框架。</p><h2 id="重要角色Netty"><a href="#重要角色Netty" class="headerlink" title="重要角色Netty"></a>重要角色Netty</h2><p>还在学习中…..</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是BIO&quot;&gt;&lt;a href=&quot;#什么是BIO&quot; class=&quot;headerlink&quot; title=&quot;什么是BIO&quot;&gt;&lt;/a&gt;什么是BIO&lt;/h2&gt;&lt;p&gt;BIO(Blocked Input Output)是一种&lt;strong&gt;同步阻塞IO&lt;/strong&gt;。早期</summary>
      
    
    
    
    <category term="java网络编程" scheme="http://yoursite.com/categories/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux常见命令</title>
    <link href="http://yoursite.com/2020/09/29/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/09/29/Linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</id>
    <published>2020-09-28T16:00:00.000Z</published>
    <updated>2020-09-29T14:26:57.248Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-进程线程"><a href="#1-进程线程" class="headerlink" title="1. 进程线程"></a>1. 进程线程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">top   ---实时显示系统中各个进程的资源占用状况</span><br><span class="line">ps    ---查看当前进程</span><br><span class="line">top -H -p pid    ---查看进程下的线程</span><br><span class="line">ps -T -p pid     ---同上</span><br></pre></td></tr></table></figure><h4 id="2-磁盘和内存"><a href="#2-磁盘和内存" class="headerlink" title="2. 磁盘和内存"></a>2. 磁盘和内存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df     ---查看磁盘状态</span><br><span class="line">free   ---查看内存状态</span><br></pre></td></tr></table></figure><h4 id="3-网络"><a href="#3-网络" class="headerlink" title="3. 网络"></a>3. 网络</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat    ---显示各种网络相关信息</span><br><span class="line">ifconfig   ---查看网卡信息</span><br></pre></td></tr></table></figure><h4 id="4-文件-目录"><a href="#4-文件-目录" class="headerlink" title="4. 文件/目录"></a>4. 文件/目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mkdir    ---创建目录</span><br><span class="line">touch    ---创建文件</span><br><span class="line">mv       ---移动文件&#x2F;目录</span><br><span class="line">rm       ---删除文件&#x2F;目录</span><br><span class="line">cp       ---复制文件&#x2F;目录</span><br><span class="line">chmod    ---修改文件&#x2F;目录的权限</span><br><span class="line">more     ---按页显示内容</span><br><span class="line">cat      ---按行显示内容</span><br><span class="line">tac      ---按行倒叙显示内容</span><br><span class="line">less     ---与more类似，可以向前翻页</span><br><span class="line">tail     ---只看结尾几行</span><br><span class="line">head     ---只看开始几行</span><br><span class="line">scp</span><br></pre></td></tr></table></figure><h4 id="5-压缩和解压"><a href="#5-压缩和解压" class="headerlink" title="5. 压缩和解压"></a>5. 压缩和解压</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar       ---压缩和解压</span><br></pre></td></tr></table></figure><h4 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">cd</span><br><span class="line">pwd</span><br><span class="line">grep   ---文本搜索</span><br><span class="line">sed</span><br><span class="line">awk</span><br><span class="line">chgrp</span><br><span class="line">wc    ---统计字节数(-c)、行数(-l)、字数(-w)</span><br><span class="line">history</span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-进程线程&quot;&gt;&lt;a href=&quot;#1-进程线程&quot; class=&quot;headerlink&quot; title=&quot;1. 进程线程&quot;&gt;&lt;/a&gt;1. 进程线程&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g</summary>
      
    
    
    
    <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring和SpringBoot的区别</title>
    <link href="http://yoursite.com/2020/09/24/Spring%E5%92%8CSpringBoot%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2020/09/24/Spring%E5%92%8CSpringBoot%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2020-09-23T16:00:00.000Z</published>
    <updated>2020-10-19T04:55:57.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是Spring"><a href="#1-什么是Spring" class="headerlink" title="1. 什么是Spring"></a>1. 什么是Spring</h2><p><code>Spring</code>框架为开发<code>Java</code>应用程序提供了全面的基础架构支持。它包含一些很好的功能，如依赖注入和开箱即用的模块，如：<code>Spring JDBC 、Spring MVC 、Spring Security、 Spring AOP 、Spring ORM 、Spring Test</code>.</p><p>这些模块缩短应用程序的开发时间，提高了应用开发的效率例如，在<code>Java Web</code>开发的早期阶段，我们需要编写大量的代码来将记录插入到数据库中。但是通过使用<code>Spring JDBC</code>模块的<code>JDBCTemplate</code>，我们可以将操作简化为几行代码。</p><h2 id="2-什么是Spring-Boot"><a href="#2-什么是Spring-Boot" class="headerlink" title="2.什么是Spring Boot"></a>2.什么是Spring Boot</h2><p><code>Spring Boot</code>基本上是<code>Spring</code>框架的扩展，它消除了设置<code>Spring</code>应用程序所需的<code>XML配置</code>，为更快，更高效的开发生态系统铺平了道路。</p><p><strong><code>Spring Boot</code>中的一些特征：</strong></p><ol><li>创建独立的<code>Spring</code>应用。</li><li>嵌入式<code>Tomcat</code>、<code>Jetty</code>、 <code>Undertow</code>容器（无需部署war文件）。</li><li>提供的<code>starters</code> 简化构建配置</li><li>尽可能自动配置<code>spring</code>应用。</li><li>提供生产指标,例如指标、健壮检查和外部化配置</li><li>完全没有代码生成和<code>XML</code>配置要求</li></ol><blockquote><p><a href="https://www.jianshu.com/p/ffe5ebe17c3a">https://www.jianshu.com/p/ffe5ebe17c3a</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么是Spring&quot;&gt;&lt;a href=&quot;#1-什么是Spring&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是Spring&quot;&gt;&lt;/a&gt;1. 什么是Spring&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Spring&lt;/code&gt;框架为开发&lt;code&gt;Ja</summary>
      
    
    
    
    <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring循环依赖</title>
    <link href="http://yoursite.com/2020/09/24/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/"/>
    <id>http://yoursite.com/2020/09/24/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/</id>
    <published>2020-09-23T16:00:00.000Z</published>
    <updated>2020-10-19T04:54:41.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Spring中bean的生命周期"><a href="#1-Spring中bean的生命周期" class="headerlink" title="1. Spring中bean的生命周期"></a>1. Spring中bean的生命周期</h2><ul><li>构造器创建bean对象</li><li>依赖注入</li><li>init方法初始化bean对象</li><li>使用</li><li>销毁</li></ul><h2 id="2-Spring循环依赖是怎么回事"><a href="#2-Spring循环依赖是怎么回事" class="headerlink" title="2. Spring循环依赖是怎么回事"></a>2. Spring循环依赖是怎么回事</h2><p>循环依赖发生在单例对象A的创建过程中（第一步和第二步）需要其他的单例对象B，而这个单例对象B恰好也需要A。循环依赖主要分两种：<strong>构造器循环依赖</strong>和<strong>属性循环依赖</strong>。</p><h2 id="3-如和解决循环依赖"><a href="#3-如和解决循环依赖" class="headerlink" title="3. 如和解决循环依赖"></a>3. 如和解决循环依赖</h2><p>Spring通过三级缓存可以解决属性循环依赖，三级缓存主要如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Object&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;String, ObjectFactory&lt;?&gt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;String, Object&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><ul><li><p><code>singletonObjects</code>: 第一级缓存，存放完整可用的单例对象</p></li><li><p><code>earlySingletonObjects</code>: 第二级缓存，存放提前曝光的单例对象</p></li><li><p><code>singletonFactories</code>: 第三级缓存，存放单例对象的工厂</p></li></ul><p>那么三级缓存如何解决属性循环依赖的呢？看一下单例bean的创建过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从一级缓存中获取单例对象</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// 一级缓存获取失败，且该对象正在创建过程中</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">// 二级缓存中获取单例对象</span></span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="comment">// 二级缓存获取失败，且允许从三级缓存中获取对象</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">// 三级缓存获取单例对象的工厂</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="comment">// 获取成功，获取对象，将对象从三级缓存放到二级缓存</span></span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么三级缓存可以解决循环依赖呢？这是因为在bean生命周期的第一步结束后，会将该对象放入三级缓存。这也是无法解决构造器循环依赖的原因。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">&quot;Singleton factory must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/u010853261/article/details/77940767">https://blog.csdn.net/u010853261/article/details/77940767</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Spring中bean的生命周期&quot;&gt;&lt;a href=&quot;#1-Spring中bean的生命周期&quot; class=&quot;headerlink&quot; title=&quot;1. Spring中bean的生命周期&quot;&gt;&lt;/a&gt;1. Spring中bean的生命周期&lt;/h2&gt;&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
    <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>旋转有序数组上二分查找</title>
    <link href="http://yoursite.com/2020/09/15/%E6%97%8B%E8%BD%AC%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%8A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2020/09/15/%E6%97%8B%E8%BD%AC%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%8A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2020-09-14T16:00:00.000Z</published>
    <updated>2020-10-19T05:19:32.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>在旋转排序数组上应用二分查找，若数组中的元素都不相同，则可以按下图分析：</p><img src="/2020/09/15/%E6%97%8B%E8%BD%AC%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%8A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/1.png" width="520" height="320"><ul><li><p>若a[mid] &gt; a[high], 则代表mid位于旋转数组的左半段；</p></li><li><p>若a[mid] &lt; a[low],则代表mid位于旋转数组的右半段</p></li><li><p>否则，代表区间[low, high]是个递增数组，不存在旋转    </p></li></ul><p>若数组中可能存在重复元素，则需要按下图分析：</p><img src="/2020/09/15/%E6%97%8B%E8%BD%AC%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%8A%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/2.png" width="520" height="320"><ul><li>若a[mid] &lt; a[low], 则代表处于状态①</li><li>若a[mid] &gt; a[high], 则代表处于状态②</li><li>若a[mid] = a[low] = a[high],则代表处于状态③或④</li><li>否则，代表区间[low, high]不存在反转</li></ul><h2 id="1-寻找旋转排序数组中的最小值"><a href="#1-寻找旋转排序数组中的最小值" class="headerlink" title="1. 寻找旋转排序数组中的最小值"></a>1. <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">寻找旋转排序数组中的最小值</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; nums[high])&#123;</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[low])&#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-寻找旋转排序数组中的最小值II"><a href="#2-寻找旋转排序数组中的最小值II" class="headerlink" title="2. 寻找旋转排序数组中的最小值II"></a>2. <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">寻找旋转排序数组中的最小值II</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[low])&#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[high])&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == nums[low] &amp;&amp; nums[mid] == nums[high])&#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums[low];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-搜索旋转排序数组"><a href="#3-搜索旋转排序数组" class="headerlink" title="3. 搜索旋转排序数组"></a>3. <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; nums[high])&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt;= nums[low] &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[low])&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[high])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[mid])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-搜索旋转排序数组II"><a href="#4-搜索旋转排序数组II" class="headerlink" title="4. 搜索旋转排序数组II"></a>4. <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">搜索旋转排序数组II</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; nums[high])&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt;= nums[low] &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[low])&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[high])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]  == nums[low] &amp;&amp; nums[mid] == nums[high])&#123;</span><br><span class="line">            low++;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[mid])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h2&gt;&lt;p&gt;在旋转排序数组上应用二分查找，若数组中的元素都不相同，则可以按下图分析：&lt;/p&gt;
&lt;img src=&quot;/2020/09/15</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>MVCC多版本并发控制</title>
    <link href="http://yoursite.com/2020/09/15/MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2020/09/15/MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</id>
    <published>2020-09-14T16:00:00.000Z</published>
    <updated>2020-10-19T05:22:30.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是MVCC"><a href="#1-什么是MVCC" class="headerlink" title="1. 什么是MVCC"></a>1. 什么是MVCC</h2><p>mvcc中文名位多版本并发控制，是数据库引擎处理读写冲突的一种手段，目的在于提高并发场景下数据库的吞吐量。<br>通过mvcc机制，在多个事务并发执行时，<strong>select可以无需加锁</strong>，而是通过mvcc机制读取指定版本的历史记录，可以保证读取的值符合事务所处的隔离级别。从而解决并发场景下的读写冲突。<br>在mysql数据库中，mvcc可以在<strong>读已提交</strong>和<strong>可重复读</strong>两种隔离级别下使用。</p><h2 id="2-为什么需要MVCC"><a href="#2-为什么需要MVCC" class="headerlink" title="2. 为什么需要MVCC"></a>2. 为什么需要MVCC</h2><p>事务并发会导致一系列问题：丢失更新、脏读、不可重复读、幻读。数据库可以通过隔离级别来应对，实现隔离级别有两种方式：</p><ul><li>加读写锁</li><li>mvcc【针对于select,更新还得加写锁】</li></ul><p>但本质上，隔离级别是一种在并发性能和并发产生的副作用间的妥协。</p><h2 id="3-mvcc的实现原理"><a href="#3-mvcc的实现原理" class="headerlink" title="3. mvcc的实现原理"></a>3. mvcc的实现原理</h2><p>InnoDB引擎是通过每个表的两个隐藏字段实现的：</p><ul><li>DATA_TRX_ID：记录更新这条记录的事务ID</li><li>DATA_ROLL_PTR：指向改行上一次的数据，在undo日志中以链表形式组织</li></ul><p>此外InnoDB还有一个隐藏字段：</p><ul><li>DB_ROW_ID：如果表没有主键，此列会出现作为隐藏主键。</li></ul><p><strong>MVCC的判断流程如下：</strong></p><p>ReadView:是当前活动事务ID的列表[minid, maxid]</p><ul><li>如果被访问数据的DATA_TRX_ID小于minid，说明该版本的数据在ReadView生成前，已经<strong>提交</strong>，可以直接返回</li><li>如果访问数据的DATA_TRX_ID大于maxid, 说明该版本的数据在ReadView生成后才<strong>生成</strong>，需要根据undo寻找上一个版本，继续判断</li><li>如果访问数据的DATA_TRX_ID在minid和maxid之间，<ul><li>若DATA_TRX_ID在ReadView中，说明创建ReadView时，该版本所属事务尚未提交，需要寻找上一个版本</li><li>若DATA_TRX_ID不在ReadView中，说明创建ReadView时，该版本所属事务已经提交，可以直接返回</li></ul></li></ul><p>RC和RR两个隔离级别下一个很大的不同是：<strong>ReadView生成时间点不同，RC下每次select都会生成一个ReadView，事务执行期间会更新；而RR只在第一个select语句时生成一个ReadView，事务执行期间，不会更新。</strong></p><p><strong>参考</strong>：<a href="https://www.codercto.com/a/88775.html">InnoDB MVCC 机制，看这篇就够了</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-什么是MVCC&quot;&gt;&lt;a href=&quot;#1-什么是MVCC&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是MVCC&quot;&gt;&lt;/a&gt;1. 什么是MVCC&lt;/h2&gt;&lt;p&gt;mvcc中文名位多版本并发控制，是数据库引擎处理读写冲突的一种手段，目的在于提高</summary>
      
    
    
    
    <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySql" scheme="http://yoursite.com/tags/MySql/"/>
    
  </entry>
  
  <entry>
    <title>Java实现消费者-生产者模式</title>
    <link href="http://yoursite.com/2020/09/06/Java%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://yoursite.com/2020/09/06/Java%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85/</id>
    <published>2020-09-05T16:00:00.000Z</published>
    <updated>2020-10-19T04:32:38.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-生产者-消费者者模式"><a href="#1-生产者-消费者者模式" class="headerlink" title="1. 生产者-消费者者模式"></a>1. 生产者-消费者者模式</h2><p>生产者-消费者模式是并发场景下非常经典的设计模式。生产者用于生产物品，消费者消费生产者生产的物品。在Java中可以多种实现方式：</p><ul><li>synchronized锁</li><li>ReentrantLock锁</li><li>BlockingQueue阻塞队列</li><li>PipedInputStream/PipedOutputStream管道</li><li>Semaphore信号量</li></ul><h2 id="2-synchronized实现生产者-消费者"><a href="#2-synchronized实现生产者-消费者" class="headerlink" title="2. synchronized实现生产者-消费者"></a>2. synchronized实现生产者-消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> productNum;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ct;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(productNum == capacity)&#123;</span><br><span class="line">            notifyAll();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        productNum++;</span><br><span class="line">        ct++;</span><br><span class="line">        System.out.println(ct+<span class="string">&quot;生产一个商品：&quot;</span> + productNum + <span class="string">&quot; &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(productNum == <span class="number">0</span>) &#123;</span><br><span class="line">            notifyAll();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        productNum--;</span><br><span class="line">        ct++;</span><br><span class="line">        System.out.println(ct + <span class="string">&quot;消费一个商品：&quot;</span> + productNum + <span class="string">&quot; &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        One one = <span class="keyword">new</span> One();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    one.produce();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;P&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    one.consume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;C&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的刚开始唤醒线程用的是notify方法，会出现线程一直阻塞无法推进的问题。原因是notify是随机唤醒一个阻塞的线程，如果在执行的某个时刻，productNum = 0而且生产线程全部是Runnable状态，此时会有一个消费线程处于Blocked状态。结果显然易见，会出现死循环，两个消费线程相互唤醒阻塞。</p><p>synchronized锁编写起来非常简单，但是消费线程和生产线程会处于一个等待队列，他们的等待条件相同，而ReentrantLock可以指定等待条件。</p><h2 id="2-ReentrantLock实现生产者-消费者模式"><a href="#2-ReentrantLock实现生产者-消费者模式" class="headerlink" title="2. ReentrantLock实现生产者-消费者模式"></a>2. ReentrantLock实现生产者-消费者模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> productNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ct;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();    <span class="comment">// 生产者生产</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();   <span class="comment">// 消费者消费</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(productNum == capacity)&#123;</span><br><span class="line">                notEmpty.signal();   <span class="comment">// 唤醒一个消费线程</span></span><br><span class="line">                notFull.await();     <span class="comment">// 挂起当前生产线程</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            productNum++;</span><br><span class="line">            ct++;</span><br><span class="line">            System.out.println(ct+<span class="string">&quot;生产一个商品：&quot;</span> + productNum + <span class="string">&quot; &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">            notEmpty.signal();    <span class="comment">// 唤醒一个消费线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(productNum == <span class="number">0</span>)&#123;</span><br><span class="line">                notFull.signal();    <span class="comment">// 唤醒一个生产线程</span></span><br><span class="line">                notEmpty.await();    <span class="comment">// 挂起当前消费线程</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            productNum--;</span><br><span class="line">            ct++;</span><br><span class="line">            System.out.println(ct+<span class="string">&quot;消费一个商品：&quot;</span> + productNum + <span class="string">&quot; &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">            notFull.signal();    <span class="comment">// 唤醒一个生产线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Two two = <span class="keyword">new</span> Two();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    two.produce();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;P&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    two.consume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;C&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-BlockingQueue实现生产者-消费者模式"><a href="#3-BlockingQueue实现生产者-消费者模式" class="headerlink" title="3. BlockingQueue实现生产者-消费者模式"></a>3. BlockingQueue实现生产者-消费者模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Three</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            blockingQueue.put(<span class="number">1</span>);;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 生产一个物品:&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            blockingQueue.take();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 消费一个物品&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Three three = <span class="keyword">new</span> Three();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    three.produce();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;P&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    three.consume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;C&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞队列：当队列为满时，阻塞当前生产者线程，唤醒消费者线程；当队列为空的时候，阻塞当前消费者线程，唤醒生产者线程。</p><h2 id="4-管道输入输出流PipedInputStream和PipedOutputStream实现生产者-消费者模式"><a href="#4-管道输入输出流PipedInputStream和PipedOutputStream实现生产者-消费者模式" class="headerlink" title="4.管道输入输出流PipedInputStream和PipedOutputStream实现生产者-消费者模式"></a>4.管道输入输出流PipedInputStream和PipedOutputStream实现生产者-消费者模式</h2><p>使用方法：先创建一个管道输入流和管道输出流，然后将输入流和输出流进行连接，用生产者线程往管道输出流中写入数据，消费者在管道输入流中读取数据，这样就可以实现了不同线程间的相互通讯，但是这种方式在生产者和生产者、消费者和消费者之间不能保证同步，也就是说在一个生产者和一个消费者的情况下是可以生产者和消费者之间交替运行的，多个生成者和多个消费者者之间则不行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Four</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PipedInputStream input = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PipedOutputStream output = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Four</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input.connect(output);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> t = (<span class="keyword">int</span>)(Math.random() * <span class="number">255</span>);</span><br><span class="line">            output.write(t);</span><br><span class="line">            output.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;生产一个商品&quot;</span> + t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> t = input.read();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费一个商品&quot;</span> + t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Four four = <span class="keyword">new</span> Four();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">                    four.produce();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">                    four.consume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            four.input.close();</span><br><span class="line">            four.output.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-Semaphore实现生产者-消费者模式"><a href="#5-Semaphore实现生产者-消费者模式" class="headerlink" title="5. Semaphore实现生产者-消费者模式"></a>5. Semaphore实现生产者-消费者模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Five</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> productNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore notFull = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore notEmpty = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notFull.acquire();</span><br><span class="line">            mutex.acquire();</span><br><span class="line">            productNum++;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产一个商品&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            mutex.release();</span><br><span class="line">            notEmpty.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            notEmpty.acquire();</span><br><span class="line">            mutex.acquire();</span><br><span class="line">            productNum--;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费一个商品&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            mutex.release();</span><br><span class="line">            notFull.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Five five = <span class="keyword">new</span> Five();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    five.produce();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;P&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    five.consume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;C&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-生产者-消费者者模式&quot;&gt;&lt;a href=&quot;#1-生产者-消费者者模式&quot; class=&quot;headerlink&quot; title=&quot;1. 生产者-消费者者模式&quot;&gt;&lt;/a&gt;1. 生产者-消费者者模式&lt;/h2&gt;&lt;p&gt;生产者-消费者模式是并发场景下非常经典的设计模式。生产者</summary>
      
    
    
    
    <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>百度后台开发笔试</title>
    <link href="http://yoursite.com/2020/09/03/%E7%99%BE%E5%BA%A6%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%AC%94%E8%AF%95/"/>
    <id>http://yoursite.com/2020/09/03/%E7%99%BE%E5%BA%A6%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%AC%94%E8%AF%95/</id>
    <published>2020-09-02T16:00:00.000Z</published>
    <updated>2020-10-19T05:23:53.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-一个长为n的正整数数组，里面的每个元素不是0就是5。从数组中选出若干数字组成一个数字，要求能整除90。求满足条件的最大的数字，不存在就输出-1。"><a href="#1-一个长为n的正整数数组，里面的每个元素不是0就是5。从数组中选出若干数字组成一个数字，要求能整除90。求满足条件的最大的数字，不存在就输出-1。" class="headerlink" title="1.一个长为n的正整数数组，里面的每个元素不是0就是5。从数组中选出若干数字组成一个数字，要求能整除90。求满足条件的最大的数字，不存在就输出-1。"></a>1.一个长为n的正整数数组，里面的每个元素不是0就是5。从数组中选出若干数字组成一个数字，要求能整除90。求满足条件的最大的数字，不存在就输出-1。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">12</span><br><span class="line">5 5 5 5 5 5 0 0 5 5 5 5</span><br><span class="line">输出：</span><br><span class="line">55555555500</span><br></pre></td></tr></table></figure><ul><li><p>数字能整除90—&gt;能整除10，结果还能整除9</p></li><li><p>一个数字能整除9—&gt;每位之和能整除90</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">        <span class="keyword">int</span> fiveNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> zeroNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(scan.nextInt() == <span class="number">5</span>)&#123;</span><br><span class="line">                fiveNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                zeroNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个0都不存在时</span></span><br><span class="line">        <span class="keyword">if</span>(zeroNum == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5可以最多出现几次</span></span><br><span class="line">        <span class="keyword">while</span>(fiveNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((fiveNum * <span class="number">5</span>) % <span class="number">9</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fiveNum--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5一次都没有</span></span><br><span class="line">        <span class="keyword">if</span>(fiveNum == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以有fiveNum个5，zeroNum个0，毫无疑问5在前0在后</span></span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(fiveNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            s += <span class="string">&quot;5&quot;</span>;</span><br><span class="line">            fiveNum--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(zeroNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            s += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            zeroNum--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-有n头奶牛，每头奶牛进行m项测评，所有测评都通过的是优质奶牛。"><a href="#2-有n头奶牛，每头奶牛进行m项测评，所有测评都通过的是优质奶牛。" class="headerlink" title="2.有n头奶牛，每头奶牛进行m项测评，所有测评都通过的是优质奶牛。"></a>2.有n头奶牛，每头奶牛进行m项测评，所有测评都通过的是优质奶牛。</h2><p>注意区间的重合问题。但是不知道什么原因一直超时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T = scan.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(T-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = scan.nextInt(), m = scan.nextInt();   <span class="comment">// 奶牛数，资质数</span></span><br><span class="line">            <span class="keyword">int</span>[] ct = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;   <span class="comment">// 每种资质下有k个区间满足</span></span><br><span class="line">                Arrays.fill(visited, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">int</span> k = scan.nextInt();   <span class="comment">// 区间数</span></span><br><span class="line">                <span class="keyword">while</span>(k-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> l = scan.nextInt(), r = scan.nextInt();  <span class="comment">// 区间开始结束</span></span><br><span class="line">                    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(visited[l])&#123;   <span class="comment">// 去重</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ct[l]++;</span><br><span class="line">                        visited[l] = <span class="keyword">true</span>;</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ct[i] == m)&#123;</span><br><span class="line">                    list.add(i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">            <span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">                System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-有n阶台阶，每次可以跨1-m步，要求每次跨的步数与前两次都不同。求登顶的次数"><a href="#3-有n阶台阶，每次可以跨1-m步，要求每次跨的步数与前两次都不同。求登顶的次数" class="headerlink" title="3.有n阶台阶，每次可以跨1-m步，要求每次跨的步数与前两次都不同。求登顶的次数"></a>3.<a href="https://blog.csdn.net/qq_35590091/article/details/108403940">有n阶台阶，每次可以跨1-m步，要求每次跨的步数与前两次都不同。求登顶的次数</a></h2><p>还有一种解法dp[i][j][k]表示到达k前两步分别为j,k的方案数，用动态规划解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Three &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; scan.nextInt(), m &#x3D; scan.nextInt();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int ct &#x3D; backtracking(0, -1, -1, n, m, map);</span><br><span class="line"></span><br><span class="line">        System.out.println(ct);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int backtracking(int lastLast, int last, int cur, int n, int m, Map&lt;String, Integer&gt; map) &#123;</span><br><span class="line"></span><br><span class="line">        if(cur &#x3D;&#x3D; n)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur &gt; n)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str &#x3D; lastLast + &quot;-&quot; + last + &quot;_&quot; + cur;</span><br><span class="line">        if(map.containsKey(str))&#123;</span><br><span class="line">            return map.get(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ct &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; m; i++)&#123;</span><br><span class="line">            ct +&#x3D; backtracking(last, i, cur+i, n, m, map);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ct %&#x3D;1000000007;</span><br><span class="line"></span><br><span class="line">        map.put(str, ct);</span><br><span class="line">        return ct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-一个长为n的正整数数组，里面的每个元素不是0就是5。从数组中选出若干数字组成一个数字，要求能整除90。求满足条件的最大的数字，不存在就输出-1。&quot;&gt;&lt;a href=&quot;#1-一个长为n的正整数数组，里面的每个元素不是0就是5。从数组中选出若干数字组成一个数字，要</summary>
      
    
    
    
    <category term="笔试" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AF%95/"/>
    
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="百度" scheme="http://yoursite.com/tags/%E7%99%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Redis系列之缓存不一致</title>
    <link href="http://yoursite.com/2020/08/30/Redis%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
    <id>http://yoursite.com/2020/08/30/Redis%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4/</id>
    <published>2020-08-29T16:00:00.000Z</published>
    <updated>2020-08-30T13:39:41.269Z</updated>
    
    <content type="html"><![CDATA[<p>缓存不一致指的是缓存中的数据与数据库中的数据发生了不一致的情况。一般常用的缓存方案有两种：</p><p><strong>方案一：</strong></p><ul><li>读的时候，先读缓存，缓存没有的话，读数据库，取出数据后放入缓存，同时返回响应。</li><li>更新的时候，先删除缓存，再更新数据库</li></ul><p><strong>方案二：</strong></p><ul><li>读的时候，先读缓存，缓存没有的话，读数据库，取出数据后放入缓存，同时返回响应。</li><li>更新的时候，先更新数据库，再删除缓存</li></ul><p><strong>两种方案数据库缓存不一致发生的场景：</strong></p><ul><li>方案一：T1删除缓存-&gt;T2读缓存(没有)，读数据库，并放入缓存-&gt;T1更新数据库</li><li>方案二：T1读缓存(没有)，读数据库-&gt;T2更新数据库，删除缓存-&gt;T1放入缓存</li></ul><p><strong>解决方案：</strong></p><p>一般来说，我们对缓存的一致性要求并没有很高，只要求最终一致性，在较短的时间内不一致都是能忍受的。不论是前面哪一种方案，就算发生了，再来一次更新请求只要不发生同样的情况，缓存都会被再次刷成一致的。所以解决方案从简易到复杂就有缓存过期时间兜底，保证“更新数据库、删除缓存”和“读数据库并设置缓存”的之间串行化。</p><ul><li><p>缓存过期时间兜底</p><p>就算更新操作非常少，没有更新操作，也有一个缓存过期时间，在缓存过期之后再次刷新缓存。</p></li><li><p>读若未命中，将读并放入缓存操作放入该线程的队列；更新操作也放入该线程的队列</p></li><li><p>更新操作执行后，向MQ发消息置缓存失效。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;缓存不一致指的是缓存中的数据与数据库中的数据发生了不一致的情况。一般常用的缓存方案有两种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案一：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读的时候，先读缓存，缓存没有的话，读数据库，取出数据后放入缓存，同时返回响应。&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>美团8.29后端笔试</title>
    <link href="http://yoursite.com/2020/08/30/%E7%BE%8E%E5%9B%A28.29%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AF%95/"/>
    <id>http://yoursite.com/2020/08/30/%E7%BE%8E%E5%9B%A28.29%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AF%95/</id>
    <published>2020-08-29T16:00:00.000Z</published>
    <updated>2020-10-19T05:26:13.752Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-小团的神秘暗号"><a href="#1-小团的神秘暗号" class="headerlink" title="1. 小团的神秘暗号"></a>1. 小团的神秘暗号</h3><p>一字符串为其加上一个头部和尾部进行加密。头部至少包含一个“MT”的子序列，且以T结尾。尾部至少包含一个“MT”的子序列，且以M开始。求得取出头部、尾部后的最大字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">10</span></span><br><span class="line">MMATSATMMT</span><br><span class="line">输出：</span><br><span class="line">SATM</span><br></pre></td></tr></table></figure><p>送分题，找出最靠前的头部和最靠后的尾部，剩下的就是最长的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n = Integer.valueOf(scan.nextLine());</span><br><span class="line">    String str = scan.nextLine();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag1 = <span class="keyword">false</span>, flag2 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">            flag1 = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;T&#x27;</span> &amp;&amp; flag1)&#123;</span><br><span class="line">            start = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            flag2 = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;M&#x27;</span> &amp;&amp; flag2)&#123;</span><br><span class="line">            end = i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(str.substring(start, end+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-小团的选调计划"><a href="#2-小团的选调计划" class="headerlink" title="2. 小团的选调计划"></a>2. 小团的选调计划</h3><p>有n个人编号1-n，有n个任务，编号1-n。每个人可以填写选择任务的志愿，编号小的优先被满足。求出每个人最终分配的任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">1 5 3 4 2</span><br><span class="line">2 3 5 4 1</span><br><span class="line">5 4 1 2 3</span><br><span class="line">1 2 5 4 3</span><br><span class="line">1 4 5 2 3</span><br><span class="line">输出：</span><br><span class="line">1 2 5 4 3</span><br></pre></td></tr></table></figure><p>送分题，记录任务的领取状况，按人员编号从小到大，依次按其志愿领取任务未领取的任务。‘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[][] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            nums[i][j] = scan.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span>[] selected = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!selected[nums[i][j]])&#123;</span><br><span class="line">                selected[nums[i][j]] = <span class="keyword">true</span>;</span><br><span class="line">                res[i] = nums[i][j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m : res)&#123;</span><br><span class="line">        System.out.print(m+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-小团无路可逃"><a href="#3-小团无路可逃" class="headerlink" title="3. 小团无路可逃"></a>3. 小团无路可逃</h3><p>有一颗树，小团位于y位置，小美位于x位置。小美要追打小团，每次小美和小团可以向相邻位置转移（小团可以不动）。问最多多久小美可以追上小团。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 1 2</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">4 2</span><br><span class="line">5 3</span><br><span class="line">输出：</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>求出小美距所有节点的最短距离[dx1, dx2, …]，小团距所欲节点的最短距离[dy1, dy2, …]。则问题的结果是满足dx<sub>i</sub> &gt; dy<sub>i</sub>的最大dx<sub>i</sub>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n = scan.nextInt(), x = scan.nextInt(), y = scan.nextInt();</span><br><span class="line">    List&lt;Integer&gt;[] lists = <span class="keyword">new</span> List[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> u = scan.nextInt(), v = scan.nextInt();</span><br><span class="line">        lists[u] = lists[u] == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;&gt;() : lists[u];</span><br><span class="line">        lists[v] = lists[v] == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;&gt;() : lists[v];</span><br><span class="line">        lists[u].add(v);</span><br><span class="line">        lists[v].add(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dist1 = getDistance(x, n, lists);</span><br><span class="line">    <span class="keyword">int</span>[] dist2 = getDistance(y, n, lists);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dist1[i] &gt; dist2[i])&#123;</span><br><span class="line">            res = Math.max(res, dist1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迪杰斯特拉算法求单源最短路径(还可以通过BFS算法求)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getDistance(<span class="keyword">int</span> start, <span class="keyword">int</span> n, List&lt;Integer&gt;[] lists) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];    <span class="comment">// 节点编号1-n</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dist, -<span class="number">1</span>);    <span class="comment">// -1 代表不可达</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lists[start] == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> next : lists[start])&#123;</span><br><span class="line">        dist[next] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    flag[start] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">// 找出下一个最近距离节点</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;    <span class="comment">// 初始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!flag[j] &amp;&amp; dist[j] != -<span class="number">1</span>)&#123;    <span class="comment">// 节点j尚未求出最短距离，且节点j目前可达</span></span><br><span class="line">                min = min == <span class="number">0</span> ? j : dist[min] &gt; dist[j] ? j : min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag[min] = <span class="keyword">true</span>;    <span class="comment">// min节点加入最终集和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> next : lists[min])&#123;    <span class="comment">// 通过min,更新未求出最短距离的节点</span></span><br><span class="line">            <span class="keyword">if</span>(!flag[next])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[next] == -<span class="number">1</span>)&#123;</span><br><span class="line">                    dist[next] = dist[min] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dist[next] = Math.min(dist[next], dist[min] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-小团的默契游戏"><a href="#3-小团的默契游戏" class="headerlink" title="3. 小团的默契游戏"></a>3. 小团的默契游戏</h3><p>一个长为n的整数数组，最大值不超过m。给一个组合(l, r)，使得按序取数组中满足a[i]&lt;l或a[i]&gt;r组成的数组是单调不下降的。其中1&lt;=l&lt;=r&lt;=m。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 5</span><br><span class="line">4 1 4 1 2</span><br><span class="line">输出：</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>最简单的方式是通过三层循环解决该问题，但仔细分析可以发现一下规律：</p><ul><li>若(l, r)满足，则(l, r+1)肯定满足</li><li>若(l, r)满足，则(l+1, *)满足的话，只能是*&gt;=r</li></ul><p>通过这两点可以进行充分的剪枝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> m = scan.nextInt(), n = scan.nextInt();</span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        nums[i] = scan.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> l, r, i;</span><br><span class="line">    <span class="keyword">int</span> star = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虽然n的数量级时10^5, 但加入了两处剪枝后，可以大幅降低时间复杂度</span></span><br><span class="line">    <span class="keyword">for</span>(l = <span class="number">1</span>; l &lt;= m; l++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(r = star; r &lt;= m; r++)&#123;   <span class="comment">// l时的r必然是l-1时r的子集---第二处剪枝</span></span><br><span class="line">            <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &lt; l || nums[i] &gt; r)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[i] &lt; pre)&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == n)&#123;   <span class="comment">// 子序列是非降序排列---第一处剪枝-1</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r &lt;= m)&#123;   <span class="comment">// [r, m]必然满足---第一处剪枝-2</span></span><br><span class="line">            ct += m - r + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        star = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(ct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-小团的神秘暗号&quot;&gt;&lt;a href=&quot;#1-小团的神秘暗号&quot; class=&quot;headerlink&quot; title=&quot;1. 小团的神秘暗号&quot;&gt;&lt;/a&gt;1. 小团的神秘暗号&lt;/h3&gt;&lt;p&gt;一字符串为其加上一个头部和尾部进行加密。头部至少包含一个“MT”的子序列，且以T</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
    <category term="美团" scheme="http://yoursite.com/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动2021后端笔试第二场08.16</title>
    <link href="http://yoursite.com/2020/08/16/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A82021%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%9C%BA08.16/"/>
    <id>http://yoursite.com/2020/08/16/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A82021%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%9C%BA08.16/</id>
    <published>2020-08-15T16:00:00.000Z</published>
    <updated>2020-08-16T08:51:50.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-统计二叉树中的叶子节点数"><a href="#1-统计二叉树中的叶子节点数" class="headerlink" title="1. 统计二叉树中的叶子节点数"></a>1. 统计二叉树中的叶子节点数</h3><p>给出二叉树中的前序和中序遍历，求出二叉树中有多少个叶子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">3</span>       <span class="comment">// 节点数</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span>   <span class="comment">// 前序序列</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span>   <span class="comment">// 中序序列</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span>       <span class="comment">// 叶子节点数</span></span><br></pre></td></tr></table></figure><p>答题过程中采用的方法是重建+遍历统计，最终只过了90%，说是数组越界，但<code>buildTree</code>经过在<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/submissions/">Leetcode</a>和<a href="https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6">牛客网</a>都测试了一遍，都能通过，想不明白。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preOrder, <span class="keyword">int</span> prest, <span class="keyword">int</span> preed, <span class="keyword">int</span>[] inOrder, <span class="keyword">int</span> inst, <span class="keyword">int</span> ined)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(prest &gt; preed)&#123;    <span class="comment">// 没有子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        root.val = preOrder[prest];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">for</span>(mid = inst; mid &lt;= ined &amp;&amp; root.val != inOrder[mid]; mid++);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = mid - inst;</span><br><span class="line">        root.left = buildTree(preOrder, prest+<span class="number">1</span>, prest+len, inOrder, inst, mid-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preOrder, prest+len+<span class="number">1</span>, preed, inOrder, mid+<span class="number">1</span>,ined);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceAll</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traceAll(root.left);</span><br><span class="line">        traceAll(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ct++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scan.nextInt();   <span class="comment">// 二叉树的节点数</span></span><br><span class="line">        <span class="keyword">int</span>[] preOrder = <span class="keyword">new</span> <span class="keyword">int</span>[n];    <span class="comment">// 前序序列</span></span><br><span class="line">        <span class="keyword">int</span>[] inOrder = <span class="keyword">new</span> <span class="keyword">int</span>[n];     <span class="comment">// 中序序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            preOrder[i] = scan.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            inOrder[i] = scan.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root = buildTree(preOrder, <span class="number">0</span>, n-<span class="number">1</span>, inOrder, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ct = <span class="number">0</span>;</span><br><span class="line">        traceAll(root);</span><br><span class="line"></span><br><span class="line">        System.out.println(ct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，统计叶子节点数，在buildTree的时候就可以统计，可以节省一次遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preOrder, <span class="keyword">int</span> prest, <span class="keyword">int</span> preed, <span class="keyword">int</span>[] inOrder, <span class="keyword">int</span> inst, <span class="keyword">int</span> ined)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(prest &gt; preed)&#123;    <span class="comment">// 没有子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(prest == preed &amp;&amp; inst == ined)&#123;   <span class="comment">// 叶子节点</span></span><br><span class="line">            ct++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        root.val = preOrder[prest];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">for</span>(mid = inst; mid &lt;= ined &amp;&amp; root.val != inOrder[mid]; mid++);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = mid - inst;</span><br><span class="line">        root.left = buildTree(preOrder, prest+<span class="number">1</span>, prest+len, inOrder, inst, mid-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preOrder, prest+len+<span class="number">1</span>, preed, inOrder, mid+<span class="number">1</span>,ined);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scan.nextInt();   <span class="comment">// 二叉树的节点数</span></span><br><span class="line">        <span class="keyword">int</span>[] preOrder = <span class="keyword">new</span> <span class="keyword">int</span>[n];    <span class="comment">// 前序序列</span></span><br><span class="line">        <span class="keyword">int</span>[] inOrder = <span class="keyword">new</span> <span class="keyword">int</span>[n];     <span class="comment">// 中序序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            preOrder[i] = scan.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            inOrder[i] = scan.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        ct = <span class="number">0</span>;</span><br><span class="line">        TreeNode root = buildTree(preOrder, <span class="number">0</span>, n-<span class="number">1</span>, inOrder, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        System.out.println(ct);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-有效字符"><a href="#2-有效字符" class="headerlink" title="2. 有效字符"></a>2. 有效字符</h3><p>一个由0-9，A-F组成的字符串，里面不能出现0010，问至少删除多少个字符，能满足要求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2           &#x2F;&#x2F; 测试用例数</span><br><span class="line">0100</span><br><span class="line">0010ABCDEF</span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>没想到什么很好的解决方法，最后骗分的代码竟然AC了，纯属瞎猫碰上死耗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> t = Integer.valueOf(scan.nextLine());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(t-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            String s = scan.nextLine();</span><br><span class="line">            <span class="keyword">int</span> len = s.length();</span><br><span class="line">            <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i+<span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i+<span class="number">2</span>) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; s.charAt(i+<span class="number">3</span>) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    ct++;</span><br><span class="line">                    i += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(ct);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到讨论区里的解释是只要找有几个“0010”即可，仔细想想确实是，比如00<u>1</u>000<u>1</u>0至少删去两个字符，001<u>00</u>10至少删去两个字符，001<u>0</u>10至少删去一个字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> t = Integer.valueOf(scan.nextLine());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(t-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            String s = scan.nextLine();</span><br><span class="line">            <span class="keyword">int</span> len = s.length();</span><br><span class="line">            <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i+<span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i+<span class="number">2</span>) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; s.charAt(i+<span class="number">3</span>) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    ct++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(ct);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这类题目应该通过例子，找出规律。</p><h3 id="3-插入广告"><a href="#3-插入广告" class="headerlink" title="3. 插入广告"></a>3. 插入广告</h3><p>给n段视频，每段视频长度为L_i。现在需要向视频中插入广告，为了用户体验，插入的间隔越大越好。插入间隔可以为0，现有m段广告，问最大的插入间隔是多少。如果无法插入，则***</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">n m</span><br><span class="line">L_1 L_2 ... L_n</span><br><span class="line">输入：</span><br><span class="line">最大间隔</span><br></pre></td></tr></table></figure><p>是在想不出怎么会有无法插入的情况，大不了间隔为0，一直放广告，随便一段视频都能插入完啊。还有中间广播提示广告可以无限插入，这道题根本get不到点，直接放弃了。</p><p>评论区讨论是用二分法解决的，突然恍然大悟：如果间隔为x，那么视频i最多能插入L_i / x段视频。这点笔试中想到了，但是没有联系到二分法，所以感觉没有思路。这道题nlogn是可以通过的，广告的最小间隔是0，最大间隔是max{L_i}。那么这道题就可以转化为二分法求最大的大于指定数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Three &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; scan.nextInt(), m &#x3D; scan.nextInt();</span><br><span class="line">        int[] lens &#x3D; new int[n];</span><br><span class="line">        int left &#x3D; 0, right &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">            lens[i] &#x3D; scan.nextInt();</span><br><span class="line">            right &#x3D; Math.max(right, lens[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(left &lt; right)&#123;</span><br><span class="line">            int mid &#x3D; left + (right - left + 1) &#x2F; 2;</span><br><span class="line">            </span><br><span class="line">            int ct &#x3D; count(lens, mid);</span><br><span class="line">            </span><br><span class="line">            if(ct &lt; m)&#123;</span><br><span class="line">                right &#x3D; mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                left &#x3D; mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int count(int[] lens, int mid) &#123;</span><br><span class="line">        </span><br><span class="line">        int ct &#x3D; 0;</span><br><span class="line">        for(int m : lens)&#123;</span><br><span class="line">            ct +&#x3D; m &#x2F; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题目，可能需要使用long类型，不过解决问题的思路有了，才是最关键的。</p><h3 id="4-最大的sum-m"><a href="#4-最大的sum-m" class="headerlink" title="4. 最大的sum % m"></a>4. 最大的sum % m</h3><p>长度为n的整数数组，从数组中选取0-n个数，选取的数的和记为sum，求最大的sum%m。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;&#x3D; m &lt;&#x3D; 1e9+7</span><br><span class="line">n &lt;&#x3D; 35</span><br></pre></td></tr></table></figure><p>这道题看起来是0-1背包，但m的数量级太大，直接劝退。后来考虑递归遍历所有情况，时间复杂度2^n，也会超时，最终通过40%。看评论区，暴力dfs居然过了60%，为什么我的只过了40%，难道是因为用的是java吗。</p><p><a href="https://www.nowcoder.com/discuss/478874?type=post&order=time&pos=&page=1&channel=1009&source_id=search_post">看评论区，通过将数组分为两组</a>，思路以后再写。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-统计二叉树中的叶子节点数&quot;&gt;&lt;a href=&quot;#1-统计二叉树中的叶子节点数&quot; class=&quot;headerlink&quot; title=&quot;1. 统计二叉树中的叶子节点数&quot;&gt;&lt;/a&gt;1. 统计二叉树中的叶子节点数&lt;/h3&gt;&lt;p&gt;给出二叉树中的前序和中序遍历，求出二叉树</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
    <category term="字节" scheme="http://yoursite.com/tags/%E5%AD%97%E8%8A%82/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2021美团正式批笔试8.15</title>
    <link href="http://yoursite.com/2020/08/15/2021%E7%BE%8E%E5%9B%A2%E6%AD%A3%E5%BC%8F%E6%89%B9%E7%AC%94%E8%AF%958.15/"/>
    <id>http://yoursite.com/2020/08/15/2021%E7%BE%8E%E5%9B%A2%E6%AD%A3%E5%BC%8F%E6%89%B9%E7%AC%94%E8%AF%958.15/</id>
    <published>2020-08-14T16:00:00.000Z</published>
    <updated>2020-08-15T14:17:55.061Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-特殊的逆序对"><a href="#1-特殊的逆序对" class="headerlink" title="1. 特殊的逆序对"></a>1. 特殊的逆序对</h4><p>如果一个数的四倍是它的逆序数，那么这两个数就构成了一个逆序数对。给一个正整数n，求不大于n的正整数构成的逆序数对。</p><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1234的逆序数是4321，1100的逆序数是11</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入正整数n</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行输出共有多少对逆序数</span><br><span class="line">从第二行开始每行输出一对逆序数，按第一个数从小到达开始输出，没有就不输出</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">10000</span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line">2178 8712</span><br></pre></td></tr></table></figure><p>*<em>没有考虑到4</em>i可能已经超出了n，最终代码只通过了55%：**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = i * <span class="number">4</span>; </span><br><span class="line">            <span class="keyword">if</span>(t &lt;= n &amp;&amp; judge(i))&#123;   <span class="comment">// 丢掉了重要条件</span></span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, t&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] arr : list)&#123;</span><br><span class="line">            System.out.println(arr[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + arr[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String str1 = String.valueOf(a);</span><br><span class="line">        <span class="keyword">int</span> b = Integer.valueOf(<span class="keyword">new</span> StringBuilder(str1).reverse().toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a*<span class="number">4</span> == b;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-统计旅行次数"><a href="#2-统计旅行次数" class="headerlink" title="2. 统计旅行次数"></a>2. 统计旅行次数</h4><p>每次旅行会从一个城市出发，经过若干城市后回到出发的城市。现给出若干次旅行所有的城市之间的通行信息，请你找出总共旅行了多少次。其中不会包括无效的旅行信息。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行输入n，代表通行信息条数</span><br><span class="line">此后每行输入出发城市，到达城市</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一共旅行了多少次</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">6</span><br><span class="line">beijing chongqing</span><br><span class="line">chongqing hangzhou</span><br><span class="line">hangzhou beijing</span><br><span class="line">beijing xian</span><br><span class="line">xian beijing</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>看评论才知道，要考虑A-A这种情况（但自己的代码没问题啊），代码只通过了91%：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author shkstart</span><br><span class="line"> * @create 2020-08-15 16:36</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Two &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; Integer.valueOf(scan.nextLine());</span><br><span class="line"></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">            String[] strs &#x3D; scan.nextLine().split(&quot; &quot;);</span><br><span class="line">            List&lt;String&gt; list &#x3D; map.getOrDefault(strs[0], new ArrayList&lt;&gt;());</span><br><span class="line">            list.add(strs[1]);</span><br><span class="line">            map.put(strs[0], list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ct &#x3D; 0;</span><br><span class="line">        for(String key : map.keySet())&#123;</span><br><span class="line">            List&lt;String&gt; list &#x3D; map.get(key);</span><br><span class="line">            while(list.size() &gt; 0)&#123;</span><br><span class="line">                if(dfs(key, key, map))&#123;</span><br><span class="line">                    ct++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(ct);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean dfs(String start, String key, Map&lt;String, List&lt;String&gt;&gt; map) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list &#x3D; map.get(key);</span><br><span class="line"></span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        boolean res &#x3D; false;</span><br><span class="line"></span><br><span class="line">        for(i &#x3D; 0; i &lt; list.size(); i++)&#123;</span><br><span class="line">            String next &#x3D; list.get(i);</span><br><span class="line">            if(next.equals(start))&#123;</span><br><span class="line">                res &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                res &#x3D; dfs(start, next, map);</span><br><span class="line">            &#125;</span><br><span class="line">            if(res)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(res)&#123;</span><br><span class="line">            list.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>补充：</p><p>真无语，难道真的是自己审题有问题吗，看到有人居然一遍遍历就过了，把题想难了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int count;</span><br><span class="line">    cin&gt;&gt;count;</span><br><span class="line">    vector&lt;pair&lt;string,string&gt;&gt;res;</span><br><span class="line">    string str1,str2;</span><br><span class="line">    for(int i &#x3D; 0;i &lt; count;i++)&#123;</span><br><span class="line">        cin&gt;&gt;str1&gt;&gt;str2;</span><br><span class="line">        res.push_back(&#123;str1,str2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    int len &#x3D; 1;</span><br><span class="line">    count &#x3D; res.size();</span><br><span class="line">    for(int i &#x3D; 0;i &lt; count - 1;i++)&#123;</span><br><span class="line">        if(res[i].second !&#x3D; res[i + 1].first)len++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-小区人员划分"><a href="#3-小区人员划分" class="headerlink" title="3. 小区人员划分"></a>3. 小区人员划分</h4><p>有n个人编号1-n，给出关系&lt;a, b&gt;代表a和b同属一个小区。请你根据给出的关系，对人员进行划分。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行输入n，m分别代表人员数，和关系数</span><br><span class="line">第二行开始每行输入关系a b , 共输入m行</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行输出n个人共有几个小区</span><br><span class="line">此后每行，输出每个小区的人员，编号递增</span><br><span class="line">小区顺序：编号最小的人员的编号越小，越优先输出</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>通过并查集思想，不难解决，此次笔试唯一AC的题：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author shkstart</span><br><span class="line"> * @create 2020-08-15 17:24</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Three &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; scan.nextInt(), m &#x3D; scan.nextInt();</span><br><span class="line">        int[] mark &#x3D; new int[n+1];</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; n ;i++)&#123;</span><br><span class="line">            mark[i] &#x3D; i;</span><br><span class="line">            List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            list.add(i);</span><br><span class="line">            map.put(i, list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">            int a &#x3D; scan.nextInt(), b &#x3D; scan.nextInt();</span><br><span class="line">            int c_a &#x3D; mark[a], c_b &#x3D; mark[b];</span><br><span class="line">            if(c_a &#x3D;&#x3D; c_b)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Integer&gt; listA&#x3D; map.get(c_a);</span><br><span class="line">            List&lt;Integer&gt; listB &#x3D; map.get(c_b);</span><br><span class="line">            for(int t : listB)&#123;</span><br><span class="line">                mark[t] &#x3D; c_a;</span><br><span class="line">                listA.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">            map.remove(c_b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">        Set&lt;Integer&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">            int c &#x3D; mark[i];</span><br><span class="line">            if(set.contains(c))&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Integer&gt; list &#x3D; map.get(c);</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            for(int num : list)&#123;</span><br><span class="line">                System.out.print(num + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            set.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-运输的最高收益"><a href="#4-运输的最高收益" class="headerlink" title="4.  运输的最高收益"></a>4.  运输的最高收益</h4><p>运输公司有n辆车，位于不同位置。现有两个地方都要用车，每辆车由于位置不同到两地的运输收益也不同。连个地方分别要a辆车，b辆车。请你计算出运输的最大收益。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行：n, a, b</span><br><span class="line">第二行：a1 a2 ... an  每辆车到第一个地方的收益</span><br><span class="line">第二行：b1 b2 ... bn  每辆车到第二个地方的收益</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大收益</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 2 2</span><br><span class="line">4 3 5 5 1</span><br><span class="line">2 3 4 3 5</span><br><span class="line">输出：</span><br><span class="line">18</span><br></pre></td></tr></table></figure><p><strong>这道题应该是道动态规划的题，和背包也挺像的，暂时没思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-特殊的逆序对&quot;&gt;&lt;a href=&quot;#1-特殊的逆序对&quot; class=&quot;headerlink&quot; title=&quot;1. 特殊的逆序对&quot;&gt;&lt;/a&gt;1. 特殊的逆序对&lt;/h4&gt;&lt;p&gt;如果一个数的四倍是它的逆序数，那么这两个数就构成了一个逆序数对。给一个正整数n，求不大于</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>SSH连接虚拟机Ubuntu</title>
    <link href="http://yoursite.com/2020/08/15/SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu/"/>
    <id>http://yoursite.com/2020/08/15/SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu/</id>
    <published>2020-08-14T16:00:00.000Z</published>
    <updated>2020-08-15T14:18:59.260Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-查看虚拟机ip地址"><a href="#1-查看虚拟机ip地址" class="headerlink" title="1. 查看虚拟机ip地址"></a>1. 查看虚拟机ip地址</h4><p>在Ubuntu下输入命令查看ip地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><h4 id="2-测试ip地址是否可达"><a href="#2-测试ip地址是否可达" class="headerlink" title="2. 测试ip地址是否可达"></a>2. 测试ip地址是否可达</h4><p>Windows下打开cmd，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [ip地址]</span><br></pre></td></tr></table></figure><h4 id="3-安装ssh"><a href="#3-安装ssh" class="headerlink" title="3. 安装ssh"></a>3. 安装ssh</h4><p>首先测试Ubuntu是否安装ssh:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh localhost</span><br></pre></td></tr></table></figure><p>若连接失败，则需要安装ssh服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>安装完成后，确认ssh服务处于启动状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh status </span><br></pre></td></tr></table></figure><p>出现Active: active (running)，代表正在正在运行。</p><h4 id="4-使用XShell或git连接Ubuntu"><a href="#4-使用XShell或git连接Ubuntu" class="headerlink" title="4. 使用XShell或git连接Ubuntu"></a>4. 使用XShell或git连接Ubuntu</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-查看虚拟机ip地址&quot;&gt;&lt;a href=&quot;#1-查看虚拟机ip地址&quot; class=&quot;headerlink&quot; title=&quot;1. 查看虚拟机ip地址&quot;&gt;&lt;/a&gt;1. 查看虚拟机ip地址&lt;/h4&gt;&lt;p&gt;在Ubuntu下输入命令查看ip地址：&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>背包问题解析</title>
    <link href="http://yoursite.com/2020/08/14/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2020/08/14/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/</id>
    <published>2020-08-13T16:00:00.000Z</published>
    <updated>2020-10-19T05:33:35.261Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-0-1背包"><a href="#1-0-1背包" class="headerlink" title="1. 0-1背包"></a>1. 0-1背包</h2><p>背包的能容纳的最大重量为W，有N个物品，每个物品的重量为w<sub>i</sub>，价值为v<sub>i</sub>。求背包可容纳的物品的最大价值。</p><p>定义二维数组dp[N][W]，dp[i][j]表示前i个物品在重量不超过j的情况下能容纳物品的最大价值。设第i件物品的重量为w<sub>i</sub>, 价值为v<sub>i</sub>，根据第i件物品是否在背包中，可以有两种情况：</p><ul><li>第i件物品不放在背包中，dp[i][j]（前i件物品放入容量为j的背包的最大价值） =  dp[i-1][j]（前i-1件物品放入容量为j的背包的最大价值）</li><li>第i件物品放入背包中，dp[i][j]（前i件物品放入容量为j的背包的最大价值） = dp[i-1][j-w<sub>i</sub>] + v<sub>i</sub>（前i-1件物品放入容量为j-w<sub>i</sub>的背包的最大价值 + v<sub>i</sub>）</li></ul><p>dp[i][j]应该取两者的较大的，状态转移方程为：<br>$$<br>dp[i][j] = max{dp[i-1][j],\quad dp[i-1][j-w_i],+,v_i}<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values, <span class="keyword">int</span> W, <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][W+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> w = weights[i-<span class="number">1</span>], v = values[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= W; j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j - w &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], dp[i-<span class="number">1</span>][j-w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>空间优化</strong></p><p>观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。此时，<br>$$<br>dp[j] = max{dp[j],,, dp[j-w_i],+,v_i}<br>$$<br>因为dp[j-w<sub>i</sub>]代表的是dp[i-1][j-w<sub>i</sub>]，为了避免覆盖掉dp[i-1][j-w<sub>i</sub>]，也就是说要先计算 dp[i][j] 再计算 dp[i][j-w<sub>i</sub>]，在程序实现时需要按倒序来循环求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values, <span class="keyword">int</span> W, <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[W+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> w = weights[i-<span class="number">1</span>], v = values[i-<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// dp[j] 代表没有第i件物品容量为j的最大价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = W; j &gt;= w; j--)&#123;</span><br><span class="line">            dp[j] = Math.max([j], dp[j-w] + v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例题</strong></p><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></p><p>我们可以先求出数组所有元素的和sum，问题可以转化为0-1背包问题：背包的容量为sum/2，原数组就是每件物品的重量，判断背包是否可以正好装满。</p><p>此问题没有涉及物品的价值：求的是是否能将背包装满，所以无需考虑物品的价值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m : nums)&#123;</span><br><span class="line">        sum += m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> S = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[S+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;    <span class="comment">// 每个物品只用一次</span></span><br><span class="line">        <span class="keyword">int</span> weight = nums[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = S; j &gt;= weight; j--)&#123;    <span class="comment">// 从后往前，先计算dp[j]，再计算dp[j-1]</span></span><br><span class="line">            dp[j] = dp[j] || dp[j-weight];   <span class="comment">// *****</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[S];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></p><p>将数组按符号分为两个集和：带正号集和S1，带符号集和S2，可以得出：<br>$$<br>sum(S1) - sum(S2) = target\<br>sum(S1) + sum(S2) ,=, sum<br>$$<br>可以得出：<br>$$<br>2*sum(S1) = target + sum<br>$$<br> 问题也可以转化为0-1背包问题：容量为(target+sum)/2，物品为数组，求有多少种方式可以将背包放满。</p><p>此问题求解的是背包放满有多少种方式，同样没有涉及到物品价值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m : nums)&#123;</span><br><span class="line">        sum += m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((sum + S) % <span class="number">2</span> == <span class="number">1</span> || sum &lt; S)&#123;   <span class="comment">// 注意这里，否则会超出内存</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = (sum + S) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span> [T + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> weight : nums)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = T; j &gt;= weight; j--)&#123;</span><br><span class="line">            dp[j] += dp[j-weight];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题数组长度不会超过20，同样可以用DFS求解，时间复杂度O(2^n)。</p><p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></p><p>这道题如果仔细考虑一下，也是个0-1背包问题：背包的容量有两个限制m和n，物品就是字符串数组，每个物品的代价就是字符串中0和1的数量，求背包中最多能放如多少个物品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(String[] strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];    <span class="comment">// 背包有两个限制属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String s : strs)&#123;    <span class="comment">// 每个物品只能放一次</span></span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>, one = <span class="number">0</span>;    <span class="comment">// 物品的两个属性代价</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                zero++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                one++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= zero; j--)&#123;    <span class="comment">// 0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = n; k &gt;= one; k--)&#123;    <span class="comment">// 1</span></span><br><span class="line">                dp[j][k] = Math.max(dp[j][k], dp[j-zero][k-one] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>0-1背包的特点</strong></p><ul><li>N个物品，每个物品两个属性&lt;w, v&gt;</li><li>每个物品在背包中可以放0个或1个</li><li>求容量不超出下的最大价值</li></ul><h2 id="2-完全背包"><a href="#2-完全背包" class="headerlink" title="2. 完全背包"></a>2. 完全背包</h2><p>背包的能容纳的最大重量为W，有N个物品，每个物品的重量为w<sub>i</sub>，价值为v<sub>i</sub>。求背包可容纳的物品的最大价值。完全背包问题中，每个物品放入的数量是不受限制的。</p><p>dp[i][j]表示前i个物品&lt;w<sub>i</sub>, v<sub>i</sub>&gt;放入容量为j背包时的最大代价，根据第i个物品放入到背包的状况，可以得到状态转移方程：<br>$$<br>dp[i][j] = max{dp[i-1][j],, dp[i-1][j-w_i] + v_i,, dp[i-1][j-2<em>w_i]+2</em>v_i,….}<br>$$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values, <span class="keyword">int</span> W, <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][W+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;    <span class="comment">// 放入每个物品</span></span><br><span class="line">        <span class="keyword">int</span> w = weights[i-<span class="number">1</span>], v = values[i-<span class="number">1</span>];    <span class="comment">// 物品的代价和价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= W; j++)&#123;    <span class="comment">// </span></span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j];     <span class="comment">// 不放入第i个物品</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k*w &lt;= j; k++)&#123;    <span class="comment">// 放入1个，2个....</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], dp[i-<span class="number">1</span>][j-k*w] + k*v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br><span class="line">空间压缩后</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values, <span class="keyword">int</span> W, <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[W+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;    <span class="comment">// 放入每个物品</span></span><br><span class="line">        <span class="keyword">int</span> w = weights[i-<span class="number">1</span>], v = values[i-<span class="number">1</span>];    <span class="comment">// 物品的代价和价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = W; j &gt;= <span class="number">1</span>; j--)&#123;    <span class="comment">// </span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k*w &lt;= j; k++)&#123;    <span class="comment">// 放入1个，2个....</span></span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-k*w] + k*v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种比较简洁的思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values, <span class="keyword">int</span> W, <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[W+<span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;    <span class="comment">// 放入每个物品</span></span><br><span class="line">        <span class="keyword">int</span> w = weights[i-<span class="number">1</span>], v = values[i-<span class="number">1</span>];    <span class="comment">// 物品的代价和价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = w; j &lt;= W; j++)&#123;    <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span>(dp[j-w] != -<span class="number">1</span>)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j-w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></p><p>此问题是个完全背包问题：物品是硬币，可以无限次放入，背包容量是amount，求能将背包装满的组合数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">       Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line">       dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> m : coins[i])&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &lt;= amount; j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(dp[j-m] != -<span class="number">1</span>)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(dp[j] == -<span class="number">1</span>)&#123;</span><br><span class="line">                       dp[j] = dp[j-m] + <span class="number">1</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">else</span>&#123;</span><br><span class="line">                       dp[j] = Math.min(dp[j], dp[j-m]+<span class="number">1</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> dp[amount];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a></p><p>完全背包，求组合数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = coin; i &lt;= amount; i++)&#123;</span><br><span class="line">            dp[i] += dp[i-coin];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></p><p>这道题比较有意思，物品是单词字典，背包的容量是字符串长度，不过它的放入条件是字符串要相同。而且物品放入有先后顺序。带放入顺序的完全背包问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String str : wordDict)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = str.length(); i &lt;= len; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!dp[i] &amp;&amp; dp[i-str.length()] &amp;&amp; isSame(s, i-<span class="number">1</span>, str))&#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确解法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(String str : wordDict)&#123;</span><br><span class="line">                <span class="keyword">int</span> l = str.length();</span><br><span class="line">                <span class="keyword">if</span>(!dp[i] &amp;&amp; i &gt;= l &amp;&amp; isSame(s, i-<span class="number">1</span>, str))&#123;</span><br><span class="line">                    dp[i] |= dp[i-l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(String str, <span class="keyword">int</span> end, String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = end, j = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> j == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></p><p>求组合数，不同的序列被视为不同的组合，则需要考虑物品放入背包时的顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] maximum = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    maximum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length &amp;&amp; nums[j] &lt;= i; j++) &#123;</span><br><span class="line">            maximum[i] += maximum[i - nums[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maximum[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无视组合数字的中的先后顺序的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m : nums)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &lt;= target; j++)&#123;</span><br><span class="line">            dp[j] += dp[j-m];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完全背包的特点</strong></p><ul><li>N个物品，每个物品两个属性&lt;w, v&gt;</li><li>每个物品在背包中可以放0个或无限多个</li><li>求容量不超出下的最大价值</li></ul><h2 id="3-多重背包"><a href="#3-多重背包" class="headerlink" title="3. 多重背包"></a>3. 多重背包</h2><p><strong>多重背包的特点</strong></p><ul><li>N个物品，每个物品两个属性&lt;w, v&gt;</li><li>每个物品都有一定的数量N<sub>i</sub>，在背包中可以放入0-N<sub>i</sub></li><li>求容量不超出下的最大价值</li></ul><h2 id="4-多维费用背包"><a href="#4-多维费用背包" class="headerlink" title="4.多维费用背包"></a>4.多维费用背包</h2><p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></p><p>属于0-1背包中的多维费用背包，答案见0-1背包。</p><p><strong>多维费用背包的特点</strong></p><ul><li>N个物品，每个物品有多个限制属性如容量、体积，以及价值</li><li>放入看具体要求</li><li>求重量和体积都不超出下的最大价值</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-0-1背包&quot;&gt;&lt;a href=&quot;#1-0-1背包&quot; class=&quot;headerlink&quot; title=&quot;1. 0-1背包&quot;&gt;&lt;/a&gt;1. 0-1背包&lt;/h2&gt;&lt;p&gt;背包的能容纳的最大重量为W，有N个物品，每个物品的重量为w&lt;sub&gt;i&lt;/sub&gt;，价值为v&lt;s</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="背包" scheme="http://yoursite.com/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础</title>
    <link href="http://yoursite.com/2020/08/13/Redis%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/08/13/Redis%E5%9F%BA%E7%A1%80/</id>
    <published>2020-08-13T13:22:53.000Z</published>
    <updated>2020-08-15T14:18:53.033Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Redis有那些数据结构"><a href="#1-Redis有那些数据结构" class="headerlink" title="1.Redis有那些数据结构"></a>1.Redis有那些数据结构</h4><p>​    字符串、字典Hash、列表List、集和Set、有序集和SortedSet。</p><p>​    ….加分项</p><p>​    BitMap、Geo、HyperLogLog、</p><p><strong>应用场景补充</strong></p><p>​    字符串：常规的key-value缓存应用。常用计数器：微博数，粉丝数</p><p>​    hash: 存储部分变更数据，如用户信息等。</p><p>​    list: 可以构建消息队列</p><p>​    set: 交集、并集、差集，去重，找共同的爱好……</p><p>​    sortedset: 通过score对元素进行优先排序，带权重的消息队列</p><h4 id="2-大量key同一时间过期"><a href="#2-大量key同一时间过期" class="headerlink" title="2.大量key同一时间过期"></a>2.大量key同一时间过期</h4><p>​    如果大量的key在同一时间过期，那么到过期的时间点Redis会发生卡顿现象，严重的话会造成<strong>缓存雪崩</strong>，解决方法是在设置失效时间时加上一个随机值。</p><h4 id="3-Redis分布式锁"><a href="#3-Redis分布式锁" class="headerlink" title="3.Redis分布式锁"></a>3.Redis分布式锁</h4><p>​    分布式锁是为了解决多进程之间的同步，redis可以实现分布式锁。可以用setnx原子操作来获得锁（），抢到之后用expire给锁添加过期时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setnx k v</span><br><span class="line">expire k timeout</span><br></pre></td></tr></table></figure><p>追问：如果setnx获取锁成功，但线程执行expire之前崩溃，会如何，怎样解决？</p><p>​    此时，这个锁将一直被持有，无法释放。可以用同时具有setnx和expire的原子指令***解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set k v nx[key必须不存在] [ex t 秒级]&#x2F;[px t 毫秒级]</span><br></pre></td></tr></table></figure><h4 id="4-如何在Redis中查询大量的具有固定前缀的key"><a href="#4-如何在Redis中查询大量的具有固定前缀的key" class="headerlink" title="4.如何在Redis中查询大量的具有固定前缀的key"></a>4.如何在Redis中查询大量的具有固定前缀的key</h4><p>​    可以利用keys指令查询，但该指令会一次性查找全部符合条件的key，会造成卡顿（Redis是单线程的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys [pattern]</span><br></pre></td></tr></table></figure><p>​    因为keys指令需要全部遍历，数据量很大的话，需要一定的执行时间。由于Redis是单线程，所以其他服务会暂停，直到keys指令结束。为避免此情况发生，可以使用scan指令，scan指令可以无阻塞的取出指定模式的key列表（每次执行会找到若干个符合条件的key），但会出现重复，所以客户端需要去重：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan cursor[0代表从头开始] [MATCH pattern] [COUNT num]</span><br></pre></td></tr></table></figure><p>​    由于scan不是一次性遍历（增量式迭代），所以在全部扫描完成时可能有些key会发生变化。</p><h4 id="5-Redis异步队列"><a href="#5-Redis异步队列" class="headerlink" title="5.Redis异步队列"></a>5.Redis异步队列</h4><p>​    Redis可以实现异步队列，一般用List实现，rpush生产消息，lpop消费消息。当lpop没有消息可消费时，需要sleep一会儿重试。</p><p>​    除了sleep还可以使用blpop指令，在没有消息时，他会阻塞住直到消息到来。</p><p><strong>一次生产，多次消费如何实现？</strong></p><p>​    可以使用pub/sub主题订阅模式，可以实现1：N的消息队列</p><p><strong>pub/sub有何问题</strong></p><p>​    在消费者下线情况下，生产的消息会丢失，可以使用RabbitMQ。</p><p><strong>如何实现延时队列</strong></p><p>​    可以使用有序集和sortedset，将时间作为score，消息内容作为key，调用zadd来生产消息，消费者通过zrangebyscore指令获取N秒前的消息.</p><h4 id="6-Redis持久化"><a href="#6-Redis持久化" class="headerlink" title="6.Redis持久化"></a>6.Redis持久化</h4><p>​    Redis持久化有两种方式：RDB镜像全量持久化、AOF增量持久化。</p><p><strong>RDB:</strong></p><p>​    Redis每隔一段时间可以将所有数据备份到磁盘，Redis会fork一个子线程进行RDB操作，子线程创建后，父子线程共享数据段，父线程将继续提供服务，写脏的页面数据会和子线程分开（cow, copy on write)。cow数据未发生变化时，父子线程共享数据，一旦发生变化，子线程才会分配空间存储数据。</p><p>​    自动触发：配置文件中，可以配置经过多少次save就触发；</p><p>​    手动触发：通过bgsave命令，会fork一个子进程。</p><p><strong>AOF：</strong></p><p>​    将Redis执行的指令记录到磁盘，sync属性可以支持每条指令都写到磁盘，但代价较高。可以设置每秒sync，这样最多会丢失1s的数据。</p><p>​    AOF日志会随着时间不断变大，可以通过AOF重写解决。首先读取数据库中所有键值的状态，使用一条命令替代前面多条操作语句。使用bgrewriteaof命令进行重写，重写时会fork一个子进程进行重写，主进程将重写期间的命令放到重写缓冲区中，待重写完成将其添加到AOF文件中。</p><p>​    RDB无法实时持久化，AOF文件较大（AOF重写解决）。</p><h4 id="7-Pipline是什么"><a href="#7-Pipline是什么" class="headerlink" title="7.Pipline是什么"></a>7.Pipline是什么</h4><p>​    普通的请求中，每次请求都对应一次IO操作等待（往返时延），而Pipline会将所有请求转化为一次IO操作（一次往返）。使用前提是指令之间没有因果相关性。</p><h4 id="8-Redis的同步机制"><a href="#8-Redis的同步机制" class="headerlink" title="8.Redis的同步机制"></a>8.Redis的同步机制</h4><p>​    Redis同步机制有两种：主从同步</p><p><strong>主从同步：</strong></p><ul><li>从服务器向主服务器发送sync命令</li><li>主服务器收到sync命令，开始执行bgsave命令生成RDB文件，并用缓存开始记录此后执行的所有写命令</li><li>主服务器bgsave完成之后，向从服务器发送RDB文件，继续在缓存中记录写命令</li><li>从服务器收到RDB文件，丢弃所有旧数据，载入RDB</li><li>主服务器向从服务器发送缓存中的命令</li><li>从服务器载入RDB后开始接收命令请求，执行来自主服务器中的缓存命令</li></ul><p>通过以上操作，<strong>全量同步</strong>完成，以后主服务器向从服务器发送所有的写操作进行<strong>增量同步</strong>。</p><h4 id="9-Redis集群"><a href="#9-Redis集群" class="headerlink" title="9.Redis集群"></a>9.Redis集群</h4><p>​    Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master,继续提供服务。</p><p>​    Redis Cluster着眼于扩展性，在单个Redis内存不足时，使用Cluster进行分片存储。</p><h4 id="10-Redis为什么快"><a href="#10-Redis为什么快" class="headerlink" title="10.Redis为什么快"></a>10.Redis为什么快</h4><ul><li><p>数据放在内存中，而且其存储数据类似HashMap，所以速度很快</p></li><li><p>单线程，没有线程上下文切换开销</p></li><li><p>多路IO复用，可以一个线程监听多路IO</p><p>研究表明，redis的瓶颈在网络时延</p></li></ul><h4 id="11-Redis与memcached区别"><a href="#11-Redis与memcached区别" class="headerlink" title="11.Redis与memcached区别"></a>11.Redis与memcached区别</h4><ul><li>memcached只支持字符串，redis支持更丰富的数据类型</li><li>redis支持数据持久化</li><li>redis支持数据备份，即master-slave</li></ul><h4 id="12-redis数据过期回收"><a href="#12-redis数据过期回收" class="headerlink" title="12.redis数据过期回收"></a>12.redis数据过期回收</h4><ul><li><p>定期回收</p><p>没过一段时间去抽查一部分数据是否过期，过期就删除。</p></li><li><p>惰性删除</p><p>使用key时，先判断是否过期，过期则删除。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-Redis有那些数据结构&quot;&gt;&lt;a href=&quot;#1-Redis有那些数据结构&quot; class=&quot;headerlink&quot; title=&quot;1.Redis有那些数据结构&quot;&gt;&lt;/a&gt;1.Redis有那些数据结构&lt;/h4&gt;&lt;p&gt;​    字符串、字典Hash、列表List</summary>
      
    
    
    
    <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库基础概念</title>
    <link href="http://yoursite.com/2020/08/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2020/08/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2020-08-13T13:22:53.000Z</published>
    <updated>2020-08-15T14:19:12.413Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h4><p>事务指的是满足ACID的一组操作，它可以通过Commit提交一个事务，也可以使用Rollback进行回滚。</p><ol><li><p><strong>原子性（Atomicity）</strong></p><p>事务被视为不可分割的最小单元，事务的所有操作要么全部完成后提交，要么全部失败回滚。</p><p>回滚可以通过回滚日志（Undo log）实现，里面记录着事务所执行的所有修改操作，回滚时反向执行即可。</p></li><li><p><strong>一致性（Consistency）</strong></p><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果是相同的。</p></li><li><p><strong>隔离性（Isolation）</strong></p><p>一个事务所作的更改在提交前对其他事务是不可见的。</p></li><li><p><strong>持久性（Durability）</strong></p><p>一旦事务提交，其所作的更改就会永远保持到数据库中。即使数据库发生崩溃，事务的执行的结果也不能丢失。</p><p>系统发生崩溃时，可以通过重做日志（Redo Log）进行修复，从而实现持久性。与回滚日志不同记录的数据的逻辑修改不同，重做日志记录的是数据页的物理更改。</p></li></ol><p>事务的ACID特性概念简单，但不好理解，主要是这几个特性不是一种平级关系：</p><ul><li>一致性是基本保证的，只有满足一致性，事务的执行结果才是正确的</li><li>在无并发情形下，事务串行执行，隔离性一定满足。此时只要满足原子性就能满足一致性</li><li>在并发情形下，多个事务并发执行，事务不仅要满足原子性，还要满足隔离性，才能满足一致性</li><li>事务满足持久性，是为了应对系统崩溃情况</li></ul><h4 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h4><p>并发条件下，事务的隔离性很难保证，因为会出现很多并发一致性问题。</p><ol><li><p><strong>丢失修改</strong></p><p>T1，T2两个事务都对一个数据进行修改，T1先修改，T2后修改，此时T2的修改会覆盖T1的修改。</p></li></ol><p><img src="/2020/08/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/Users\Liuyz\Desktop\面试备战笔记\images\丢失修改.png" alt="丢失修改"></p><ol start="2"><li><p><strong>读脏数据</strong></p><p>T1修改一个数据，T2随后读取了该数据。如果T1撤销了这次修改（发生了回滚），那么T2读到的数据是脏数据。</p><p><img src="/2020/08/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/Users\Liuyz\Desktop\面试备战笔记\images\读脏数据.png" alt="读脏数据"></p></li><li><p><strong>不可重复读</strong></p><p>T2读取了一个数据，随后T1修改了该数据。如果T2再次读该数据，此时读取的数据与第一次不一致。</p><p><img src="/2020/08/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/Users\Liuyz\Desktop\面试备战笔记\images\不可重复读.png" alt="不可重复读"></p></li><li><p><strong>幻读</strong></p><p>T1读取了某个范围内的数据，随后T2在这个范围内插入了一条数据。T1再次查询这个范围内的数据的话，此时读取的结果与第一次不同。</p><p><img src="/2020/08/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/Users\Liuyz\Desktop\面试备战笔记\images\幻读.png" alt="幻读"></p></li></ol><h4 id="三、数据库中的锁机制"><a href="#三、数据库中的锁机制" class="headerlink" title="三、数据库中的锁机制"></a>三、数据库中的锁机制</h4><ol><li><p><strong>锁的粒度</strong></p><p>MySQL中提供了两种锁的粒度：行级锁和表级锁。</p><p>降低锁的粒度，可以减少锁的竞争，提升系统的并发程度。</p><p>但是加锁需要消耗资源，锁的各种实现都会增加系统负担。锁粒度越小，系统开销越大。</p><p>因此需要平衡锁开销和并发度。</p></li><li><p><strong>锁的类型</strong></p><p>独占锁（Exclusive），简写为 X 锁，又称写锁。</p><p>共享锁（Shared），简写为 S 锁，又称读锁。</p><p>有以下两个规定：</p><p>​    一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</p><p>​    一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</p><p><strong>补充</strong>（不太懂）</p><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><p>​    一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</p><p>​    一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</p><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p></li><li><p><strong>封锁协议</strong></p><p><strong>一级封锁协议</strong>：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><p><strong>二级封锁协议</strong>：在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><p><strong>三级封锁协议</strong>：在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><p><strong>两端锁协议</strong>：加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件。</p></li></ol><h4 id="四、事务的隔离级别"><a href="#四、事务的隔离级别" class="headerlink" title="四、事务的隔离级别"></a>四、事务的隔离级别</h4><ol><li><p><strong>读未提交（READ UNCOMMITTED）</strong></p><p>一个事务可以读取到另一个事务没有提交的数据。无法避免任何一种情况。</p></li><li><p><strong>读提交（READ COMMITTED）</strong></p><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。可以解决脏读。</p></li><li><p><strong>可重复读（REPEATABLE READ）</strong></p><p>保证在同一个事务中多次读取同一数据的结果是一样的。可以解决不可重复读。</p></li><li><p><strong>序列化（SERIALIZABLE）</strong></p><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p><p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p></li></ol><h4 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h4><h4 id="六、关系数据库设计理论"><a href="#六、关系数据库设计理论" class="headerlink" title="六、关系数据库设计理论"></a>六、关系数据库设计理论</h4><p><strong>数据库三大范式：</strong></p><ul><li><strong>属性不可分</strong>：每一列属性都是不可再分的属性值，确保每一列的原子性，两列属性相近或一样，尽量合并属性一样的列，确保不产生冗余数据。</li><li>每一行的数据只能与其中一列相关，一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。</li><li>数据不能存在传递关系，每个属性都与主键有直接关系而不是间接关系。</li></ul><h4 id="七、常见问题"><a href="#七、常见问题" class="headerlink" title="七、常见问题"></a>七、常见问题</h4><ol><li><p><strong>数据库索引用过哪些，什么情况失效？</strong></p><p>主键索引（聚簇索引）、普通索引、唯一索引、全文索引</p><p>where 语句中使用or，但是没有把or中的所有字段都加上索引，索引失效。</p></li></ol><p>　　where 语句使用&lt;&gt;和!=</p><p>　　like查询以“%…”开头</p><p>　　如果mysql估计全表扫描更快的话</p><ol start="2"><li><p><strong>LIMIT M, N</strong> </p><p>LIMIT 给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目（初始记录行的偏移量是 0而不是 1)。</p><p>LIMIT M 等价于LIMIT 0, M</p></li><li><p><strong>drop和delete的区别</strong></p><p>delete 删除的是 <strong>数据，</strong>drop语句删除表结构及所有数据，并将表所占用的空间全部释放</p></li></ol><p>　　delete会触发触发器，drop不会触发触发器；</p><ol start="4"><li><p><strong>数据库事务的应用场景</strong></p><p>在执行一系列数据库操作时，要保证这些操作必须完全正确执行，否则就不执行，在这种情况下，适合使用事务，例如将一些数据插入到两个相关联的表中，而且不能只有一张表插入成功，这种情况下，使用事务，无论是否插入成功，都不会对数据库造成不好的影响。</p></li><li><p><strong>数据库索引的创建原则</strong></p><p>表的主键、外键必须有索引;</p><p>经常查询的数据列最好建立索引</p><p>对于需要在指定范围内的快速或频繁查询的数据列;</p><p>经常用在WHERE子句中的数据列。</p><p>经常出现在关键字order by、group by、distinct后面的字段，建立索引。如果建立的是复合索引，索引的字段顺序要和这些关键字后面的字段顺序一致，否则索引不会被使用。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、事务&quot;&gt;&lt;a href=&quot;#一、事务&quot; class=&quot;headerlink&quot; title=&quot;一、事务&quot;&gt;&lt;/a&gt;一、事务&lt;/h4&gt;&lt;p&gt;事务指的是满足ACID的一组操作，它可以通过Commit提交一个事务，也可以使用Rollback进行回滚。&lt;/p&gt;
&lt;ol&gt;</summary>
      
    
    
    
    <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>MySql数据库面试问题</title>
    <link href="http://yoursite.com/2020/08/13/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2020/08/13/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2020-08-13T13:22:53.000Z</published>
    <updated>2020-08-15T14:18:39.066Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-说一说MySQL中的索引"><a href="#1-说一说MySQL中的索引" class="headerlink" title="1.说一说MySQL中的索引"></a>1.说一说MySQL中的索引</h4><p>​    MySQL数据库的索引是用B+树实现的。在B+树中非叶节点只存储关键字和指针（可以存储更多的关键字，降低树高），叶子节点存储关键字和数据。相邻的叶子节点间有指针连接，范围查找更为快速。通过B+树索引进行查找的时间复杂度为树高，一般是2~4次。<strong>（数据结构）</strong></p><p>​    MySQL数据库中的索引有两种：聚集索引、稀疏索引。其中聚集索引的叶子节点会存储实际表中真实的数据，一个表只能有一个聚集索引，而稀疏索引的叶子节点存储的是主键的值。也就是说，通过稀疏索引进行查找，首先会查询稀疏索引树，找到符合条件的聚集索引的关键字，然后用该关键字在聚集索引树中进行查找，找到最终的数据。</p><p>​    MySQL数据库中InnoDB引擎主索引是聚集索引，叶子的value存储真实数据，辅助索引是稀疏索引，叶子节点value存储主键的值；而Myisam引擎主索引和辅助索引都是稀疏索引，两者没有任何区别（value都存储数据的地址）。</p><h4 id="2-为什么MySQL索引使用B-树，不是B树"><a href="#2-为什么MySQL索引使用B-树，不是B树" class="headerlink" title="2.为什么MySQL索引使用B+树，不是B树"></a>2.为什么MySQL索引使用B+树，不是B树</h4><p>​    B+树是B树的变种，B+树中非叶节点只用来保存索引（关键字和指针），不储存数据，所有的数据存储在叶子节点上；而B树中的非叶节点会保存数据，这样使得B+树的查询效率更加稳定，均是从根节点到叶子节点。</p><p>​    B+树非叶节点不存储数据，所以可以存储更多的关键字，使得B+树查找的磁盘IO数更少。</p><p>​    B+树相邻的叶子节点间有指针连接，范围查询更为有利。</p><h4 id="3-为什么推荐采用自增主键"><a href="#3-为什么推荐采用自增主键" class="headerlink" title="3.为什么推荐采用自增主键"></a>3.为什么推荐采用自增主键</h4><p>​    InnoDB推荐使用自增列作为主键，这样可以提高存取速度。因为如果InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的。</p><h4 id="4-MySQL常见的存储引擎有哪些"><a href="#4-MySQL常见的存储引擎有哪些" class="headerlink" title="4.MySQL常见的存储引擎有哪些"></a>4.MySQL常见的存储引擎有哪些</h4><p>​    MySQL中常见的存储引擎有InnoDB和MyISAM，主要区别是：</p><ul><li>MyISAM不支持事务；InnoDB是事务类型的存储引擎。</li><li>MyISAM只支持表级锁；InnoDB支持行级锁和表级锁，默认为行级锁。</li><li>MyISAM引擎不支持外键；InnoDB支持外键。</li><li>MyISAM支持全文索引（FULLTEXT）；InnoDB不支持。</li><li>MyISAM索引都是是稀疏索引，叶子节点存储真实数据的指针，数据和索引分离；InnoDB采用聚集索引，真实数据在聚集的叶子节点上，辅助索引是稀疏索引，叶子节点存储主键值。</li></ul><h4 id="5-MySQL中where、group-by、having关键字"><a href="#5-MySQL中where、group-by、having关键字" class="headerlink" title="5.MySQL中where、group by、having关键字"></a>5.MySQL中where、group by、having关键字</h4><ul><li>where子句用来筛选from子句中指定的操作所产生的的<strong>行</strong></li><li>group by 子句用来<strong>分组</strong>where子句的输出</li><li>having子句用来从分组的结果中<strong>筛选组</strong></li></ul><p><strong>where和having的区别</strong>：where 是group by之前进行筛选，筛选的是行，having是group by 之后进行统计的筛选，筛选的是组。</p><p><strong>执行顺序</strong>：执行where子句查找符合条件的数据 &gt; 使用group by 子句对数据进行分组 &gt;对group by 子句形成的组运行聚集函数计算每一组的值&gt;最后用having 子句去掉不符合条件的组</p><h4 id="6-索引的最左前缀原则"><a href="#6-索引的最左前缀原则" class="headerlink" title="6.索引的最左前缀原则"></a>6.索引的最左前缀原则</h4><p>​    在联合索引的情况下，不需要索引的全部定义，只要满足最左前缀，就可以利用索引来加快查询速度。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。最左前缀原则的利用也可以显著提高查询效率，是常见的MySQL性能优化手段。</p><p>​    如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name&#x3D;xx and city&#x3D;xx ; ／／可以命中索引</span><br><span class="line">select * from user where name&#x3D;xx ; &#x2F;&#x2F; 可以命中索引</span><br><span class="line">select * from user where city&#x3D;xx ; &#x2F;&#x2F; 无法命中索引            </span><br></pre></td></tr></table></figure><pre><code> 这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 `city= xx and name ＝xx`，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。</code></pre><h4 id="7-那些列上适合建立索引，对性能有何开销"><a href="#7-那些列上适合建立索引，对性能有何开销" class="headerlink" title="7.那些列上适合建立索引，对性能有何开销"></a>7.那些列上适合建立索引，对性能有何开销</h4><p>​    主键、外键必须有索引。</p><p>​    经常需要作为（where）条件查询的列上适合创建索引，并且该列上也必须有一定的区分度。创建索引需要维护，在插入数据的时候会重新维护各个索引树（<strong>数据页的分裂与合并</strong>），对性能造成影响。</p><h4 id="8-“行级锁什么时候会锁住整个表？“"><a href="#8-“行级锁什么时候会锁住整个表？“" class="headerlink" title="8.“行级锁什么时候会锁住整个表？“"></a>8.“行级锁什么时候会锁住整个表？“</h4><p>​    InnoDB行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。</p><h4 id="9-MySQL中建表的约束"><a href="#9-MySQL中建表的约束" class="headerlink" title="9.MySQL中建表的约束"></a>9.MySQL中建表的约束</h4><ul><li>主键约束：唯一性，非空性</li><li>唯一约束：唯一性，可以空，但只能有一个</li><li>检查约束：对该列数据的范围、格式的限制</li><li>默认约束：该数据的默认值</li><li>外键约束：需要建立两表间的关系并引用主表的列</li></ul><h4 id="10-SQL语句的优化有哪些？"><a href="#10-SQL语句的优化有哪些？" class="headerlink" title="10.SQL语句的优化有哪些？"></a>10.SQL语句的优化有哪些？</h4><ul><li>为经常使用的字段（排序、搜索）建立索引</li><li>字段的种类尽可能用int 或者tinyint类型。另外字段尽可能用NOT NULL。</li><li>select * 尽量少用，你想要什么字段 就select 什么字段出来 不要老是用* 号！同理，只要一行数据时尽量使用 LIMIT 1</li></ul><h4 id="11-order-by是怎么工作的？"><a href="#11-order-by是怎么工作的？" class="headerlink" title="11.order by是怎么工作的？"></a>11.order by是怎么工作的？</h4><p>​    ORDER BY 语句用于对结果集进行排序。以下面的语句进行分析：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span> ;</span><br></pre></td></tr></table></figure><p>city字段建立了索引，过程如下：</p><ul><li><p>初始化 sort_buffer, 确认放入 name, city, age 这三个字段。</p></li><li><p>从索引 city 找到第一个满足 city=’杭州’条件的主键 id。</p></li><li><p>回表取到 name, city, age 三个字段值，存入 sort_buffer 中。</p></li><li><p>从索引 city 取下一个主键 id 记录。</p></li><li><p>重复 3-4 步骤，直到 city 不满足条件。</p></li><li><p>对 sort_buffer 中的数据按照字段 name 做快速排序。</p></li><li><p>排序结果取前 1000 行返回给客户端。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-说一说MySQL中的索引&quot;&gt;&lt;a href=&quot;#1-说一说MySQL中的索引&quot; class=&quot;headerlink&quot; title=&quot;1.说一说MySQL中的索引&quot;&gt;&lt;/a&gt;1.说一说MySQL中的索引&lt;/h4&gt;&lt;p&gt;​    MySQL数据库的索引是用B+树实</summary>
      
    
    
    
    <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis缓存雪崩、穿透、击穿</title>
    <link href="http://yoursite.com/2020/08/13/Redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF/"/>
    <id>http://yoursite.com/2020/08/13/Redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF/</id>
    <published>2020-08-13T13:22:53.000Z</published>
    <updated>2020-08-15T14:18:45.548Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-缓存雪崩了解吗"><a href="#1-缓存雪崩了解吗" class="headerlink" title="1.缓存雪崩了解吗"></a>1.缓存雪崩了解吗</h4><p>​    Redis中数据同一时刻大面积失效，那一瞬间Redis和没有一样，此时如果存在大量请求，会直接打到MySql数据库上，MySql数据库会瘫痪，无法提供服务，整个系统就崩掉了。</p><p><strong>如何应对呢？</strong></p><p>​    处理缓存雪崩很简单，在批量往Redis存数据的时候，把每个key的失效时间加个随机值就好了，保证数据在同一时刻不会大面积失效，数据库负担过重。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setRedis（Key，value，time + Math.random() * 10000）;</span><br></pre></td></tr></table></figure><p>​    如果Redis时集群部署，可以将热点数据均匀分散到各个Redis库中，避免全部失效。</p><p>​    也可以设置热点数据永不过期，更新时覆盖即可。</p><h4 id="2-缓存穿透、击穿"><a href="#2-缓存穿透、击穿" class="headerlink" title="2.缓存穿透、击穿"></a>2.缓存穿透、击穿</h4><p>​    缓存穿透是指缓存和数据库中都没有的数据，而用户在不断的发送请求。此时的用户很有可能是攻击者，会导致数据库压力过大。（先查缓存，没有就去数据库查）</p><p><strong>如何解决呢？</strong></p><ul><li><p>增加校验，拦截不合理的请求。</p></li><li><p>从缓存和数据库都取不到的数据，可以在缓存中添加key对应valu为null的一条数据，有效时间可以设置短点</p></li></ul><p>​    缓存击穿和缓存雪崩类似，但有点不同。缓存击穿指的是有一个key非常热点，在不停的扛着大并发，在该key失效的一瞬间，会有大量请求击穿缓存打到数据库，导致数据库负担过重。</p><p><strong>如何解决呢？</strong></p><ul><li>设置热点数据永不过期</li><li>加上互斥锁</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-缓存雪崩了解吗&quot;&gt;&lt;a href=&quot;#1-缓存雪崩了解吗&quot; class=&quot;headerlink&quot; title=&quot;1.缓存雪崩了解吗&quot;&gt;&lt;/a&gt;1.缓存雪崩了解吗&lt;/h4&gt;&lt;p&gt;​    Redis中数据同一时刻大面积失效，那一瞬间Redis和没有一样，此时如果</summary>
      
    
    
    
    <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
  </entry>
  
</feed>
