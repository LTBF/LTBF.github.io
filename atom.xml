<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Like Wind</title>
  
  <subtitle>不积跬步，无以至千里；不积小流，无以成江海</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-05T07:29:59.959Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>NTJD</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>百度后台开发笔试</title>
    <link href="http://yoursite.com/2021/09/03/%E7%99%BE%E5%BA%A6%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%AC%94%E8%AF%95/"/>
    <id>http://yoursite.com/2021/09/03/%E7%99%BE%E5%BA%A6%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E7%AC%94%E8%AF%95/</id>
    <published>2021-09-02T16:00:00.000Z</published>
    <updated>2020-09-05T07:29:59.959Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-一个长为n的正整数数组，里面的每个元素不是0就是5。从数组中选出若干数字组成一个数字，要求能整除90。求满足条件的最大的数字，不存在就输出-1。"><a href="#1-一个长为n的正整数数组，里面的每个元素不是0就是5。从数组中选出若干数字组成一个数字，要求能整除90。求满足条件的最大的数字，不存在就输出-1。" class="headerlink" title="1.一个长为n的正整数数组，里面的每个元素不是0就是5。从数组中选出若干数字组成一个数字，要求能整除90。求满足条件的最大的数字，不存在就输出-1。"></a>1.一个长为n的正整数数组，里面的每个元素不是0就是5。从数组中选出若干数字组成一个数字，要求能整除90。求满足条件的最大的数字，不存在就输出-1。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">12</span><br><span class="line">5 5 5 5 5 5 0 0 5 5 5 5</span><br><span class="line">输出：</span><br><span class="line">55555555500</span><br></pre></td></tr></table></figure><ul><li><p>数字能整除90—&gt;能整除10，结果还能整除9</p></li><li><p>一个数字能整除9—&gt;每位之和能整除90</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">        <span class="keyword">int</span> fiveNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> zeroNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(scan.nextInt() == <span class="number">5</span>)&#123;</span><br><span class="line">                fiveNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                zeroNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个0都不存在时</span></span><br><span class="line">        <span class="keyword">if</span>(zeroNum == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5可以最多出现几次</span></span><br><span class="line">        <span class="keyword">while</span>(fiveNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((fiveNum * <span class="number">5</span>) % <span class="number">9</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fiveNum--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5一次都没有</span></span><br><span class="line">        <span class="keyword">if</span>(fiveNum == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以有fiveNum个5，zeroNum个0，毫无疑问5在前0在后</span></span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(fiveNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            s += <span class="string">&quot;5&quot;</span>;</span><br><span class="line">            fiveNum--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(zeroNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            s += <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            zeroNum--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-有n头奶牛，每头奶牛进行m项测评，所有测评都通过的是优质奶牛。"><a href="#2-有n头奶牛，每头奶牛进行m项测评，所有测评都通过的是优质奶牛。" class="headerlink" title="2.有n头奶牛，每头奶牛进行m项测评，所有测评都通过的是优质奶牛。"></a>2.有n头奶牛，每头奶牛进行m项测评，所有测评都通过的是优质奶牛。</h4><p>注意区间的重合问题。但是不知道什么原因一直超时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T = scan.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(T-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> n = scan.nextInt(), m = scan.nextInt();   <span class="comment">// 奶牛数，资质数</span></span><br><span class="line">            <span class="keyword">int</span>[] ct = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;   <span class="comment">// 每种资质下有k个区间满足</span></span><br><span class="line">                Arrays.fill(visited, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">int</span> k = scan.nextInt();   <span class="comment">// 区间数</span></span><br><span class="line">                <span class="keyword">while</span>(k-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> l = scan.nextInt(), r = scan.nextInt();  <span class="comment">// 区间开始结束</span></span><br><span class="line">                    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(visited[l])&#123;   <span class="comment">// 去重</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ct[l]++;</span><br><span class="line">                        visited[l] = <span class="keyword">true</span>;</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ct[i] == m)&#123;</span><br><span class="line">                    list.add(i+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">            <span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">                System.out.print(s + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-有n阶台阶，每次可以跨1-m步，要求每次跨的步数与前两次都不同。求登顶的次数"><a href="#3-有n阶台阶，每次可以跨1-m步，要求每次跨的步数与前两次都不同。求登顶的次数" class="headerlink" title="3.有n阶台阶，每次可以跨1-m步，要求每次跨的步数与前两次都不同。求登顶的次数"></a>3.<a href="https://blog.csdn.net/qq_35590091/article/details/108403940">有n阶台阶，每次可以跨1-m步，要求每次跨的步数与前两次都不同。求登顶的次数</a></h4><p>还有一种解法dp[i][j][k]表示到达k前两步分别为j,k的方案数，用动态规划解决。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Three &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; scan.nextInt(), m &#x3D; scan.nextInt();</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int ct &#x3D; backtracking(0, -1, -1, n, m, map);</span><br><span class="line"></span><br><span class="line">        System.out.println(ct);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int backtracking(int lastLast, int last, int cur, int n, int m, Map&lt;String, Integer&gt; map) &#123;</span><br><span class="line"></span><br><span class="line">        if(cur &#x3D;&#x3D; n)&#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(cur &gt; n)&#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String str &#x3D; lastLast + &quot;-&quot; + last + &quot;_&quot; + cur;</span><br><span class="line">        if(map.containsKey(str))&#123;</span><br><span class="line">            return map.get(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ct &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; m; i++)&#123;</span><br><span class="line">            ct +&#x3D; backtracking(last, i, cur+i, n, m, map);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ct %&#x3D;1000000007;</span><br><span class="line"></span><br><span class="line">        map.put(str, ct);</span><br><span class="line">        return ct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-一个长为n的正整数数组，里面的每个元素不是0就是5。从数组中选出若干数字组成一个数字，要求能整除90。求满足条件的最大的数字，不存在就输出-1。&quot;&gt;&lt;a href=&quot;#1-一个长为n的正整数数组，里面的每个元素不是0就是5。从数组中选出若干数字组成一个数字，要</summary>
      
    
    
    
    <category term="笔试" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AF%95/"/>
    
    
    <category term="百度" scheme="http://yoursite.com/tags/%E7%99%BE%E5%BA%A6/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java实现消费者-生产者模式</title>
    <link href="http://yoursite.com/2020/09/06/Java%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/09/06/Java%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</id>
    <published>2020-09-05T16:00:00.000Z</published>
    <updated>2020-09-06T09:29:15.420Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-生产者-消费者者模式"><a href="#1-生产者-消费者者模式" class="headerlink" title="1. 生产者-消费者者模式"></a>1. 生产者-消费者者模式</h4><p>生产者-消费者模式是并发场景下非常经典的设计模式。生产者用于生产物品，消费者消费生产者生产的物品。在Java中可以多种实现方式：</p><ul><li>synchronized锁</li><li>ReentrantLock锁</li><li>BlockingQueue阻塞队列</li><li>PipedInputStream/PipedOutputStream管道</li><li>Semaphore信号量</li></ul><h4 id="2-synchronized实现生产者-消费者"><a href="#2-synchronized实现生产者-消费者" class="headerlink" title="2. synchronized实现生产者-消费者"></a>2. synchronized实现生产者-消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> productNum;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ct;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(productNum == capacity)&#123;</span><br><span class="line">            notifyAll();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        productNum++;</span><br><span class="line">        ct++;</span><br><span class="line">        System.out.println(ct+<span class="string">&quot;生产一个商品：&quot;</span> + productNum + <span class="string">&quot; &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(productNum == <span class="number">0</span>) &#123;</span><br><span class="line">            notifyAll();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        productNum--;</span><br><span class="line">        ct++;</span><br><span class="line">        System.out.println(ct + <span class="string">&quot;消费一个商品：&quot;</span> + productNum + <span class="string">&quot; &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        One one = <span class="keyword">new</span> One();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    one.produce();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;P&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    one.consume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;C&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的刚开始唤醒线程用的是notify方法，会出现线程一直阻塞无法推进的问题。原因是notify是随机唤醒一个阻塞的线程，如果在执行的某个时刻，productNum = 0而且生产线程全部是Runnable状态，此时会有一个消费线程处于Blocked状态。结果显然易见，会出现死循环，两个消费线程相互唤醒阻塞。</p><p>synchronized锁编写起来非常简单，但是消费线程和生产线程会处于一个等待队列，他们的等待条件相同，而ReentrantLock可以指定等待条件。</p><h4 id="2-ReentrantLock实现生产者-消费者模式"><a href="#2-ReentrantLock实现生产者-消费者模式" class="headerlink" title="2. ReentrantLock实现生产者-消费者模式"></a>2. ReentrantLock实现生产者-消费者模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> productNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ct;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();    <span class="comment">// 生产者生产</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();   <span class="comment">// 消费者消费</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span>(productNum == capacity)&#123;</span><br><span class="line">                notEmpty.signal();   <span class="comment">// 唤醒一个消费线程</span></span><br><span class="line">                notFull.await();     <span class="comment">// 挂起当前生产线程</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            productNum++;</span><br><span class="line">            ct++;</span><br><span class="line">            System.out.println(ct+<span class="string">&quot;生产一个商品：&quot;</span> + productNum + <span class="string">&quot; &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">            notEmpty.signal();    <span class="comment">// 唤醒一个消费线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(productNum == <span class="number">0</span>)&#123;</span><br><span class="line">                notFull.signal();    <span class="comment">// 唤醒一个生产线程</span></span><br><span class="line">                notEmpty.await();    <span class="comment">// 挂起当前消费线程</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            productNum--;</span><br><span class="line">            ct++;</span><br><span class="line">            System.out.println(ct+<span class="string">&quot;消费一个商品：&quot;</span> + productNum + <span class="string">&quot; &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;获得锁&quot;</span>);</span><br><span class="line">            notFull.signal();    <span class="comment">// 唤醒一个生产线程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Two two = <span class="keyword">new</span> Two();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    two.produce();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;P&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    two.consume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;C&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-BlockingQueue实现生产者-消费者模式"><a href="#3-BlockingQueue实现生产者-消费者模式" class="headerlink" title="3. BlockingQueue实现生产者-消费者模式"></a>3. BlockingQueue实现生产者-消费者模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Three</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            blockingQueue.put(<span class="number">1</span>);;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 生产一个物品:&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            blockingQueue.take();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 消费一个物品&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Three three = <span class="keyword">new</span> Three();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    three.produce();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;P&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    three.consume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;C&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阻塞队列：当队列为满时，阻塞当前生产者线程，唤醒消费者线程；当队列为空的时候，阻塞当前消费者线程，唤醒生产者线程。</p><h4 id="4-管道输入输出流PipedInputStream和PipedOutputStream实现生产者-消费者模式"><a href="#4-管道输入输出流PipedInputStream和PipedOutputStream实现生产者-消费者模式" class="headerlink" title="4.管道输入输出流PipedInputStream和PipedOutputStream实现生产者-消费者模式"></a>4.管道输入输出流PipedInputStream和PipedOutputStream实现生产者-消费者模式</h4><p>使用方法：先创建一个管道输入流和管道输出流，然后将输入流和输出流进行连接，用生产者线程往管道输出流中写入数据，消费者在管道输入流中读取数据，这样就可以实现了不同线程间的相互通讯，但是这种方式在生产者和生产者、消费者和消费者之间不能保证同步，也就是说在一个生产者和一个消费者的情况下是可以生产者和消费者之间交替运行的，多个生成者和多个消费者者之间则不行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Four</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PipedInputStream input = <span class="keyword">new</span> PipedInputStream();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PipedOutputStream output = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Four</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            input.connect(output);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> t = (<span class="keyword">int</span>)(Math.random() * <span class="number">255</span>);</span><br><span class="line">            output.write(t);</span><br><span class="line">            output.flush();</span><br><span class="line">            System.out.println(<span class="string">&quot;生产一个商品&quot;</span> + t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> t = input.read();</span><br><span class="line">            System.out.println(<span class="string">&quot;消费一个商品&quot;</span> + t);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Four four = <span class="keyword">new</span> Four();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">                    four.produce();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">                    four.consume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            four.input.close();</span><br><span class="line">            four.output.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-Semaphore实现生产者-消费者模式"><a href="#5-Semaphore实现生产者-消费者模式" class="headerlink" title="5. Semaphore实现生产者-消费者模式"></a>5. Semaphore实现生产者-消费者模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Five</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> productNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore notFull = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore notEmpty = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            notFull.acquire();</span><br><span class="line">            mutex.acquire();</span><br><span class="line">            productNum++;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产一个商品&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            mutex.release();</span><br><span class="line">            notEmpty.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            notEmpty.acquire();</span><br><span class="line">            mutex.acquire();</span><br><span class="line">            productNum--;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费一个商品&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            mutex.release();</span><br><span class="line">            notFull.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Five five = <span class="keyword">new</span> Five();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    five.produce();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;P&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    five.consume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="string">&quot;C&quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-生产者-消费者者模式&quot;&gt;&lt;a href=&quot;#1-生产者-消费者者模式&quot; class=&quot;headerlink&quot; title=&quot;1. 生产者-消费者者模式&quot;&gt;&lt;/a&gt;1. 生产者-消费者者模式&lt;/h4&gt;&lt;p&gt;生产者-消费者模式是并发场景下非常经典的设计模式。生产者</summary>
      
    
    
    
    <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>美团8.29后端笔试</title>
    <link href="http://yoursite.com/2020/08/30/%E7%BE%8E%E5%9B%A28.29%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AF%95/"/>
    <id>http://yoursite.com/2020/08/30/%E7%BE%8E%E5%9B%A28.29%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AF%95/</id>
    <published>2020-08-29T16:00:00.000Z</published>
    <updated>2020-08-30T12:21:44.248Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-小团的神秘暗号"><a href="#1-小团的神秘暗号" class="headerlink" title="1. 小团的神秘暗号"></a>1. 小团的神秘暗号</h3><p>一字符串为其加上一个头部和尾部进行加密。头部至少包含一个“MT”的子序列，且以T结尾。尾部至少包含一个“MT”的子序列，且以M开始。求得取出头部、尾部后的最大字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">10</span></span><br><span class="line">MMATSATMMT</span><br><span class="line">输出：</span><br><span class="line">SATM</span><br></pre></td></tr></table></figure><p>送分题，找出最靠前的头部和最靠后的尾部，剩下的就是最长的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n = Integer.valueOf(scan.nextLine());</span><br><span class="line">    String str = scan.nextLine();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, end = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag1 = <span class="keyword">false</span>, flag2 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">            flag1 = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;T&#x27;</span> &amp;&amp; flag1)&#123;</span><br><span class="line">            start = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">            flag2 = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) == <span class="string">&#x27;M&#x27;</span> &amp;&amp; flag2)&#123;</span><br><span class="line">            end = i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(str.substring(start, end+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-小团的选调计划"><a href="#2-小团的选调计划" class="headerlink" title="2. 小团的选调计划"></a>2. 小团的选调计划</h3><p>有n个人编号1-n，有n个任务，编号1-n。每个人可以填写选择任务的志愿，编号小的优先被满足。求出每个人最终分配的任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">1 5 3 4 2</span><br><span class="line">2 3 5 4 1</span><br><span class="line">5 4 1 2 3</span><br><span class="line">1 2 5 4 3</span><br><span class="line">1 4 5 2 3</span><br><span class="line">输出：</span><br><span class="line">1 2 5 4 3</span><br></pre></td></tr></table></figure><p>送分题，记录任务的领取状况，按人员编号从小到大，依次按其志愿领取任务未领取的任务。‘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">    int n &#x3D; scan.nextInt();</span><br><span class="line">    int[][] nums &#x3D; new int[n][n];</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++)&#123;</span><br><span class="line">            nums[i][j] &#x3D; scan.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean[] selected &#x3D; new boolean[n+1];</span><br><span class="line">    int[] res &#x3D; new int[n];</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">        for(int j &#x3D; 0; j &lt; n; j++)&#123;</span><br><span class="line">            if(!selected[nums[i][j]])&#123;</span><br><span class="line">                selected[nums[i][j]] &#x3D; true;</span><br><span class="line">                res[i] &#x3D; nums[i][j];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(int m : res)&#123;</span><br><span class="line">        System.out.print(m+&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-小团无路可逃"><a href="#3-小团无路可逃" class="headerlink" title="3. 小团无路可逃"></a>3. 小团无路可逃</h3><p>有一颗树，小团位于y位置，小美位于x位置。小美要追打小团，每次小美和小团可以向相邻位置转移（小团可以不动）。问最多多久小美可以追上小团。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 1 2</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">4 2</span><br><span class="line">5 3</span><br><span class="line">输出：</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>求出小美距所有节点的最短距离[dx1, dx2, …]，小团距所欲节点的最短距离[dy1, dy2, …]。则问题的结果是满足dx<sub>i</sub> &gt; dy<sub>i</sub>的最大dx<sub>i</sub>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">    int n &#x3D; scan.nextInt(), x &#x3D; scan.nextInt(), y &#x3D; scan.nextInt();</span><br><span class="line">    List&lt;Integer&gt;[] lists &#x3D; new List[n+1];</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n-1; i++)&#123;</span><br><span class="line">        int u &#x3D; scan.nextInt(), v &#x3D; scan.nextInt();</span><br><span class="line">        lists[u] &#x3D; lists[u] &#x3D;&#x3D; null ? new ArrayList&lt;&gt;() : lists[u];</span><br><span class="line">        lists[v] &#x3D; lists[v] &#x3D;&#x3D; null ? new ArrayList&lt;&gt;() : lists[v];</span><br><span class="line">        lists[u].add(v);</span><br><span class="line">        lists[v].add(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[] dist1 &#x3D; getDistance(x, n, lists);</span><br><span class="line">    int[] dist2 &#x3D; getDistance(y, n, lists);</span><br><span class="line"></span><br><span class="line">    int res &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">        if(dist1[i] &gt; dist2[i])&#123;</span><br><span class="line">            res &#x3D; Math.max(res, dist1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(res);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 迪杰斯特拉算法求单源最短路径(还可以通过BFS算法求)</span><br><span class="line">private static int[] getDistance(int start, int n, List&lt;Integer&gt;[] lists) &#123;</span><br><span class="line"></span><br><span class="line">    int[] dist &#x3D; new int[n+1];    &#x2F;&#x2F; 节点编号1-n</span><br><span class="line">    boolean[] flag &#x3D; new boolean[n+1];</span><br><span class="line">    Arrays.fill(dist, -1);    &#x2F;&#x2F; -1 代表不可达</span><br><span class="line"></span><br><span class="line">    if(lists[start] &#x3D;&#x3D; null)&#123;</span><br><span class="line">        return dist;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int next : lists[start])&#123;</span><br><span class="line">        dist[next] &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    flag[start] &#x3D; true;</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">        &#x2F;&#x2F; 找出下一个最近距离节点</span><br><span class="line">        int min &#x3D; 0;    &#x2F;&#x2F; 初始</span><br><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; n; j++)&#123;</span><br><span class="line">            if(!flag[j] &amp;&amp; dist[j] !&#x3D; -1)&#123;    &#x2F;&#x2F; 节点j尚未求出最短距离，且节点j目前可达</span><br><span class="line">                min &#x3D; min &#x3D;&#x3D; 0 ? j : dist[min] &gt; dist[j] ? j : min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag[min] &#x3D; true;    &#x2F;&#x2F; min节点加入最终集和</span><br><span class="line">        for(int next : lists[min])&#123;    &#x2F;&#x2F; 通过min,更新未求出最短距离的节点</span><br><span class="line">            if(!flag[next])&#123;</span><br><span class="line">                if(dist[next] &#x3D;&#x3D; -1)&#123;</span><br><span class="line">                    dist[next] &#x3D; dist[min] + 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    dist[next] &#x3D; Math.min(dist[next], dist[min] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dist;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-小团的默契游戏"><a href="#3-小团的默契游戏" class="headerlink" title="3. 小团的默契游戏"></a>3. 小团的默契游戏</h3><p>一个长为n的整数数组，最大值不超过m。给一个组合(l, r)，使得按序取数组中满足a[i]&lt;l或a[i]&gt;r组成的数组是单调不下降的。其中1&lt;=l&lt;=r&lt;=m。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 5</span><br><span class="line">4 1 4 1 2</span><br><span class="line">输出：</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>最简单的方式是通过三层循环解决该问题，但仔细分析可以发现一下规律：</p><ul><li>若(l, r)满足，则(l, r+1)肯定满足</li><li>若(l, r)满足，则(l+1, <em>)满足的话，只能是\</em>&gt;=r</li></ul><p>通过这两点可以进行充分的剪枝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">    int m &#x3D; scan.nextInt(), n &#x3D; scan.nextInt();</span><br><span class="line">    int[] nums &#x3D; new int[n];</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">        nums[i] &#x3D; scan.nextInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int ct &#x3D; 0;</span><br><span class="line">    int l, r, i;</span><br><span class="line">    int star &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 虽然n的数量级时10^5, 但加入了两处剪枝后，可以大幅降低时间复杂度</span><br><span class="line">    for(l &#x3D; 1; l &lt;&#x3D; m; l++)&#123;</span><br><span class="line">        for(r &#x3D; star; r &lt;&#x3D; m; r++)&#123;   &#x2F;&#x2F; l时的r必然是l-1时r的子集---第二处剪枝</span><br><span class="line">            int pre &#x3D; 0;</span><br><span class="line">            for(i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">                if(nums[i] &lt; l || nums[i] &gt; r)&#123;</span><br><span class="line">                    if(nums[i] &lt; pre)&#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre &#x3D; nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(i &#x3D;&#x3D; n)&#123;   &#x2F;&#x2F; 子序列是非降序排列---第一处剪枝-1</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(r &lt;&#x3D; m)&#123;   &#x2F;&#x2F; [r, m]必然满足---第一处剪枝-2</span><br><span class="line">            ct +&#x3D; m - r + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        star &#x3D; r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(ct);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-小团的神秘暗号&quot;&gt;&lt;a href=&quot;#1-小团的神秘暗号&quot; class=&quot;headerlink&quot; title=&quot;1. 小团的神秘暗号&quot;&gt;&lt;/a&gt;1. 小团的神秘暗号&lt;/h3&gt;&lt;p&gt;一字符串为其加上一个头部和尾部进行加密。头部至少包含一个“MT”的子序列，且以T</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
    <category term="美团" scheme="http://yoursite.com/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>Redis系列之缓存不一致</title>
    <link href="http://yoursite.com/2020/08/30/Redis%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
    <id>http://yoursite.com/2020/08/30/Redis%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BC%93%E5%AD%98%E4%B8%8D%E4%B8%80%E8%87%B4/</id>
    <published>2020-08-29T16:00:00.000Z</published>
    <updated>2020-08-30T13:39:41.269Z</updated>
    
    <content type="html"><![CDATA[<p>缓存不一致指的是缓存中的数据与数据库中的数据发生了不一致的情况。一般常用的缓存方案有两种：</p><p><strong>方案一：</strong></p><ul><li>读的时候，先读缓存，缓存没有的话，读数据库，取出数据后放入缓存，同时返回响应。</li><li>更新的时候，先删除缓存，再更新数据库</li></ul><p><strong>方案二：</strong></p><ul><li>读的时候，先读缓存，缓存没有的话，读数据库，取出数据后放入缓存，同时返回响应。</li><li>更新的时候，先更新数据库，再删除缓存</li></ul><p><strong>两种方案数据库缓存不一致发生的场景：</strong></p><ul><li>方案一：T1删除缓存-&gt;T2读缓存(没有)，读数据库，并放入缓存-&gt;T1更新数据库</li><li>方案二：T1读缓存(没有)，读数据库-&gt;T2更新数据库，删除缓存-&gt;T1放入缓存</li></ul><p><strong>解决方案：</strong></p><p>一般来说，我们对缓存的一致性要求并没有很高，只要求最终一致性，在较短的时间内不一致都是能忍受的。不论是前面哪一种方案，就算发生了，再来一次更新请求只要不发生同样的情况，缓存都会被再次刷成一致的。所以解决方案从简易到复杂就有缓存过期时间兜底，保证“更新数据库、删除缓存”和“读数据库并设置缓存”的之间串行化。</p><ul><li><p>缓存过期时间兜底</p><p>就算更新操作非常少，没有更新操作，也有一个缓存过期时间，在缓存过期之后再次刷新缓存。</p></li><li><p>读若未命中，将读并放入缓存操作放入该线程的队列；更新操作也放入该线程的队列</p></li><li><p>更新操作执行后，向MQ发消息置缓存失效。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;缓存不一致指的是缓存中的数据与数据库中的数据发生了不一致的情况。一般常用的缓存方案有两种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案一：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读的时候，先读缓存，缓存没有的话，读数据库，取出数据后放入缓存，同时返回响应。&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
    <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动2021后端笔试第二场08.16</title>
    <link href="http://yoursite.com/2020/08/16/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A82021%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%9C%BA08.16/"/>
    <id>http://yoursite.com/2020/08/16/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A82021%E5%90%8E%E7%AB%AF%E7%AC%94%E8%AF%95%E7%AC%AC%E4%BA%8C%E5%9C%BA08.16/</id>
    <published>2020-08-15T16:00:00.000Z</published>
    <updated>2020-08-16T08:51:50.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-统计二叉树中的叶子节点数"><a href="#1-统计二叉树中的叶子节点数" class="headerlink" title="1. 统计二叉树中的叶子节点数"></a>1. 统计二叉树中的叶子节点数</h3><p>给出二叉树中的前序和中序遍历，求出二叉树中有多少个叶子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">3</span>       <span class="comment">// 节点数</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span>   <span class="comment">// 前序序列</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span>   <span class="comment">// 中序序列</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span>       <span class="comment">// 叶子节点数</span></span><br></pre></td></tr></table></figure><p>答题过程中采用的方法是重建+遍历统计，最终只过了90%，说是数组越界，但<code>buildTree</code>经过在<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/submissions/">Leetcode</a>和<a href="https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6">牛客网</a>都测试了一遍，都能通过，想不明白。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left, right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preOrder, <span class="keyword">int</span> prest, <span class="keyword">int</span> preed, <span class="keyword">int</span>[] inOrder, <span class="keyword">int</span> inst, <span class="keyword">int</span> ined)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(prest &gt; preed)&#123;    <span class="comment">// 没有子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        root.val = preOrder[prest];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">for</span>(mid = inst; mid &lt;= ined &amp;&amp; root.val != inOrder[mid]; mid++);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = mid - inst;</span><br><span class="line">        root.left = buildTree(preOrder, prest+<span class="number">1</span>, prest+len, inOrder, inst, mid-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preOrder, prest+len+<span class="number">1</span>, preed, inOrder, mid+<span class="number">1</span>,ined);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceAll</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traceAll(root.left);</span><br><span class="line">        traceAll(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ct++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scan.nextInt();   <span class="comment">// 二叉树的节点数</span></span><br><span class="line">        <span class="keyword">int</span>[] preOrder = <span class="keyword">new</span> <span class="keyword">int</span>[n];    <span class="comment">// 前序序列</span></span><br><span class="line">        <span class="keyword">int</span>[] inOrder = <span class="keyword">new</span> <span class="keyword">int</span>[n];     <span class="comment">// 中序序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            preOrder[i] = scan.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            inOrder[i] = scan.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root = buildTree(preOrder, <span class="number">0</span>, n-<span class="number">1</span>, inOrder, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ct = <span class="number">0</span>;</span><br><span class="line">        traceAll(root);</span><br><span class="line"></span><br><span class="line">        System.out.println(ct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，统计叶子节点数，在buildTree的时候就可以统计，可以节省一次遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">One</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preOrder, <span class="keyword">int</span> prest, <span class="keyword">int</span> preed, <span class="keyword">int</span>[] inOrder, <span class="keyword">int</span> inst, <span class="keyword">int</span> ined)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(prest &gt; preed)&#123;    <span class="comment">// 没有子树</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(prest == preed &amp;&amp; inst == ined)&#123;   <span class="comment">// 叶子节点</span></span><br><span class="line">            ct++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        root.val = preOrder[prest];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">for</span>(mid = inst; mid &lt;= ined &amp;&amp; root.val != inOrder[mid]; mid++);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = mid - inst;</span><br><span class="line">        root.left = buildTree(preOrder, prest+<span class="number">1</span>, prest+len, inOrder, inst, mid-<span class="number">1</span>);</span><br><span class="line">        root.right = buildTree(preOrder, prest+len+<span class="number">1</span>, preed, inOrder, mid+<span class="number">1</span>,ined);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scan.nextInt();   <span class="comment">// 二叉树的节点数</span></span><br><span class="line">        <span class="keyword">int</span>[] preOrder = <span class="keyword">new</span> <span class="keyword">int</span>[n];    <span class="comment">// 前序序列</span></span><br><span class="line">        <span class="keyword">int</span>[] inOrder = <span class="keyword">new</span> <span class="keyword">int</span>[n];     <span class="comment">// 中序序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            preOrder[i] = scan.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            inOrder[i] = scan.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        ct = <span class="number">0</span>;</span><br><span class="line">        TreeNode root = buildTree(preOrder, <span class="number">0</span>, n-<span class="number">1</span>, inOrder, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        System.out.println(ct);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-有效字符"><a href="#2-有效字符" class="headerlink" title="2. 有效字符"></a>2. 有效字符</h3><p>一个由0-9，A-F组成的字符串，里面不能出现0010，问至少删除多少个字符，能满足要求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">2           &#x2F;&#x2F; 测试用例数</span><br><span class="line">0100</span><br><span class="line">0010ABCDEF</span><br><span class="line">输出：</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>没想到什么很好的解决方法，最后骗分的代码竟然AC了，纯属瞎猫碰上死耗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> t = Integer.valueOf(scan.nextLine());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(t-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            String s = scan.nextLine();</span><br><span class="line">            <span class="keyword">int</span> len = s.length();</span><br><span class="line">            <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i+<span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i+<span class="number">2</span>) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; s.charAt(i+<span class="number">3</span>) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    ct++;</span><br><span class="line">                    i += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(ct);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到讨论区里的解释是只要找有几个“0010”即可，仔细想想确实是，比如00<u>1</u>000<u>1</u>0至少删去两个字符，001<u>00</u>10至少删去两个字符，001<u>0</u>10至少删去一个字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Two</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> t = Integer.valueOf(scan.nextLine());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(t-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            String s = scan.nextLine();</span><br><span class="line">            <span class="keyword">int</span> len = s.length();</span><br><span class="line">            <span class="keyword">int</span> ct = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i+<span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i+<span class="number">2</span>) == <span class="string">&#x27;1&#x27;</span> &amp;&amp; s.charAt(i+<span class="number">3</span>) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                    ct++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(ct);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这类题目应该通过例子，找出规律。</p><h3 id="3-插入广告"><a href="#3-插入广告" class="headerlink" title="3. 插入广告"></a>3. 插入广告</h3><p>给n段视频，每段视频长度为L_i。现在需要向视频中插入广告，为了用户体验，插入的间隔越大越好。插入间隔可以为0，现有m段广告，问最大的插入间隔是多少。如果无法插入，则***</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">n m</span><br><span class="line">L_1 L_2 ... L_n</span><br><span class="line">输入：</span><br><span class="line">最大间隔</span><br></pre></td></tr></table></figure><p>是在想不出怎么会有无法插入的情况，大不了间隔为0，一直放广告，随便一段视频都能插入完啊。还有中间广播提示广告可以无限插入，这道题根本get不到点，直接放弃了。</p><p>评论区讨论是用二分法解决的，突然恍然大悟：如果间隔为x，那么视频i最多能插入L_i / x段视频。这点笔试中想到了，但是没有联系到二分法，所以感觉没有思路。这道题nlogn是可以通过的，广告的最小间隔是0，最大间隔是max{L_i}。那么这道题就可以转化为二分法求最大的大于指定数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Three &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; scan.nextInt(), m &#x3D; scan.nextInt();</span><br><span class="line">        int[] lens &#x3D; new int[n];</span><br><span class="line">        int left &#x3D; 0, right &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">            lens[i] &#x3D; scan.nextInt();</span><br><span class="line">            right &#x3D; Math.max(right, lens[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(left &lt; right)&#123;</span><br><span class="line">            int mid &#x3D; left + (right - left + 1) &#x2F; 2;</span><br><span class="line">            </span><br><span class="line">            int ct &#x3D; count(lens, mid);</span><br><span class="line">            </span><br><span class="line">            if(ct &lt; m)&#123;</span><br><span class="line">                right &#x3D; mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                left &#x3D; mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int count(int[] lens, int mid) &#123;</span><br><span class="line">        </span><br><span class="line">        int ct &#x3D; 0;</span><br><span class="line">        for(int m : lens)&#123;</span><br><span class="line">            ct +&#x3D; m &#x2F; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return ct;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这道题目，可能需要使用long类型，不过解决问题的思路有了，才是最关键的。</p><h3 id="4-最大的sum-m"><a href="#4-最大的sum-m" class="headerlink" title="4. 最大的sum % m"></a>4. 最大的sum % m</h3><p>长度为n的整数数组，从数组中选取0-n个数，选取的数的和记为sum，求最大的sum%m。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;&#x3D; m &lt;&#x3D; 1e9+7</span><br><span class="line">n &lt;&#x3D; 35</span><br></pre></td></tr></table></figure><p>这道题看起来是0-1背包，但m的数量级太大，直接劝退。后来考虑递归遍历所有情况，时间复杂度2^n，也会超时，最终通过40%。看评论区，暴力dfs居然过了60%，为什么我的只过了40%，难道是因为用的是java吗。</p><p><a href="https://www.nowcoder.com/discuss/478874?type=post&order=time&pos=&page=1&channel=1009&source_id=search_post">看评论区，通过将数组分为两组</a>，思路以后再写。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-统计二叉树中的叶子节点数&quot;&gt;&lt;a href=&quot;#1-统计二叉树中的叶子节点数&quot; class=&quot;headerlink&quot; title=&quot;1. 统计二叉树中的叶子节点数&quot;&gt;&lt;/a&gt;1. 统计二叉树中的叶子节点数&lt;/h3&gt;&lt;p&gt;给出二叉树中的前序和中序遍历，求出二叉树</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="字节" scheme="http://yoursite.com/tags/%E5%AD%97%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>SSH连接虚拟机Ubuntu</title>
    <link href="http://yoursite.com/2020/08/15/SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu/"/>
    <id>http://yoursite.com/2020/08/15/SSH%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BAUbuntu/</id>
    <published>2020-08-14T16:00:00.000Z</published>
    <updated>2020-08-15T14:18:59.260Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-查看虚拟机ip地址"><a href="#1-查看虚拟机ip地址" class="headerlink" title="1. 查看虚拟机ip地址"></a>1. 查看虚拟机ip地址</h4><p>在Ubuntu下输入命令查看ip地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><h4 id="2-测试ip地址是否可达"><a href="#2-测试ip地址是否可达" class="headerlink" title="2. 测试ip地址是否可达"></a>2. 测试ip地址是否可达</h4><p>Windows下打开cmd，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [ip地址]</span><br></pre></td></tr></table></figure><h4 id="3-安装ssh"><a href="#3-安装ssh" class="headerlink" title="3. 安装ssh"></a>3. 安装ssh</h4><p>首先测试Ubuntu是否安装ssh:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh localhost</span><br></pre></td></tr></table></figure><p>若连接失败，则需要安装ssh服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><p>安装完成后，确认ssh服务处于启动状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh status </span><br></pre></td></tr></table></figure><p>出现Active: active (running)，代表正在正在运行。</p><h4 id="4-使用XShell或git连接Ubuntu"><a href="#4-使用XShell或git连接Ubuntu" class="headerlink" title="4. 使用XShell或git连接Ubuntu"></a>4. 使用XShell或git连接Ubuntu</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-查看虚拟机ip地址&quot;&gt;&lt;a href=&quot;#1-查看虚拟机ip地址&quot; class=&quot;headerlink&quot; title=&quot;1. 查看虚拟机ip地址&quot;&gt;&lt;/a&gt;1. 查看虚拟机ip地址&lt;/h4&gt;&lt;p&gt;在Ubuntu下输入命令查看ip地址：&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
    <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>2021美团正式批笔试8.15</title>
    <link href="http://yoursite.com/2020/08/15/2021%E7%BE%8E%E5%9B%A2%E6%AD%A3%E5%BC%8F%E6%89%B9%E7%AC%94%E8%AF%958.15/"/>
    <id>http://yoursite.com/2020/08/15/2021%E7%BE%8E%E5%9B%A2%E6%AD%A3%E5%BC%8F%E6%89%B9%E7%AC%94%E8%AF%958.15/</id>
    <published>2020-08-14T16:00:00.000Z</published>
    <updated>2020-08-15T14:17:55.061Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-特殊的逆序对"><a href="#1-特殊的逆序对" class="headerlink" title="1. 特殊的逆序对"></a>1. 特殊的逆序对</h4><p>如果一个数的四倍是它的逆序数，那么这两个数就构成了一个逆序数对。给一个正整数n，求不大于n的正整数构成的逆序数对。</p><p>提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1234的逆序数是4321，1100的逆序数是11</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入正整数n</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行输出共有多少对逆序数</span><br><span class="line">从第二行开始每行输出一对逆序数，按第一个数从小到达开始输出，没有就不输出</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">10000</span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line">2178 8712</span><br></pre></td></tr></table></figure><p>*<em>没有考虑到4</em>i可能已经超出了n，最终代码只通过了55%：**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = i * <span class="number">4</span>; </span><br><span class="line">            <span class="keyword">if</span>(t &lt;= n &amp;&amp; judge(i))&#123;   <span class="comment">// 丢掉了重要条件</span></span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, t&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] arr : list)&#123;</span><br><span class="line">            System.out.println(arr[<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + arr[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String str1 = String.valueOf(a);</span><br><span class="line">        <span class="keyword">int</span> b = Integer.valueOf(<span class="keyword">new</span> StringBuilder(str1).reverse().toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a*<span class="number">4</span> == b;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-统计旅行次数"><a href="#2-统计旅行次数" class="headerlink" title="2. 统计旅行次数"></a>2. 统计旅行次数</h4><p>每次旅行会从一个城市出发，经过若干城市后回到出发的城市。现给出若干次旅行所有的城市之间的通行信息，请你找出总共旅行了多少次。其中不会包括无效的旅行信息。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行输入n，代表通行信息条数</span><br><span class="line">此后每行输入出发城市，到达城市</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一共旅行了多少次</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">6</span><br><span class="line">beijing chongqing</span><br><span class="line">chongqing hangzhou</span><br><span class="line">hangzhou beijing</span><br><span class="line">beijing xian</span><br><span class="line">xian beijing</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>看评论才知道，要考虑A-A这种情况（但自己的代码没问题啊），代码只通过了91%：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author shkstart</span><br><span class="line"> * @create 2020-08-15 16:36</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Two &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; Integer.valueOf(scan.nextLine());</span><br><span class="line"></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">            String[] strs &#x3D; scan.nextLine().split(&quot; &quot;);</span><br><span class="line">            List&lt;String&gt; list &#x3D; map.getOrDefault(strs[0], new ArrayList&lt;&gt;());</span><br><span class="line">            list.add(strs[1]);</span><br><span class="line">            map.put(strs[0], list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int ct &#x3D; 0;</span><br><span class="line">        for(String key : map.keySet())&#123;</span><br><span class="line">            List&lt;String&gt; list &#x3D; map.get(key);</span><br><span class="line">            while(list.size() &gt; 0)&#123;</span><br><span class="line">                if(dfs(key, key, map))&#123;</span><br><span class="line">                    ct++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(ct);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static boolean dfs(String start, String key, Map&lt;String, List&lt;String&gt;&gt; map) &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list &#x3D; map.get(key);</span><br><span class="line"></span><br><span class="line">        int i &#x3D; 0;</span><br><span class="line">        boolean res &#x3D; false;</span><br><span class="line"></span><br><span class="line">        for(i &#x3D; 0; i &lt; list.size(); i++)&#123;</span><br><span class="line">            String next &#x3D; list.get(i);</span><br><span class="line">            if(next.equals(start))&#123;</span><br><span class="line">                res &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                res &#x3D; dfs(start, next, map);</span><br><span class="line">            &#125;</span><br><span class="line">            if(res)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(res)&#123;</span><br><span class="line">            list.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>补充：</p><p>真无语，难道真的是自己审题有问题吗，看到有人居然一遍遍历就过了，把题想难了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int count;</span><br><span class="line">    cin&gt;&gt;count;</span><br><span class="line">    vector&lt;pair&lt;string,string&gt;&gt;res;</span><br><span class="line">    string str1,str2;</span><br><span class="line">    for(int i &#x3D; 0;i &lt; count;i++)&#123;</span><br><span class="line">        cin&gt;&gt;str1&gt;&gt;str2;</span><br><span class="line">        res.push_back(&#123;str1,str2&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    int len &#x3D; 1;</span><br><span class="line">    count &#x3D; res.size();</span><br><span class="line">    for(int i &#x3D; 0;i &lt; count - 1;i++)&#123;</span><br><span class="line">        if(res[i].second !&#x3D; res[i + 1].first)len++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-小区人员划分"><a href="#3-小区人员划分" class="headerlink" title="3. 小区人员划分"></a>3. 小区人员划分</h4><p>有n个人编号1-n，给出关系&lt;a, b&gt;代表a和b同属一个小区。请你根据给出的关系，对人员进行划分。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行输入n，m分别代表人员数，和关系数</span><br><span class="line">第二行开始每行输入关系a b , 共输入m行</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行输出n个人共有几个小区</span><br><span class="line">此后每行，输出每个小区的人员，编号递增</span><br><span class="line">小区顺序：编号最小的人员的编号越小，越优先输出</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>通过并查集思想，不难解决，此次笔试唯一AC的题：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author shkstart</span><br><span class="line"> * @create 2020-08-15 17:24</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Three &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Scanner scan &#x3D; new Scanner(System.in);</span><br><span class="line">        int n &#x3D; scan.nextInt(), m &#x3D; scan.nextInt();</span><br><span class="line">        int[] mark &#x3D; new int[n+1];</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; n ;i++)&#123;</span><br><span class="line">            mark[i] &#x3D; i;</span><br><span class="line">            List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">            list.add(i);</span><br><span class="line">            map.put(i, list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">            int a &#x3D; scan.nextInt(), b &#x3D; scan.nextInt();</span><br><span class="line">            int c_a &#x3D; mark[a], c_b &#x3D; mark[b];</span><br><span class="line">            if(c_a &#x3D;&#x3D; c_b)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Integer&gt; listA&#x3D; map.get(c_a);</span><br><span class="line">            List&lt;Integer&gt; listB &#x3D; map.get(c_b);</span><br><span class="line">            for(int t : listB)&#123;</span><br><span class="line">                mark[t] &#x3D; c_a;</span><br><span class="line">                listA.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">            map.remove(c_b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">        Set&lt;Integer&gt; set &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;</span><br><span class="line">            int c &#x3D; mark[i];</span><br><span class="line">            if(set.contains(c))&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Integer&gt; list &#x3D; map.get(c);</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            for(int num : list)&#123;</span><br><span class="line">                System.out.print(num + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            set.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-运输的最高收益"><a href="#4-运输的最高收益" class="headerlink" title="4.  运输的最高收益"></a>4.  运输的最高收益</h4><p>运输公司有n辆车，位于不同位置。现有两个地方都要用车，每辆车由于位置不同到两地的运输收益也不同。连个地方分别要a辆车，b辆车。请你计算出运输的最大收益。</p><p>输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行：n, a, b</span><br><span class="line">第二行：a1 a2 ... an  每辆车到第一个地方的收益</span><br><span class="line">第二行：b1 b2 ... bn  每辆车到第二个地方的收益</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大收益</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">5 2 2</span><br><span class="line">4 3 5 5 1</span><br><span class="line">2 3 4 3 5</span><br><span class="line">输出：</span><br><span class="line">18</span><br></pre></td></tr></table></figure><p><strong>这道题应该是道动态规划的题，和背包也挺像的，暂时没思路：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-特殊的逆序对&quot;&gt;&lt;a href=&quot;#1-特殊的逆序对&quot; class=&quot;headerlink&quot; title=&quot;1. 特殊的逆序对&quot;&gt;&lt;/a&gt;1. 特殊的逆序对&lt;/h4&gt;&lt;p&gt;如果一个数的四倍是它的逆序数，那么这两个数就构成了一个逆序数对。给一个正整数n，求不大于</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>背包问题解析</title>
    <link href="http://yoursite.com/2020/08/14/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2020/08/14/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/</id>
    <published>2020-08-13T16:00:00.000Z</published>
    <updated>2020-08-15T14:19:06.346Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-0-1背包"><a href="#1-0-1背包" class="headerlink" title="1. 0-1背包"></a>1. 0-1背包</h4><p>背包的能容纳的最大重量为W，有N个物品，每个物品的重量为w<sub>i</sub>，价值为v<sub>i</sub>。求背包可容纳的物品的最大价值。</p><p>定义二维数组dp[N][W]，dp[i][j]表示前i个物品在重量不超过j的情况下能容纳物品的最大价值。设第i件物品的重量为w<sub>i</sub>, 价值为v<sub>i</sub>，根据第i件物品是否在背包中，可以有两种情况：</p><ul><li>第i件物品不放在背包中，dp[i][j]（前i件物品放入容量为j的背包的最大价值） =  dp[i-1][j]（前i-1件物品放入容量为j的背包的最大价值）</li><li>第i件物品放入背包中，dp[i][j]（前i件物品放入容量为j的背包的最大价值） = dp[i-1][j-w<sub>i</sub>] + v<sub>i</sub>（前i-1件物品放入容量为j-w<sub>i</sub>的背包的最大价值 + v<sub>i</sub>）</li></ul><p>dp[i][j]应该取两者的较大的，状态转移方程为：<br>$$<br>dp[i][j] = max{dp[i-1][j],\quad dp[i-1][j-w_i],+,v_i}<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int solve(int[] weights, int[] values, int W, int N)&#123;</span><br><span class="line">    </span><br><span class="line">    int[][] dp &#x3D; new int[N+1][W+1];</span><br><span class="line">    </span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;</span><br><span class="line">        int w &#x3D; weights[i-1], v &#x3D; values[i-1];</span><br><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; W; j++)&#123;</span><br><span class="line">            dp[i][j] &#x3D; dp[i-1][j];</span><br><span class="line">            if(j - w &gt;&#x3D; 0)&#123;</span><br><span class="line">                dp[i][j] &#x3D; Math.max(dp[i][j], dp[i-1][j-w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>空间优化</strong></p><p>观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组，其中 dp[j] 既可以表示 dp[i-1][j] 也可以表示 dp[i][j]。此时，<br>$$<br>dp[j] = max{dp[j],,, dp[j-w_i],+,v_i}<br>$$<br>因为dp[j-w<sub>i</sub>]代表的是dp[i-1][j-w<sub>i</sub>]，为了避免覆盖掉dp[i-1][j-w<sub>i</sub>]，也就是说要先计算 dp[i][j] 再计算 dp[i][j-w<sub>i</sub>]，在程序实现时需要按倒序来循环求解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int solve(int[] weights, int[] values, int W, int N)&#123;</span><br><span class="line">    </span><br><span class="line">    int[] dp &#x3D; new int[W+1];</span><br><span class="line">    </span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;</span><br><span class="line">        int w &#x3D; weights[i-1], v &#x3D; values[i-1];</span><br><span class="line">        &#x2F;&#x2F; dp[j] 代表没有第i件物品容量为j的最大价值</span><br><span class="line">        for(int j &#x3D; W; j &gt;&#x3D; w; j--)&#123;</span><br><span class="line">            dp[j] &#x3D; Math.max([j], dp[j-w] + v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例题</strong></p><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></p><p>我们可以先求出数组所有元素的和sum，问题可以转化为0-1背包问题：背包的容量为sum/2，原数组就是每件物品的重量，判断背包是否可以正好装满。</p><p>此问题没有涉及物品的价值：求的是是否能将背包装满，所以无需考虑物品的价值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean canPartition(int[] nums) &#123;</span><br><span class="line"></span><br><span class="line">    int n &#x3D; nums.length;</span><br><span class="line"></span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    for(int m : nums)&#123;</span><br><span class="line">        sum +&#x3D; m;</span><br><span class="line">    &#125;</span><br><span class="line">    if(sum % 2 &#x3D;&#x3D; 1)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int S &#x3D; sum &#x2F; 2;</span><br><span class="line">    boolean[] dp &#x3D; new boolean[S+1];</span><br><span class="line">    dp[0] &#x3D; true;</span><br><span class="line"></span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;    &#x2F;&#x2F; 每个物品只用一次</span><br><span class="line">        int weight &#x3D; nums[i-1];</span><br><span class="line">        for(int j &#x3D; S; j &gt;&#x3D; weight; j--)&#123;    &#x2F;&#x2F; 从后往前，先计算dp[j]，再计算dp[j-1]</span><br><span class="line">            dp[j] &#x3D; dp[j] || dp[j-weight];   &#x2F;&#x2F; *****</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[S];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></p><p>将数组按符号分为两个集和：带正号集和S1，带符号集和S2，可以得出：<br>$$<br>sum(S1) - sum(S2) = target\<br>sum(S1) + sum(S2) ,=, sum<br>$$<br>可以得出：<br>$$<br>2*sum(S1) = target + sum<br>$$<br> 问题也可以转化为0-1背包问题：容量为(target+sum)/2，物品为数组，求有多少种方式可以将背包放满。</p><p>此问题求解的是背包放满有多少种方式，同样没有涉及到物品价值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public int findTargetSumWays(int[] nums, int S) &#123;</span><br><span class="line"></span><br><span class="line">    int sum &#x3D; 0;</span><br><span class="line">    for(int m : nums)&#123;</span><br><span class="line">        sum +&#x3D; m;</span><br><span class="line">    &#125;</span><br><span class="line">    if((sum + S) % 2 &#x3D;&#x3D; 1 || sum &lt; S)&#123;   &#x2F;&#x2F; 注意这里，否则会超出内存</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int T &#x3D; (sum + S) &#x2F; 2;</span><br><span class="line">    int[] dp &#x3D; new int [T + 1];</span><br><span class="line">    dp[0] &#x3D; 1;</span><br><span class="line">    int n &#x3D; nums.length;</span><br><span class="line"></span><br><span class="line">    for(int weight : nums)&#123;</span><br><span class="line">        for(int j &#x3D; T; j &gt;&#x3D; weight; j--)&#123;</span><br><span class="line">            dp[j] +&#x3D; dp[j-weight];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题数组长度不会超过20，同样可以用DFS求解，时间复杂度O(2^n)。</p><p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></p><p>这道题如果仔细考虑一下，也是个0-1背包问题：背包的容量有两个限制m和n，物品就是字符串数组，每个物品的代价就是字符串中0和1的数量，求背包中最多能放如多少个物品。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int findMaxForm(String[] strs, int m, int n) &#123;</span><br><span class="line"></span><br><span class="line">    int[][] dp &#x3D; new int[m+1][n+1];    &#x2F;&#x2F; 背包有两个限制属性</span><br><span class="line"></span><br><span class="line">    for(String s : strs)&#123;    &#x2F;&#x2F; 每个物品只能放一次</span><br><span class="line">        int zero &#x3D; 0, one &#x3D; 0;    &#x2F;&#x2F; 物品的两个属性代价</span><br><span class="line">        for(char ch : s.toCharArray())&#123;</span><br><span class="line">            if(ch &#x3D;&#x3D; &#39;0&#39;)&#123;</span><br><span class="line">                zero++;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                one++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int j &#x3D; m; j &gt;&#x3D; zero; j--)&#123;    &#x2F;&#x2F; 0</span><br><span class="line">            for(int k &#x3D; n; k &gt;&#x3D; one; k--)&#123;    &#x2F;&#x2F; 1</span><br><span class="line">                dp[j][k] &#x3D; Math.max(dp[j][k], dp[j-zero][k-one] + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[m][n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>0-1背包的特点</strong></p><ul><li>N个物品，每个物品两个属性&lt;w, v&gt;</li><li>每个物品在背包中可以放0个或1个</li><li>求容量不超出下的最大价值</li></ul><h4 id="2-完全背包"><a href="#2-完全背包" class="headerlink" title="2. 完全背包"></a>2. 完全背包</h4><p>背包的能容纳的最大重量为W，有N个物品，每个物品的重量为w<sub>i</sub>，价值为v<sub>i</sub>。求背包可容纳的物品的最大价值。完全背包问题中，每个物品放入的数量是不受限制的。</p><p>dp[i][j]表示前i个物品&lt;w<sub>i</sub>, v<sub>i</sub>&gt;放入容量为j背包时的最大代价，根据第i个物品放入到背包的状况，可以得到状态转移方程：<br>$$<br>dp[i][j] = max{dp[i-1][j],, dp[i-1][j-w_i] + v_i,, dp[i-1][j-2<em>w_i]+2</em>v_i,….}<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public int solve(int[] weights, int[] values, int W, int N)&#123;</span><br><span class="line">    </span><br><span class="line">    int[][] dp &#x3D; new int[N+1][W+1];</span><br><span class="line">    </span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;    &#x2F;&#x2F; 放入每个物品</span><br><span class="line">        int w &#x3D; weights[i-1], v &#x3D; values[i-1];    &#x2F;&#x2F; 物品的代价和价值</span><br><span class="line">        for(int j &#x3D; 1; j &lt;&#x3D; W; j++)&#123;    &#x2F;&#x2F; </span><br><span class="line">            dp[i][j] &#x3D; dp[i-1][j];     &#x2F;&#x2F; 不放入第i个物品</span><br><span class="line">            for(int k &#x3D; 1; k*w &lt;&#x3D; j; k++)&#123;    &#x2F;&#x2F; 放入1个，2个....</span><br><span class="line">                dp[i][j] &#x3D; Math.max(dp[i][j], dp[i-1][j-k*w] + k*v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return dp[N][W];</span><br><span class="line">&#125;</span><br><span class="line">空间压缩后</span><br><span class="line">public int solve(int[] weights, int[] values, int W, int N)&#123;</span><br><span class="line">    </span><br><span class="line">    int[] dp &#x3D; new int[W+1];</span><br><span class="line">    </span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;    &#x2F;&#x2F; 放入每个物品</span><br><span class="line">        int w &#x3D; weights[i-1], v &#x3D; values[i-1];    &#x2F;&#x2F; 物品的代价和价值</span><br><span class="line">        for(int j &#x3D; W; j &gt;&#x3D; 1; j--)&#123;    &#x2F;&#x2F; </span><br><span class="line">            for(int k &#x3D; 1; k*w &lt;&#x3D; j; k++)&#123;    &#x2F;&#x2F; 放入1个，2个....</span><br><span class="line">                dp[j] &#x3D; Math.max(dp[j], dp[j-k*w] + k*v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种比较简洁的思路：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int solve(int[] weights, int[] values, int W, int N)&#123;</span><br><span class="line">    </span><br><span class="line">    int[] dp &#x3D; new int[W+1];</span><br><span class="line">    Arrays.fill(dp, -1);</span><br><span class="line">    dp[0] &#x3D; 0;</span><br><span class="line">    </span><br><span class="line">    for(int i &#x3D; 1; i &lt;&#x3D; N; i++)&#123;    &#x2F;&#x2F; 放入每个物品</span><br><span class="line">        int w &#x3D; weights[i-1], v &#x3D; values[i-1];    &#x2F;&#x2F; 物品的代价和价值</span><br><span class="line">        for(int j &#x3D; w; j &lt;&#x3D; W; j++)&#123;    &#x2F;&#x2F; </span><br><span class="line">            if(dp[j-w] !&#x3D; -1)&#123;</span><br><span class="line">                dp[j] &#x3D; Math.max(dp[j], dp[j-w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></p><p>此问题是个完全背包问题：物品是硬币，可以无限次放入，背包容量是amount，求能将背包装满的组合数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int coinChange(int[] coins, int amount) &#123;</span><br><span class="line"></span><br><span class="line">       int[] dp &#x3D; new int[amount+1];</span><br><span class="line">       Arrays.fill(dp, -1);</span><br><span class="line">       dp[0] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">       for(int m : coins[i])&#123;</span><br><span class="line">           for(int j &#x3D; m; j &lt;&#x3D; amount; j++)&#123;</span><br><span class="line">               if(dp[j-m] !&#x3D; -1)&#123;</span><br><span class="line">                   if(dp[j] &#x3D;&#x3D; -1)&#123;</span><br><span class="line">                       dp[j] &#x3D; dp[j-m] + 1;</span><br><span class="line">                   &#125;</span><br><span class="line">                   else&#123;</span><br><span class="line">                       dp[j] &#x3D; Math.min(dp[j], dp[j-m]+1);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return dp[amount];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a></p><p>完全背包，求组合数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int change(int amount, int[] coins) &#123;</span><br><span class="line"></span><br><span class="line">    int[] dp &#x3D; new int[amount+1];</span><br><span class="line">    dp[0] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    for(int coin : coins)&#123;</span><br><span class="line">        for(int i &#x3D; coin; i &lt;&#x3D; amount; i++)&#123;</span><br><span class="line">            dp[i] +&#x3D; dp[i-coin];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[amount];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></p><p>这道题比较有意思，物品是单词字典，背包的容量是字符串长度，不过它的放入条件是字符串要相同。而且物品放入有先后顺序。带放入顺序的完全背包问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 错误解法</span><br><span class="line">public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line"></span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        boolean[] dp &#x3D; new boolean[len + 1];</span><br><span class="line">        dp[0] &#x3D; true;</span><br><span class="line">        </span><br><span class="line">        for(String str : wordDict)&#123;</span><br><span class="line"></span><br><span class="line">            for(int i &#x3D; str.length(); i &lt;&#x3D; len; i++)&#123;</span><br><span class="line">                if(!dp[i] &amp;&amp; dp[i-str.length()] &amp;&amp; isSame(s, i-1, str))&#123;</span><br><span class="line">                    dp[i] &#x3D; true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[len];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确解法</span><br><span class="line">public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line"></span><br><span class="line">        int len &#x3D; s.length();</span><br><span class="line">        boolean[] dp &#x3D; new boolean[len + 1];</span><br><span class="line">        dp[0] &#x3D; true;</span><br><span class="line">        </span><br><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; len; i++)&#123;</span><br><span class="line">            for(String str : wordDict)&#123;</span><br><span class="line">                int l &#x3D; str.length();</span><br><span class="line">                if(!dp[i] &amp;&amp; i &gt;&#x3D; l &amp;&amp; isSame(s, i-1, str))&#123;</span><br><span class="line">                    dp[i] |&#x3D; dp[i-l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return dp[len];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isSame(String str, int end, String s)&#123;</span><br><span class="line">        int i &#x3D; end, j &#x3D; s.length()-1;</span><br><span class="line">        while(i &gt;&#x3D; 0 &amp;&amp; j &gt;&#x3D; 0)&#123;</span><br><span class="line">            if(str.charAt(i) !&#x3D; s.charAt(j))&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return j &#x3D;&#x3D; -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></p><p>求组合数，不同的序列被视为不同的组合，则需要考虑物品放入背包时的顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int combinationSum4(int[] nums, int target) &#123;</span><br><span class="line">    if (nums &#x3D;&#x3D; null || nums.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int[] maximum &#x3D; new int[target + 1];</span><br><span class="line">    maximum[0] &#x3D; 1;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; target; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; nums.length &amp;&amp; nums[j] &lt;&#x3D; i; j++) &#123;</span><br><span class="line">            maximum[i] +&#x3D; maximum[i - nums[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maximum[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无视组合数字的中的先后顺序的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int combinationSum4(int[] nums, int target) &#123;</span><br><span class="line"></span><br><span class="line">    int[] dp &#x3D; new int[target+1];</span><br><span class="line">    dp[0] &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    for(int m : nums)&#123;</span><br><span class="line">        for(int j &#x3D; m; j &lt;&#x3D; target; j++)&#123;</span><br><span class="line">            dp[j] +&#x3D; dp[j-m];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[target];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>完全背包的特点</strong></p><ul><li>N个物品，每个物品两个属性&lt;w, v&gt;</li><li>每个物品在背包中可以放0个或无限多个</li><li>求容量不超出下的最大价值</li></ul><h4 id="3-多重背包"><a href="#3-多重背包" class="headerlink" title="3. 多重背包"></a>3. 多重背包</h4><p><strong>多重背包的特点</strong></p><ul><li>N个物品，每个物品两个属性&lt;w, v&gt;</li><li>每个物品都有一定的数量N<sub>i</sub>，在背包中可以放入0-N<sub>i</sub></li><li>求容量不超出下的最大价值</li></ul><h4 id="4-多维费用背包"><a href="#4-多维费用背包" class="headerlink" title="4.多维费用背包"></a>4.多维费用背包</h4><p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></p><p>属于0-1背包中的多维费用背包，答案见0-1背包。</p><p><strong>多维费用背包的特点</strong></p><ul><li>N个物品，每个物品有多个限制属性如容量、体积，以及价值</li><li>放入看具体要求</li><li>求重量和体积都不超出下的最大价值</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-0-1背包&quot;&gt;&lt;a href=&quot;#1-0-1背包&quot; class=&quot;headerlink&quot; title=&quot;1. 0-1背包&quot;&gt;&lt;/a&gt;1. 0-1背包&lt;/h4&gt;&lt;p&gt;背包的能容纳的最大重量为W，有N个物品，每个物品的重量为w&lt;sub&gt;i&lt;/sub&gt;，价值为v&lt;s</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="背包" scheme="http://yoursite.com/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础</title>
    <link href="http://yoursite.com/2020/08/13/Redis%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/08/13/Redis%E5%9F%BA%E7%A1%80/</id>
    <published>2020-08-13T13:22:53.000Z</published>
    <updated>2020-08-15T14:18:53.033Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Redis有那些数据结构"><a href="#1-Redis有那些数据结构" class="headerlink" title="1.Redis有那些数据结构"></a>1.Redis有那些数据结构</h4><p>​    字符串、字典Hash、列表List、集和Set、有序集和SortedSet。</p><p>​    ….加分项</p><p>​    BitMap、Geo、HyperLogLog、</p><p><strong>应用场景补充</strong></p><p>​    字符串：常规的key-value缓存应用。常用计数器：微博数，粉丝数</p><p>​    hash: 存储部分变更数据，如用户信息等。</p><p>​    list: 可以构建消息队列</p><p>​    set: 交集、并集、差集，去重，找共同的爱好……</p><p>​    sortedset: 通过score对元素进行优先排序，带权重的消息队列</p><h4 id="2-大量key同一时间过期"><a href="#2-大量key同一时间过期" class="headerlink" title="2.大量key同一时间过期"></a>2.大量key同一时间过期</h4><p>​    如果大量的key在同一时间过期，那么到过期的时间点Redis会发生卡顿现象，严重的话会造成<strong>缓存雪崩</strong>，解决方法是在设置失效时间时加上一个随机值。</p><h4 id="3-Redis分布式锁"><a href="#3-Redis分布式锁" class="headerlink" title="3.Redis分布式锁"></a>3.Redis分布式锁</h4><p>​    分布式锁是为了解决多进程之间的同步，redis可以实现分布式锁。可以用setnx原子操作来获得锁（），抢到之后用expire给锁添加过期时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setnx k v</span><br><span class="line">expire k timeout</span><br></pre></td></tr></table></figure><p>追问：如果setnx获取锁成功，但线程执行expire之前崩溃，会如何，怎样解决？</p><p>​    此时，这个锁将一直被持有，无法释放。可以用同时具有setnx和expire的原子指令***解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set k v nx[key必须不存在] [ex t 秒级]&#x2F;[px t 毫秒级]</span><br></pre></td></tr></table></figure><h4 id="4-如何在Redis中查询大量的具有固定前缀的key"><a href="#4-如何在Redis中查询大量的具有固定前缀的key" class="headerlink" title="4.如何在Redis中查询大量的具有固定前缀的key"></a>4.如何在Redis中查询大量的具有固定前缀的key</h4><p>​    可以利用keys指令查询，但该指令会一次性查找全部符合条件的key，会造成卡顿（Redis是单线程的）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys [pattern]</span><br></pre></td></tr></table></figure><p>​    因为keys指令需要全部遍历，数据量很大的话，需要一定的执行时间。由于Redis是单线程，所以其他服务会暂停，直到keys指令结束。为避免此情况发生，可以使用scan指令，scan指令可以无阻塞的取出指定模式的key列表（每次执行会找到若干个符合条件的key），但会出现重复，所以客户端需要去重：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scan cursor[0代表从头开始] [MATCH pattern] [COUNT num]</span><br></pre></td></tr></table></figure><p>​    由于scan不是一次性遍历（增量式迭代），所以在全部扫描完成时可能有些key会发生变化。</p><h4 id="5-Redis异步队列"><a href="#5-Redis异步队列" class="headerlink" title="5.Redis异步队列"></a>5.Redis异步队列</h4><p>​    Redis可以实现异步队列，一般用List实现，rpush生产消息，lpop消费消息。当lpop没有消息可消费时，需要sleep一会儿重试。</p><p>​    除了sleep还可以使用blpop指令，在没有消息时，他会阻塞住直到消息到来。</p><p><strong>一次生产，多次消费如何实现？</strong></p><p>​    可以使用pub/sub主题订阅模式，可以实现1：N的消息队列</p><p><strong>pub/sub有何问题</strong></p><p>​    在消费者下线情况下，生产的消息会丢失，可以使用RabbitMQ。</p><p><strong>如何实现延时队列</strong></p><p>​    可以使用有序集和sortedset，将时间作为score，消息内容作为key，调用zadd来生产消息，消费者通过zrangebyscore指令获取N秒前的消息.</p><h4 id="6-Redis持久化"><a href="#6-Redis持久化" class="headerlink" title="6.Redis持久化"></a>6.Redis持久化</h4><p>​    Redis持久化有两种方式：RDB镜像全量持久化、AOF增量持久化。</p><p><strong>RDB:</strong></p><p>​    Redis每隔一段时间可以将所有数据备份到磁盘，Redis会fork一个子线程进行RDB操作，子线程创建后，父子线程共享数据段，父线程将继续提供服务，写脏的页面数据会和子线程分开（cow, copy on write)。cow数据未发生变化时，父子线程共享数据，一旦发生变化，子线程才会分配空间存储数据。</p><p>​    自动触发：配置文件中，可以配置经过多少次save就触发；</p><p>​    手动触发：通过bgsave命令，会fork一个子进程。</p><p><strong>AOF：</strong></p><p>​    将Redis执行的指令记录到磁盘，sync属性可以支持每条指令都写到磁盘，但代价较高。可以设置每秒sync，这样最多会丢失1s的数据。</p><p>​    AOF日志会随着时间不断变大，可以通过AOF重写解决。首先读取数据库中所有键值的状态，使用一条命令替代前面多条操作语句。使用bgrewriteaof命令进行重写，重写时会fork一个子进程进行重写，主进程将重写期间的命令放到重写缓冲区中，待重写完成将其添加到AOF文件中。</p><p>​    RDB无法实时持久化，AOF文件较大（AOF重写解决）。</p><h4 id="7-Pipline是什么"><a href="#7-Pipline是什么" class="headerlink" title="7.Pipline是什么"></a>7.Pipline是什么</h4><p>​    普通的请求中，每次请求都对应一次IO操作等待（往返时延），而Pipline会将所有请求转化为一次IO操作（一次往返）。使用前提是指令之间没有因果相关性。</p><h4 id="8-Redis的同步机制"><a href="#8-Redis的同步机制" class="headerlink" title="8.Redis的同步机制"></a>8.Redis的同步机制</h4><p>​    Redis同步机制有两种：主从同步</p><p><strong>主从同步：</strong></p><ul><li>从服务器向主服务器发送sync命令</li><li>主服务器收到sync命令，开始执行bgsave命令生成RDB文件，并用缓存开始记录此后执行的所有写命令</li><li>主服务器bgsave完成之后，向从服务器发送RDB文件，继续在缓存中记录写命令</li><li>从服务器收到RDB文件，丢弃所有旧数据，载入RDB</li><li>主服务器向从服务器发送缓存中的命令</li><li>从服务器载入RDB后开始接收命令请求，执行来自主服务器中的缓存命令</li></ul><p>通过以上操作，<strong>全量同步</strong>完成，以后主服务器向从服务器发送所有的写操作进行<strong>增量同步</strong>。</p><h4 id="9-Redis集群"><a href="#9-Redis集群" class="headerlink" title="9.Redis集群"></a>9.Redis集群</h4><p>​    Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master,继续提供服务。</p><p>​    Redis Cluster着眼于扩展性，在单个Redis内存不足时，使用Cluster进行分片存储。</p><h4 id="10-Redis为什么快"><a href="#10-Redis为什么快" class="headerlink" title="10.Redis为什么快"></a>10.Redis为什么快</h4><ul><li><p>数据放在内存中，而且其存储数据类似HashMap，所以速度很快</p></li><li><p>单线程，没有线程上下文切换开销</p></li><li><p>多路IO复用，可以一个线程监听多路IO</p><p>研究表明，redis的瓶颈在网络时延</p></li></ul><h4 id="11-Redis与memcached区别"><a href="#11-Redis与memcached区别" class="headerlink" title="11.Redis与memcached区别"></a>11.Redis与memcached区别</h4><ul><li>memcached只支持字符串，redis支持更丰富的数据类型</li><li>redis支持数据持久化</li><li>redis支持数据备份，即master-slave</li></ul><h4 id="12-redis数据过期回收"><a href="#12-redis数据过期回收" class="headerlink" title="12.redis数据过期回收"></a>12.redis数据过期回收</h4><ul><li><p>定期回收</p><p>没过一段时间去抽查一部分数据是否过期，过期就删除。</p></li><li><p>惰性删除</p><p>使用key时，先判断是否过期，过期则删除。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-Redis有那些数据结构&quot;&gt;&lt;a href=&quot;#1-Redis有那些数据结构&quot; class=&quot;headerlink&quot; title=&quot;1.Redis有那些数据结构&quot;&gt;&lt;/a&gt;1.Redis有那些数据结构&lt;/h4&gt;&lt;p&gt;​    字符串、字典Hash、列表List</summary>
      
    
    
    
    <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>MySql数据库面试问题</title>
    <link href="http://yoursite.com/2020/08/13/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2020/08/13/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2020-08-13T13:22:53.000Z</published>
    <updated>2020-08-15T14:18:39.066Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-说一说MySQL中的索引"><a href="#1-说一说MySQL中的索引" class="headerlink" title="1.说一说MySQL中的索引"></a>1.说一说MySQL中的索引</h4><p>​    MySQL数据库的索引是用B+树实现的。在B+树中非叶节点只存储关键字和指针（可以存储更多的关键字，降低树高），叶子节点存储关键字和数据。相邻的叶子节点间有指针连接，范围查找更为快速。通过B+树索引进行查找的时间复杂度为树高，一般是2~4次。<strong>（数据结构）</strong></p><p>​    MySQL数据库中的索引有两种：聚集索引、稀疏索引。其中聚集索引的叶子节点会存储实际表中真实的数据，一个表只能有一个聚集索引，而稀疏索引的叶子节点存储的是主键的值。也就是说，通过稀疏索引进行查找，首先会查询稀疏索引树，找到符合条件的聚集索引的关键字，然后用该关键字在聚集索引树中进行查找，找到最终的数据。</p><p>​    MySQL数据库中InnoDB引擎主索引是聚集索引，叶子的value存储真实数据，辅助索引是稀疏索引，叶子节点value存储主键的值；而Myisam引擎主索引和辅助索引都是稀疏索引，两者没有任何区别（value都存储数据的地址）。</p><h4 id="2-为什么MySQL索引使用B-树，不是B树"><a href="#2-为什么MySQL索引使用B-树，不是B树" class="headerlink" title="2.为什么MySQL索引使用B+树，不是B树"></a>2.为什么MySQL索引使用B+树，不是B树</h4><p>​    B+树是B树的变种，B+树中非叶节点只用来保存索引（关键字和指针），不储存数据，所有的数据存储在叶子节点上；而B树中的非叶节点会保存数据，这样使得B+树的查询效率更加稳定，均是从根节点到叶子节点。</p><p>​    B+树非叶节点不存储数据，所以可以存储更多的关键字，使得B+树查找的磁盘IO数更少。</p><p>​    B+树相邻的叶子节点间有指针连接，范围查询更为有利。</p><h4 id="3-为什么推荐采用自增主键"><a href="#3-为什么推荐采用自增主键" class="headerlink" title="3.为什么推荐采用自增主键"></a>3.为什么推荐采用自增主键</h4><p>​    InnoDB推荐使用自增列作为主键，这样可以提高存取速度。因为如果InnoDB表的数据写入顺序能和B+树索引的叶子节点顺序一致的话，这时候存取效率是最高的。</p><h4 id="4-MySQL常见的存储引擎有哪些"><a href="#4-MySQL常见的存储引擎有哪些" class="headerlink" title="4.MySQL常见的存储引擎有哪些"></a>4.MySQL常见的存储引擎有哪些</h4><p>​    MySQL中常见的存储引擎有InnoDB和MyISAM，主要区别是：</p><ul><li>MyISAM不支持事务；InnoDB是事务类型的存储引擎。</li><li>MyISAM只支持表级锁；InnoDB支持行级锁和表级锁，默认为行级锁。</li><li>MyISAM引擎不支持外键；InnoDB支持外键。</li><li>MyISAM支持全文索引（FULLTEXT）；InnoDB不支持。</li><li>MyISAM索引都是是稀疏索引，叶子节点存储真实数据的指针，数据和索引分离；InnoDB采用聚集索引，真实数据在聚集的叶子节点上，辅助索引是稀疏索引，叶子节点存储主键值。</li></ul><h4 id="5-MySQL中where、group-by、having关键字"><a href="#5-MySQL中where、group-by、having关键字" class="headerlink" title="5.MySQL中where、group by、having关键字"></a>5.MySQL中where、group by、having关键字</h4><ul><li>where子句用来筛选from子句中指定的操作所产生的的<strong>行</strong></li><li>group by 子句用来<strong>分组</strong>where子句的输出</li><li>having子句用来从分组的结果中<strong>筛选组</strong></li></ul><p><strong>where和having的区别</strong>：where 是group by之前进行筛选，筛选的是行，having是group by 之后进行统计的筛选，筛选的是组。</p><p><strong>执行顺序</strong>：执行where子句查找符合条件的数据 &gt; 使用group by 子句对数据进行分组 &gt;对group by 子句形成的组运行聚集函数计算每一组的值&gt;最后用having 子句去掉不符合条件的组</p><h4 id="6-索引的最左前缀原则"><a href="#6-索引的最左前缀原则" class="headerlink" title="6.索引的最左前缀原则"></a>6.索引的最左前缀原则</h4><p>​    在联合索引的情况下，不需要索引的全部定义，只要满足最左前缀，就可以利用索引来加快查询速度。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。最左前缀原则的利用也可以显著提高查询效率，是常见的MySQL性能优化手段。</p><p>​    如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from user where name&#x3D;xx and city&#x3D;xx ; ／／可以命中索引</span><br><span class="line">select * from user where name&#x3D;xx ; &#x2F;&#x2F; 可以命中索引</span><br><span class="line">select * from user where city&#x3D;xx ; &#x2F;&#x2F; 无法命中索引            </span><br></pre></td></tr></table></figure><pre><code> 这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 `city= xx and name ＝xx`，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。</code></pre><h4 id="7-那些列上适合建立索引，对性能有何开销"><a href="#7-那些列上适合建立索引，对性能有何开销" class="headerlink" title="7.那些列上适合建立索引，对性能有何开销"></a>7.那些列上适合建立索引，对性能有何开销</h4><p>​    主键、外键必须有索引。</p><p>​    经常需要作为（where）条件查询的列上适合创建索引，并且该列上也必须有一定的区分度。创建索引需要维护，在插入数据的时候会重新维护各个索引树（<strong>数据页的分裂与合并</strong>），对性能造成影响。</p><h4 id="8-“行级锁什么时候会锁住整个表？“"><a href="#8-“行级锁什么时候会锁住整个表？“" class="headerlink" title="8.“行级锁什么时候会锁住整个表？“"></a>8.“行级锁什么时候会锁住整个表？“</h4><p>​    InnoDB行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。</p><h4 id="9-MySQL中建表的约束"><a href="#9-MySQL中建表的约束" class="headerlink" title="9.MySQL中建表的约束"></a>9.MySQL中建表的约束</h4><ul><li>主键约束：唯一性，非空性</li><li>唯一约束：唯一性，可以空，但只能有一个</li><li>检查约束：对该列数据的范围、格式的限制</li><li>默认约束：该数据的默认值</li><li>外键约束：需要建立两表间的关系并引用主表的列</li></ul><h4 id="10-SQL语句的优化有哪些？"><a href="#10-SQL语句的优化有哪些？" class="headerlink" title="10.SQL语句的优化有哪些？"></a>10.SQL语句的优化有哪些？</h4><ul><li>为经常使用的字段（排序、搜索）建立索引</li><li>字段的种类尽可能用int 或者tinyint类型。另外字段尽可能用NOT NULL。</li><li>select * 尽量少用，你想要什么字段 就select 什么字段出来 不要老是用* 号！同理，只要一行数据时尽量使用 LIMIT 1</li></ul><h4 id="11-order-by是怎么工作的？"><a href="#11-order-by是怎么工作的？" class="headerlink" title="11.order by是怎么工作的？"></a>11.order by是怎么工作的？</h4><p>​    ORDER BY 语句用于对结果集进行排序。以下面的语句进行分析：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> city,<span class="keyword">name</span>,age <span class="keyword">from</span> t <span class="keyword">where</span> city=<span class="string">&#x27;杭州&#x27;</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">name</span> <span class="keyword">limit</span> <span class="number">1000</span> ;</span><br></pre></td></tr></table></figure><p>city字段建立了索引，过程如下：</p><ul><li><p>初始化 sort_buffer, 确认放入 name, city, age 这三个字段。</p></li><li><p>从索引 city 找到第一个满足 city=’杭州’条件的主键 id。</p></li><li><p>回表取到 name, city, age 三个字段值，存入 sort_buffer 中。</p></li><li><p>从索引 city 取下一个主键 id 记录。</p></li><li><p>重复 3-4 步骤，直到 city 不满足条件。</p></li><li><p>对 sort_buffer 中的数据按照字段 name 做快速排序。</p></li><li><p>排序结果取前 1000 行返回给客户端。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-说一说MySQL中的索引&quot;&gt;&lt;a href=&quot;#1-说一说MySQL中的索引&quot; class=&quot;headerlink&quot; title=&quot;1.说一说MySQL中的索引&quot;&gt;&lt;/a&gt;1.说一说MySQL中的索引&lt;/h4&gt;&lt;p&gt;​    MySQL数据库的索引是用B+树实</summary>
      
    
    
    
    <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库基础概念</title>
    <link href="http://yoursite.com/2020/08/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2020/08/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2020-08-13T13:22:53.000Z</published>
    <updated>2020-08-15T14:19:12.413Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h4><p>事务指的是满足ACID的一组操作，它可以通过Commit提交一个事务，也可以使用Rollback进行回滚。</p><ol><li><p><strong>原子性（Atomicity）</strong></p><p>事务被视为不可分割的最小单元，事务的所有操作要么全部完成后提交，要么全部失败回滚。</p><p>回滚可以通过回滚日志（Undo log）实现，里面记录着事务所执行的所有修改操作，回滚时反向执行即可。</p></li><li><p><strong>一致性（Consistency）</strong></p><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果是相同的。</p></li><li><p><strong>隔离性（Isolation）</strong></p><p>一个事务所作的更改在提交前对其他事务是不可见的。</p></li><li><p><strong>持久性（Durability）</strong></p><p>一旦事务提交，其所作的更改就会永远保持到数据库中。即使数据库发生崩溃，事务的执行的结果也不能丢失。</p><p>系统发生崩溃时，可以通过重做日志（Redo Log）进行修复，从而实现持久性。与回滚日志不同记录的数据的逻辑修改不同，重做日志记录的是数据页的物理更改。</p></li></ol><p>事务的ACID特性概念简单，但不好理解，主要是这几个特性不是一种平级关系：</p><ul><li>一致性是基本保证的，只有满足一致性，事务的执行结果才是正确的</li><li>在无并发情形下，事务串行执行，隔离性一定满足。此时只要满足原子性就能满足一致性</li><li>在并发情形下，多个事务并发执行，事务不仅要满足原子性，还要满足隔离性，才能满足一致性</li><li>事务满足持久性，是为了应对系统崩溃情况</li></ul><h4 id="二、并发一致性问题"><a href="#二、并发一致性问题" class="headerlink" title="二、并发一致性问题"></a>二、并发一致性问题</h4><p>并发条件下，事务的隔离性很难保证，因为会出现很多并发一致性问题。</p><ol><li><p><strong>丢失修改</strong></p><p>T1，T2两个事务都对一个数据进行修改，T1先修改，T2后修改，此时T2的修改会覆盖T1的修改。</p></li></ol><p><img src="C:\Users\Liuyz\Desktop\面试备战笔记\images\丢失修改.png" alt="丢失修改"></p><ol start="2"><li><p><strong>读脏数据</strong></p><p>T1修改一个数据，T2随后读取了该数据。如果T1撤销了这次修改（发生了回滚），那么T2读到的数据是脏数据。</p><p><img src="C:\Users\Liuyz\Desktop\面试备战笔记\images\读脏数据.png" alt="读脏数据"></p></li><li><p><strong>不可重复读</strong></p><p>T2读取了一个数据，随后T1修改了该数据。如果T2再次读该数据，此时读取的数据与第一次不一致。</p><p><img src="C:\Users\Liuyz\Desktop\面试备战笔记\images\不可重复读.png" alt="不可重复读"></p></li><li><p><strong>幻读</strong></p><p>T1读取了某个范围内的数据，随后T2在这个范围内插入了一条数据。T1再次查询这个范围内的数据的话，此时读取的结果与第一次不同。</p><p><img src="C:\Users\Liuyz\Desktop\面试备战笔记\images\幻读.png" alt="幻读"></p></li></ol><h4 id="三、数据库中的锁机制"><a href="#三、数据库中的锁机制" class="headerlink" title="三、数据库中的锁机制"></a>三、数据库中的锁机制</h4><ol><li><p><strong>锁的粒度</strong></p><p>MySQL中提供了两种锁的粒度：行级锁和表级锁。</p><p>降低锁的粒度，可以减少锁的竞争，提升系统的并发程度。</p><p>但是加锁需要消耗资源，锁的各种实现都会增加系统负担。锁粒度越小，系统开销越大。</p><p>因此需要平衡锁开销和并发度。</p></li><li><p><strong>锁的类型</strong></p><p>独占锁（Exclusive），简写为 X 锁，又称写锁。</p><p>共享锁（Shared），简写为 S 锁，又称读锁。</p><p>有以下两个规定：</p><p>​    一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</p><p>​    一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</p><p><strong>补充</strong>（不太懂）</p><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><p>​    一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</p><p>​    一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</p><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p></li><li><p><strong>封锁协议</strong></p><p><strong>一级封锁协议</strong>：事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><p><strong>二级封锁协议</strong>：在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><p><strong>三级封锁协议</strong>：在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><p><strong>两端锁协议</strong>：加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件，但不是必要条件。</p></li></ol><h4 id="四、事务的隔离级别"><a href="#四、事务的隔离级别" class="headerlink" title="四、事务的隔离级别"></a>四、事务的隔离级别</h4><ol><li><p><strong>读未提交（READ UNCOMMITTED）</strong></p><p>一个事务可以读取到另一个事务没有提交的数据。无法避免任何一种情况。</p></li><li><p><strong>读提交（READ COMMITTED）</strong></p><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。可以解决脏读。</p></li><li><p><strong>可重复读（REPEATABLE READ）</strong></p><p>保证在同一个事务中多次读取同一数据的结果是一样的。可以解决不可重复读。</p></li><li><p><strong>序列化（SERIALIZABLE）</strong></p><p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p><p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p></li></ol><h4 id="五、多版本并发控制"><a href="#五、多版本并发控制" class="headerlink" title="五、多版本并发控制"></a>五、多版本并发控制</h4><h4 id="六、关系数据库设计理论"><a href="#六、关系数据库设计理论" class="headerlink" title="六、关系数据库设计理论"></a>六、关系数据库设计理论</h4><p><strong>数据库三大范式：</strong></p><ul><li><strong>属性不可分</strong>：每一列属性都是不可再分的属性值，确保每一列的原子性，两列属性相近或一样，尽量合并属性一样的列，确保不产生冗余数据。</li><li>每一行的数据只能与其中一列相关，一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。</li><li>数据不能存在传递关系，每个属性都与主键有直接关系而不是间接关系。</li></ul><h4 id="七、常见问题"><a href="#七、常见问题" class="headerlink" title="七、常见问题"></a>七、常见问题</h4><ol><li><p><strong>数据库索引用过哪些，什么情况失效？</strong></p><p>主键索引（聚簇索引）、普通索引、唯一索引、全文索引</p><p>where 语句中使用or，但是没有把or中的所有字段都加上索引，索引失效。</p></li></ol><p>　　where 语句使用&lt;&gt;和!=</p><p>　　like查询以“%…”开头</p><p>　　如果mysql估计全表扫描更快的话</p><ol start="2"><li><p><strong>LIMIT M, N</strong> </p><p>LIMIT 给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目（初始记录行的偏移量是 0而不是 1)。</p><p>LIMIT M 等价于LIMIT 0, M</p></li><li><p><strong>drop和delete的区别</strong></p><p>delete 删除的是 <strong>数据，</strong>drop语句删除表结构及所有数据，并将表所占用的空间全部释放</p></li></ol><p>　　delete会触发触发器，drop不会触发触发器；</p><ol start="4"><li><p><strong>数据库事务的应用场景</strong></p><p>在执行一系列数据库操作时，要保证这些操作必须完全正确执行，否则就不执行，在这种情况下，适合使用事务，例如将一些数据插入到两个相关联的表中，而且不能只有一张表插入成功，这种情况下，使用事务，无论是否插入成功，都不会对数据库造成不好的影响。</p></li><li><p><strong>数据库索引的创建原则</strong></p><p>表的主键、外键必须有索引;</p><p>经常查询的数据列最好建立索引</p><p>对于需要在指定范围内的快速或频繁查询的数据列;</p><p>经常用在WHERE子句中的数据列。</p><p>经常出现在关键字order by、group by、distinct后面的字段，建立索引。如果建立的是复合索引，索引的字段顺序要和这些关键字后面的字段顺序一致，否则索引不会被使用。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、事务&quot;&gt;&lt;a href=&quot;#一、事务&quot; class=&quot;headerlink&quot; title=&quot;一、事务&quot;&gt;&lt;/a&gt;一、事务&lt;/h4&gt;&lt;p&gt;事务指的是满足ACID的一组操作，它可以通过Commit提交一个事务，也可以使用Rollback进行回滚。&lt;/p&gt;
&lt;ol&gt;</summary>
      
    
    
    
    <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis缓存雪崩、穿透、击穿</title>
    <link href="http://yoursite.com/2020/08/13/Redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF/"/>
    <id>http://yoursite.com/2020/08/13/Redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF/</id>
    <published>2020-08-13T13:22:53.000Z</published>
    <updated>2020-08-15T14:18:45.548Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-缓存雪崩了解吗"><a href="#1-缓存雪崩了解吗" class="headerlink" title="1.缓存雪崩了解吗"></a>1.缓存雪崩了解吗</h4><p>​    Redis中数据同一时刻大面积失效，那一瞬间Redis和没有一样，此时如果存在大量请求，会直接打到MySql数据库上，MySql数据库会瘫痪，无法提供服务，整个系统就崩掉了。</p><p><strong>如何应对呢？</strong></p><p>​    处理缓存雪崩很简单，在批量往Redis存数据的时候，把每个key的失效时间加个随机值就好了，保证数据在同一时刻不会大面积失效，数据库负担过重。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setRedis（Key，value，time + Math.random() * 10000）;</span><br></pre></td></tr></table></figure><p>​    如果Redis时集群部署，可以将热点数据均匀分散到各个Redis库中，避免全部失效。</p><p>​    也可以设置热点数据永不过期，更新时覆盖即可。</p><h4 id="2-缓存穿透、击穿"><a href="#2-缓存穿透、击穿" class="headerlink" title="2.缓存穿透、击穿"></a>2.缓存穿透、击穿</h4><p>​    缓存穿透是指缓存和数据库中都没有的数据，而用户在不断的发送请求。此时的用户很有可能是攻击者，会导致数据库压力过大。（先查缓存，没有就去数据库查）</p><p><strong>如何解决呢？</strong></p><ul><li><p>增加校验，拦截不合理的请求。</p></li><li><p>从缓存和数据库都取不到的数据，可以在缓存中添加key对应valu为null的一条数据，有效时间可以设置短点</p></li></ul><p>​    缓存击穿和缓存雪崩类似，但有点不同。缓存击穿指的是有一个key非常热点，在不停的扛着大并发，在该key失效的一瞬间，会有大量请求击穿缓存打到数据库，导致数据库负担过重。</p><p><strong>如何解决呢？</strong></p><ul><li>设置热点数据永不过期</li><li>加上互斥锁</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;1-缓存雪崩了解吗&quot;&gt;&lt;a href=&quot;#1-缓存雪崩了解吗&quot; class=&quot;headerlink&quot; title=&quot;1.缓存雪崩了解吗&quot;&gt;&lt;/a&gt;1.缓存雪崩了解吗&lt;/h4&gt;&lt;p&gt;​    Redis中数据同一时刻大面积失效，那一瞬间Redis和没有一样，此时如果</summary>
      
    
    
    
    <category term="redis" scheme="http://yoursite.com/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://yoursite.com/2020/08/13/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/08/13/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-08-13T13:17:53.000Z</published>
    <updated>2020-08-15T14:18:07.687Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、JMM中的主内存和工作内存"><a href="#一、JMM中的主内存和工作内存" class="headerlink" title="一、JMM中的主内存和工作内存"></a>一、JMM中的主内存和工作内存</h4><p>​    Java内存模型（即Java Memory Model，简称JMM）本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括字段、静态字段、和构成数组对象元素）的访问方式。</p><p>​    所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在告诉缓存或者寄存器中，保存了该线程使用的变量从主内存副本拷贝。</p><p>​    线程只能直接操作工作内存中的变量，不同线程之间的变量传递需要通过主内存来完成。</p><p><strong>JMM中的主内存：</strong></p><ul><li>存储Java实例对象</li><li>包括成员变量、类信息、常量、静态变量</li><li>属于数据共享的区域，多线程并发操作会引发线程安全问题</li></ul><p><strong>JMM中的工作内存：</strong></p><ul><li>存储当前方法的所有本地变量信息，本地变量对其他线程不可见</li><li>字节码行号指示器、Native方法等</li><li>属于线程私有区域，不存在线程安全问题</li></ul><p><strong>JMM和Java内存区域划分是不同的概念层次</strong></p><ul><li>JMM描述的是一组规则，围绕原子性、有序性、可见性展开</li><li>相似点：存在共享区域和私有区域</li></ul><p><strong>主内存与工作内存的数据存储类型以及操作方式归纳</strong></p><ul><li>方法里的基本数据类型本地变量将直接存储在工作内存的栈帧结构中</li><li>引用类型的本地变量：引用存储在工作内存中，实例存储在主内存中</li><li>成员变量、static变量、类信息存储在主内存中</li><li>主内存共享的方式是线程各拷贝一份数据到工作内存，操作完成后刷新到主内存</li></ul><h4 id="二、内存模型的三大特性"><a href="#二、内存模型的三大特性" class="headerlink" title="二、内存模型的三大特性"></a>二、内存模型的三大特性</h4><ol><li><p>原子性</p><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p></li><li><p>可见性</p><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p></li></ol><p>​    主要有三种实现可见性的方式：</p><ul><li><p>volatile</p></li><li><p>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</p></li><li><p>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</p><p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p></li></ul><ol start="3"><li><p>有序性</p><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p><p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p></li></ol><h4 id="三、happen-before原则"><a href="#三、happen-before原则" class="headerlink" title="三、happen-before原则"></a>三、happen-before原则</h4><p>- </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、JMM中的主内存和工作内存&quot;&gt;&lt;a href=&quot;#一、JMM中的主内存和工作内存&quot; class=&quot;headerlink&quot; title=&quot;一、JMM中的主内存和工作内存&quot;&gt;&lt;/a&gt;一、JMM中的主内存和工作内存&lt;/h4&gt;&lt;p&gt;​    Java内存模型（即Jav</summary>
      
    
    
    
    <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发基础</title>
    <link href="http://yoursite.com/2020/08/13/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/08/13/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</id>
    <published>2020-08-13T10:17:53.000Z</published>
    <updated>2020-08-15T14:18:02.284Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、关于并发的相关概念"><a href="#一、关于并发的相关概念" class="headerlink" title="一、关于并发的相关概念"></a>一、关于并发的相关概念</h3><h4 id="1-多线程、并发、并行、"><a href="#1-多线程、并发、并行、" class="headerlink" title="1. 多线程、并发、并行、"></a>1. 多线程、并发、并行、</h4><ul><li><p><strong>并发</strong>：多个线程在同一<strong>时间段</strong>内同时执行。</p></li><li><p><strong>并行</strong>：多个线程在同一<strong>时刻</strong>同时时执行。</p></li></ul><p>​    通常一个处理器（或一个核）同一时刻只能处理一个线程，而线程在某些时候可能不需要cpu，在此时可以让cpu去执行其他地任务。为了充分地利用计算机资源，可以创建多个线程，在线程不需要cpu时，转而去执行其他的线程。</p><p>​    然而多线程会带来额外的开销：<strong>上下文切换</strong>、<strong>线程调度</strong></p><h4 id="2-什么是上下文切换"><a href="#2-什么是上下文切换" class="headerlink" title="2. 什么是上下文切换"></a>2. 什么是上下文切换</h4><p>​    当cpu从一个线程切换为另一个线程时，在切换前需要保存上一个线程的状态，切换后需要恢复下一个线程的状态。所以任务（线程）从保存到加载的过程就是一次上下文切换。</p><p><strong>如何减少上下文切换</strong></p><ul><li><strong>无锁并发编程：</strong>多线程竞争锁，会引起上下文切换（挂起）</li><li><strong>CAS算法：</strong>避免加锁</li><li><strong>使用最少线程：</strong></li><li><strong>协程：</strong>单线程实现多任务的调度</li></ul><h4 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3. 死锁"></a>3. 死锁</h4><p><strong>产生死锁的条件</strong></p><ul><li><strong>资源互斥：</strong>一个资源最多只能由一个线程获得</li><li><strong>请求保持：</strong>线程在请求其他资源时，不放弃已获得资源</li><li><strong>不可剥夺：</strong>一个线程获得的资源无法被其他线程剥夺</li><li><strong>环路等待：</strong> 资源的请求构成了请求环路</li></ul><p><strong>如何避免死锁</strong></p><ul><li>避免一个线程同时获取多个锁</li><li>使用定时锁</li></ul><h4 id="3-多线程一定快吗"><a href="#3-多线程一定快吗" class="headerlink" title="3. 多线程一定快吗"></a>3. 多线程一定快吗</h4><p>​    在一些情形下，多线程并不一定比单线程快：</p><ul><li>任务量比较小，单线程在很短的时间内就能完成</li><li>资源限制，如网速、硬盘读写速度、数据库连接池</li></ul><h3 id="二、Java并发机制的底层原理"><a href="#二、Java并发机制的底层原理" class="headerlink" title="二、Java并发机制的底层原理"></a>二、Java并发机制的底层原理</h3><h4 id="1-volatile"><a href="#1-volatile" class="headerlink" title="1. volatile"></a>1. volatile</h4><p>​    被volatile声明的变量，在修改时会发生两件事：</p><ul><li><strong>当前处理器缓存行的数据写回到系统内存</strong></li><li><strong>将其他CPU里缓存了该内存地址的数据置为无效</strong></li></ul><h4 id="2-Synchronized"><a href="#2-Synchronized" class="headerlink" title="2. Synchronized"></a>2. Synchronized</h4><p>​    Java中所有的对象都可以作为锁(通过对象头标记)，具体表现如下：</p><ul><li><p>Synchronized作用于普通方法：锁是当前对象</p></li><li><p>Synchronized作用于静态方法：锁是当前类的Class对象</p></li><li><p>Synchronized作用于方法快：锁是括号中的对象</p><p> Java引入了偏向锁和轻量级锁，来减少获得锁和释放锁带来的性能损耗。锁一共有四章状态：无锁、偏向锁、轻量级锁、重量级锁。这几个状态，会随着竞争情况逐渐升级，锁可以升级但不能降级。</p></li></ul><p><strong>偏向锁</strong></p><p>​    很多情况下，一个锁是总是由一个线程多次获得。获得偏向锁的线程再次获得该锁，可以直接获得，无需加锁和解锁。</p><p><strong>轻量级锁</strong></p><p>​    在获得锁时，自旋一定时间多次获得。</p><p>​    竞争的线程不会被阻塞，适用于同步块可以在很快。</p><p><strong>重量级锁</strong></p><h4 id="3-原子操作"><a href="#3-原子操作" class="headerlink" title="3. 原子操作"></a>3. 原子操作</h4><p>​    Java实现原子操作可以通过<strong>锁</strong>和<strong>循环CAS</strong>的方式实现。</p><p><strong>CAS带来的问题</strong></p><ul><li>ABA问题</li><li>循环带来额外开销：</li><li>只能保证一个变量的原子性：</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、关于并发的相关概念&quot;&gt;&lt;a href=&quot;#一、关于并发的相关概念&quot; class=&quot;headerlink&quot; title=&quot;一、关于并发的相关概念&quot;&gt;&lt;/a&gt;一、关于并发的相关概念&lt;/h3&gt;&lt;h4 id=&quot;1-多线程、并发、并行、&quot;&gt;&lt;a href=&quot;#1-多线程</summary>
      
    
    
    
    <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
    <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
    <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="volatile" scheme="http://yoursite.com/tags/volatile/"/>
    
    <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>java02</title>
    <link href="http://yoursite.com/2020/08/12/java%E4%B8%AD%E7%9A%84Object%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/08/12/java%E4%B8%AD%E7%9A%84Object%E7%B1%BB/</id>
    <published>2020-08-12T13:12:47.000Z</published>
    <updated>2020-08-15T14:18:31.272Z</updated>
    
    <content type="html"><![CDATA[<p>Java是纯面向对象的语言，换言之，在Java中一切都是对象。而Object类是Java中所有类的基类，也就是说所有类都直接或间接继承自Object。</p><p>​    在继承体系中，父类是基础，子类是对父类的扩充和丰富，所以理解Object类对理解其他类至关重要。理解Object类，关键在于其实现的方法。</p><h4 id="1-getClass"><a href="#1-getClass" class="headerlink" title="1.getClass()"></a>1.getClass()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final native Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><p>​    返回对象的Class对象，可以看出是个native方法。</p><h4 id="2-hashCode"><a href="#2-hashCode" class="headerlink" title="2.hashCode()"></a>2.hashCode()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public native int hashCode();</span><br></pre></td></tr></table></figure><p>​    返回对象的hashcode值，也是个native方法，</p><h4 id="3-equals"><a href="#3-equals" class="headerlink" title="3.equals()"></a>3.equals()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">    return (this &#x3D;&#x3D; obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    判断对象是否相同，注意这里<strong>判断的是引用</strong>。</p><h4 id="4-clone"><a href="#4-clone" class="headerlink" title="4.clone()"></a>4.clone()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected native Object clone() throws CloneNotSupportedException;</span><br></pre></td></tr></table></figure><p>​    返回该对象的克隆。</p><h4 id="5-toString"><a href="#5-toString" class="headerlink" title="5.toString()"></a>5.toString()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String toString() &#123;</span><br><span class="line">    return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    返回对象的字符串表示。</p><h4 id="6-wait"><a href="#6-wait" class="headerlink" title="6.wait()"></a>6.wait()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final native void wait(long timeout) throws InterruptedException;</span><br><span class="line">public final void wait(long timeout, int nanos) throws InterruptedException &#123;</span><br><span class="line">    if (timeout &lt; 0) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nanos &lt; 0 || nanos &gt; 999999) &#123;</span><br><span class="line">        throw new IllegalArgumentException(</span><br><span class="line">                            &quot;nanosecond timeout value out of range&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (nanos &gt; 0) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br><span class="line">public final void wait() throws InterruptedException &#123;</span><br><span class="line">    wait(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    与synchronized配合使用，释放锁使线程等待。</p><h4 id="7-notify-notifyAll"><a href="#7-notify-notifyAll" class="headerlink" title="7.notify() notifyAll()"></a>7.notify() notifyAll()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public final native void notify();</span><br><span class="line">public final native void notifyAll();</span><br></pre></td></tr></table></figure><p>​    唤醒等待的线程。</p><h4 id="8-finalize"><a href="#8-finalize" class="headerlink" title="8.finalize()"></a>8.finalize()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void finalize() throws Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><p>​    当对象没有有效引用时被垃圾回收器调用，但不保证一定会被调用。</p><h4 id="对象回收过程中的finalize-："><a href="#对象回收过程中的finalize-：" class="headerlink" title="对象回收过程中的finalize()："></a>对象回收过程中的finalize()：</h4><ul><li>通过可达性分析找到可以回收的对象</li><li>将对象加入到一个较低优先级的线程（垃圾回收器线程），线程会依次调用对象的finalize()方法</li><li>该线程执行了对象的finalize方法，若对象在该方法中实现了自救，对象不在回收</li><li>对象的finalize方法还未来得及执行（线程的优先级较低），对象被回收</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java是纯面向对象的语言，换言之，在Java中一切都是对象。而Object类是Java中所有类的基类，也就是说所有类都直接或间接继承自Object。&lt;/p&gt;
&lt;p&gt;​    在继承体系中，父类是基础，子类是对父类的扩充和丰富，所以理解Object类对理解其他类至关重要。理</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java系列之注解</title>
    <link href="http://yoursite.com/2020/08/12/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/08/12/Java%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-08-12T11:52:58.000Z</published>
    <updated>2020-08-13T00:00:59.912Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、什么是注解"><a href="#一、什么是注解" class="headerlink" title="一、什么是注解"></a>一、什么是注解</h4><p>​        Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 <code>java.lang.annotation</code> 包中。注解是ava5开始引入的新特征。</p><h4 id="二、常见的Java注解"><a href="#二、常见的Java注解" class="headerlink" title="二、常见的Java注解"></a>二、常见的Java注解</h4><ol><li><code>Override</code></li></ol><p>​        <code>java.lang.Override</code> 是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重写了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java 编译器将以一个编译错误来警示。</p><ol start="2"><li><code>Deprecated</code></li></ol><p>​        Deprecated 也是一种标记类型注解。当一个类型或者类型成员使用@Deprecated 修饰的话，编译器将不鼓励使用这个被标注的程序元素。所以使用这种修饰具有一定的“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为@Deprecated，但编译器仍然要报警。</p><ol start="3"><li><code>SuppressWarnings</code></li></ol><p>​        <code>SuppressWarning</code> 不是一个标记类型注解。它有一个类型为String[] 的成员，这个成员的值为被禁止的警告名。</p><h4 id="三、注解的语法"><a href="#三、注解的语法" class="headerlink" title="三、注解的语法"></a>三、注解的语法</h4><ol><li><p>注解定义</p><p>注解通过<code>@Interface</code>关键字进行定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnocation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注解使用</p><p>注解可以应用到类、方法、成员变量上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnocation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="四、元注解"><a href="#四、元注解" class="headerlink" title="四、元注解"></a>四、元注解</h4><p>​        元注解是作用于注解的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。元注解有：<code>@Retention</code>、<code>@Documented</code>、<code>@Target</code>、<code>@Inherited</code>、<code>@Repeatable</code> 5 种。</p><ol><li><p><code>@Retention</code> 定义该注解的生命周期</p><p>●  <code>RetentionPolicy.SOURCE</code> : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。<code>@Override</code>, <code>@SuppressWarnings</code>都属于这类注解。<br>●  <code>RetentionPolicy.CLASS</code> : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式<br>●  <code>RetentionPolicy.RUNTIME</code> : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式。</p></li><li><p><code>@Documented</code>是个标记性注解，表示是否将注解信息添加在java 文档中</p></li><li><p><code>@Target</code>表示该注解用于什么地方，默认值为任何元素</p><p>● <code>ElementType.CONSTRUCTOR</code>: 用于描述构造器<br>● <code>ElementType.FIELD</code>: 成员变量、对象、属性（包括enum实例）<br>● <code>ElementType.LOCAL_VARIABLE</code>: 用于描述局部变量<br>● <code>ElementType.METHOD</code>: 用于描述方法<br>● <code>ElementType.PACKAGE</code>: 用于描述包<br>● <code>ElementType.PARAMETER</code>: 用于描述参数<br>● <code>ElementType.TYPE</code>: 用于描述类、接口(包括注解类型) 或enum声明</p></li><li><p><code>@Inherited</code>是个标记性注解，定义该注解和子类的关系</p><p><code>@Inherited</code> 阐述了某个被标注的类型是被继承的。如果一个使用了<code>@Inherited</code> 修饰的<code>annotation</code> 类型被用于一个class，则这个<code>annotation</code> 将被用于该class 的子类。</p></li><li><p><code>@Repeatable</code> </p></li></ol><h4 id="五、注解的属性"><a href="#五、注解的属性" class="headerlink" title="五、注解的属性"></a>五、注解的属性</h4><p>​        注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnocation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">msg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在使用的时候，我们应该给它们进行赋值。赋值的方式是在注解的括号内以 value=”” 形式，多个属性之前用 ，隔开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnocation(id = 1, msg = &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        使用default关键字可以为属性指定默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnocation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;    </span><br><span class="line">    <span class="function">String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="六、自定义注解"><a href="#六、自定义注解" class="headerlink" title="六、自定义注解"></a>六、自定义注解</h4><p>自定义注解类编写的一些规则:</p><ol><li>Annotation 型定义为@interface, 所有的Annotation 会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口.</li><li>参数成员只能用public 或默认(default) 这两个访问权修饰</li><li>参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组.</li><li>要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法</li><li>注解也可以没有定义成员,，不过这样注解就没啥用了</li></ol><p>PS:<a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html">自定义注解需要使用到元注解</a></p><h4 id="七、注解原理"><a href="#七、注解原理" class="headerlink" title="七、注解原理"></a>七、注解原理</h4><p>​        注解本质是一个继承了<code>Annotation</code> 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用<code>AnnotationInvocationHandler</code> 的<code>invoke</code> 方法。该方法会从<code>memberValues</code> 这个<code>Map</code> 中索引出对应的值。而<code>memberValues</code> 的来源是Java 常量池。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、什么是注解&quot;&gt;&lt;a href=&quot;#一、什么是注解&quot; class=&quot;headerlink&quot; title=&quot;一、什么是注解&quot;&gt;&lt;/a&gt;一、什么是注解&lt;/h4&gt;&lt;p&gt;​        Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，</summary>
      
    
    
    
    <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>贝壳2021提前批笔试8.11</title>
    <link href="http://yoursite.com/2020/08/11/%E8%B4%9D%E5%A3%B3%E7%AC%94%E8%AF%958.11/"/>
    <id>http://yoursite.com/2020/08/11/%E8%B4%9D%E5%A3%B3%E7%AC%94%E8%AF%958.11/</id>
    <published>2020-08-10T16:00:00.000Z</published>
    <updated>2020-08-16T09:08:02.681Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-回文字符串"><a href="#1-回文字符串" class="headerlink" title="1.回文字符串"></a>1.回文字符串</h3><p>​    给定一个字符串str，每次可以对其中的一个字符进行修改，统计将其变为回文字符串至少要修改几次。</p><p>​    非常简单，前后两指针进行比较，统计不同的字符数即可。</p><h3 id="2-颜色填充"><a href="#2-颜色填充" class="headerlink" title="2.颜色填充"></a>2.颜色填充</h3><h5 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h5><p>​    m*n的矩阵，对其中的每个格子进行填充，有以下规则：</p><p>​        1.每个格子必须填充</p><p>​        2.相邻格子颜色不同</p><p>​        3.每种颜色的格子数相同</p><p>​    求，至少需要多少中颜色。</p><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><ul><li>其实两种颜色就能实现填充m*n格子，且相邻格子的颜色不同</li><li>为了使所有颜色的格子数相同，我们要找m*n的最小因子</li></ul><h3 id="3-数组中最大子数组的最小长度"><a href="#3-数组中最大子数组的最小长度" class="headerlink" title="3.数组中最大子数组的最小长度"></a>3.数组中最大子数组的最小长度</h3><p>给定一个数组nums, 找出其所有具有最大值的子数组的最短长度。其中，数组的值定义如下：        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组[a1, a2, a3]的值 &#x3D; a1 | a2 | a3</span><br></pre></td></tr></table></figure><p>数据范围：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums.length() &lt;&#x3D; 10^6</span><br><span class="line">数组内容全为正整数</span><br></pre></td></tr></table></figure><h5 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h5><ul><li>根据数据范围，算法复杂度必须小于O(n^2)</li><li>数组的最大值，就是所有元素或的结果</li><li>需要map进行记录，前面的状态（记录最近的，让第j位变成1的位置i）</li><li>题型类似Leetcode325：这类题都是找最大、最小的子数组，只不过条件不同。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMinLength</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">0</span>;   <span class="comment">// 所有子数组中的最大值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m : nums)&#123;</span><br><span class="line">        max |= m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = n;   <span class="comment">// 原数组肯定具有最大值</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  <span class="comment">// 记录第j位最近出现的位置i</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最大值为max，将其与m的每一位进行比较，若m对应该位的值不同(肯定为0)，</span></span><br><span class="line">        <span class="comment">// 就通过map找到最近的可以使该位为1的数的下标</span></span><br><span class="line">        <span class="comment">// 则以m为结尾的具有最大值的最小数组为，找出的所有下标的最小值</span></span><br><span class="line">        <span class="keyword">int</span> curLen = <span class="number">1</span>;   <span class="comment">// 以m为结尾数组初始长度</span></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++)&#123;   <span class="comment">// 遍历每一位</span></span><br><span class="line">            <span class="keyword">if</span>(((max&gt;&gt;j)&amp;<span class="number">1</span>) != ((m&gt;&gt;j)&amp;<span class="number">1</span>))&#123;   <span class="comment">// 第j位不同</span></span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(j))&#123;   <span class="comment">// 前面具有可以使该位为1的数</span></span><br><span class="line">                    curLen = Math.max(curLen, i - map.get(j) + <span class="number">1</span>);   <span class="comment">// 更新长度</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;   <span class="comment">// 前面没有，跳出循环，以m为结尾无法组成最大值数组</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">32</span>)&#123;   <span class="comment">// 更新比较，符合条件子数组的长度</span></span><br><span class="line">            res = Math.min(res, curLen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录最近每一位成为1的位置</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">32</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(((m&gt;&gt;j)&amp;<span class="number">1</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">                map.put(j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常可惜，当时没有做出来。</p><h3 id="4-图的最大生成树"><a href="#4-图的最大生成树" class="headerlink" title="4.图的最大生成树"></a>4.图的最大生成树</h3><p>n个城市，m条道路，每条道路具有一定的客流量。现在要去掉几条道路，使得城市之间是可达的，且剩余道路的总客流量最大。若无法可达，则输出-1，否则输出总客流量对10^9+7取余</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b c d  </span><br></pre></td></tr></table></figure><p>代表城市a和b之间的客流量为：<br>$$<br>C_c^d<br>$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n&lt;&#x3D;10^3</span><br></pre></td></tr></table></figure><h5 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h5><ul><li>dfs方法，会遍历所有的边，指数级增长，肯定会超时</li><li>这道题本质是求图的最大生成树</li><li>图的相关算法需要总结，太陌生了</li></ul><p>使用普利姆算法，贪心的求最大生成树，只能通过40%:</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-回文字符串&quot;&gt;&lt;a href=&quot;#1-回文字符串&quot; class=&quot;headerlink&quot; title=&quot;1.回文字符串&quot;&gt;&lt;/a&gt;1.回文字符串&lt;/h3&gt;&lt;p&gt;​    给定一个字符串str，每次可以对其中的一个字符进行修改，统计将其变为回文字符串至少要修改几</summary>
      
    
    
    
    <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
    <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="贝壳" scheme="http://yoursite.com/tags/%E8%B4%9D%E5%A3%B3/"/>
    
  </entry>
  
</feed>
